
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model alert
 * 
 */
export type alert = $Result.DefaultSelection<Prisma.$alertPayload>
/**
 * Model device
 * 
 */
export type device = $Result.DefaultSelection<Prisma.$devicePayload>
/**
 * Model device_type
 * 
 */
export type device_type = $Result.DefaultSelection<Prisma.$device_typePayload>
/**
 * Model emergency_contact
 * 
 */
export type emergency_contact = $Result.DefaultSelection<Prisma.$emergency_contactPayload>
/**
 * Model env_delimiter
 * 
 */
export type env_delimiter = $Result.DefaultSelection<Prisma.$env_delimiterPayload>
/**
 * Model env_user
 * 
 */
export type env_user = $Result.DefaultSelection<Prisma.$env_userPayload>
/**
 * Model environment
 * 
 */
export type environment = $Result.DefaultSelection<Prisma.$environmentPayload>
/**
 * Model expense
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type expense = $Result.DefaultSelection<Prisma.$expensePayload>
/**
 * Model format
 * 
 */
export type format = $Result.DefaultSelection<Prisma.$formatPayload>
/**
 * Model helper_user
 * 
 */
export type helper_user = $Result.DefaultSelection<Prisma.$helper_userPayload>
/**
 * Model intervention_history
 * 
 */
export type intervention_history = $Result.DefaultSelection<Prisma.$intervention_historyPayload>
/**
 * Model localisation
 * 
 */
export type localisation = $Result.DefaultSelection<Prisma.$localisationPayload>
/**
 * Model map
 * 
 */
export type map = $Result.DefaultSelection<Prisma.$mapPayload>
/**
 * Model market_potentiel
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type market_potentiel = $Result.DefaultSelection<Prisma.$market_potentielPayload>
/**
 * Model panne_history
 * 
 */
export type panne_history = $Result.DefaultSelection<Prisma.$panne_historyPayload>
/**
 * Model poi
 * 
 */
export type poi = $Result.DefaultSelection<Prisma.$poiPayload>
/**
 * Model poi_category
 * 
 */
export type poi_category = $Result.DefaultSelection<Prisma.$poi_categoryPayload>
/**
 * Model poi_zone
 * 
 */
export type poi_zone = $Result.DefaultSelection<Prisma.$poi_zonePayload>
/**
 * Model pricing
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type pricing = $Result.DefaultSelection<Prisma.$pricingPayload>
/**
 * Model purchase_history
 * 
 */
export type purchase_history = $Result.DefaultSelection<Prisma.$purchase_historyPayload>
/**
 * Model state_type
 * 
 */
export type state_type = $Result.DefaultSelection<Prisma.$state_typePayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model user_type
 * 
 */
export type user_type = $Result.DefaultSelection<Prisma.$user_typePayload>
/**
 * Model zone
 * 
 */
export type zone = $Result.DefaultSelection<Prisma.$zonePayload>
/**
 * Model zone_type
 * This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
 */
export type zone_type = $Result.DefaultSelection<Prisma.$zone_typePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ExpenseCategory: {
  COGS: 'COGS',
  SALARY: 'SALARY',
  MAINTENANCE: 'MAINTENANCE',
  UTILITIES: 'UTILITIES',
  MARKETING: 'MARKETING',
  OTHER: 'OTHER'
};

export type ExpenseCategory = (typeof ExpenseCategory)[keyof typeof ExpenseCategory]


export const intervention_type: {
  technique: 'technique',
  Non_technique: 'Non_technique'
};

export type intervention_type = (typeof intervention_type)[keyof typeof intervention_type]


export const level_new: {
  critique: 'critique',
  modere: 'modere',
  mineur: 'mineur'
};

export type level_new = (typeof level_new)[keyof typeof level_new]


export const type: {
  technique: 'technique',
  Non_technique: 'Non_technique'
};

export type type = (typeof type)[keyof typeof type]

}

export type ExpenseCategory = $Enums.ExpenseCategory

export const ExpenseCategory: typeof $Enums.ExpenseCategory

export type intervention_type = $Enums.intervention_type

export const intervention_type: typeof $Enums.intervention_type

export type level_new = $Enums.level_new

export const level_new: typeof $Enums.level_new

export type type = $Enums.type

export const type: typeof $Enums.type

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Alerts
 * const alerts = await prisma.alert.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Alerts
   * const alerts = await prisma.alert.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.alert`: Exposes CRUD operations for the **alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.alertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.deviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.device_type`: Exposes CRUD operations for the **device_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Device_types
    * const device_types = await prisma.device_type.findMany()
    * ```
    */
  get device_type(): Prisma.device_typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emergency_contact`: Exposes CRUD operations for the **emergency_contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emergency_contacts
    * const emergency_contacts = await prisma.emergency_contact.findMany()
    * ```
    */
  get emergency_contact(): Prisma.emergency_contactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.env_delimiter`: Exposes CRUD operations for the **env_delimiter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Env_delimiters
    * const env_delimiters = await prisma.env_delimiter.findMany()
    * ```
    */
  get env_delimiter(): Prisma.env_delimiterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.env_user`: Exposes CRUD operations for the **env_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Env_users
    * const env_users = await prisma.env_user.findMany()
    * ```
    */
  get env_user(): Prisma.env_userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.environment`: Exposes CRUD operations for the **environment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Environments
    * const environments = await prisma.environment.findMany()
    * ```
    */
  get environment(): Prisma.environmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.expenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.format`: Exposes CRUD operations for the **format** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Formats
    * const formats = await prisma.format.findMany()
    * ```
    */
  get format(): Prisma.formatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.helper_user`: Exposes CRUD operations for the **helper_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Helper_users
    * const helper_users = await prisma.helper_user.findMany()
    * ```
    */
  get helper_user(): Prisma.helper_userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.intervention_history`: Exposes CRUD operations for the **intervention_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Intervention_histories
    * const intervention_histories = await prisma.intervention_history.findMany()
    * ```
    */
  get intervention_history(): Prisma.intervention_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.localisation`: Exposes CRUD operations for the **localisation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Localisations
    * const localisations = await prisma.localisation.findMany()
    * ```
    */
  get localisation(): Prisma.localisationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.map`: Exposes CRUD operations for the **map** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maps
    * const maps = await prisma.map.findMany()
    * ```
    */
  get map(): Prisma.mapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.market_potentiel`: Exposes CRUD operations for the **market_potentiel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Market_potentiels
    * const market_potentiels = await prisma.market_potentiel.findMany()
    * ```
    */
  get market_potentiel(): Prisma.market_potentielDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.panne_history`: Exposes CRUD operations for the **panne_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Panne_histories
    * const panne_histories = await prisma.panne_history.findMany()
    * ```
    */
  get panne_history(): Prisma.panne_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.poi`: Exposes CRUD operations for the **poi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pois
    * const pois = await prisma.poi.findMany()
    * ```
    */
  get poi(): Prisma.poiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.poi_category`: Exposes CRUD operations for the **poi_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Poi_categories
    * const poi_categories = await prisma.poi_category.findMany()
    * ```
    */
  get poi_category(): Prisma.poi_categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.poi_zone`: Exposes CRUD operations for the **poi_zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Poi_zones
    * const poi_zones = await prisma.poi_zone.findMany()
    * ```
    */
  get poi_zone(): Prisma.poi_zoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pricing`: Exposes CRUD operations for the **pricing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pricings
    * const pricings = await prisma.pricing.findMany()
    * ```
    */
  get pricing(): Prisma.pricingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchase_history`: Exposes CRUD operations for the **purchase_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchase_histories
    * const purchase_histories = await prisma.purchase_history.findMany()
    * ```
    */
  get purchase_history(): Prisma.purchase_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.state_type`: Exposes CRUD operations for the **state_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more State_types
    * const state_types = await prisma.state_type.findMany()
    * ```
    */
  get state_type(): Prisma.state_typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_type`: Exposes CRUD operations for the **user_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_types
    * const user_types = await prisma.user_type.findMany()
    * ```
    */
  get user_type(): Prisma.user_typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zone`: Exposes CRUD operations for the **zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zone.findMany()
    * ```
    */
  get zone(): Prisma.zoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zone_type`: Exposes CRUD operations for the **zone_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zone_types
    * const zone_types = await prisma.zone_type.findMany()
    * ```
    */
  get zone_type(): Prisma.zone_typeDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    alert: 'alert',
    device: 'device',
    device_type: 'device_type',
    emergency_contact: 'emergency_contact',
    env_delimiter: 'env_delimiter',
    env_user: 'env_user',
    environment: 'environment',
    expense: 'expense',
    format: 'format',
    helper_user: 'helper_user',
    intervention_history: 'intervention_history',
    localisation: 'localisation',
    map: 'map',
    market_potentiel: 'market_potentiel',
    panne_history: 'panne_history',
    poi: 'poi',
    poi_category: 'poi_category',
    poi_zone: 'poi_zone',
    pricing: 'pricing',
    purchase_history: 'purchase_history',
    state_type: 'state_type',
    user: 'user',
    user_type: 'user_type',
    zone: 'zone',
    zone_type: 'zone_type'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "alert" | "device" | "device_type" | "emergency_contact" | "env_delimiter" | "env_user" | "environment" | "expense" | "format" | "helper_user" | "intervention_history" | "localisation" | "map" | "market_potentiel" | "panne_history" | "poi" | "poi_category" | "poi_zone" | "pricing" | "purchase_history" | "state_type" | "user" | "user_type" | "zone" | "zone_type"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      alert: {
        payload: Prisma.$alertPayload<ExtArgs>
        fields: Prisma.alertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.alertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.alertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload>
          }
          findFirst: {
            args: Prisma.alertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.alertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload>
          }
          findMany: {
            args: Prisma.alertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload>[]
          }
          create: {
            args: Prisma.alertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload>
          }
          createMany: {
            args: Prisma.alertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.alertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload>[]
          }
          delete: {
            args: Prisma.alertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload>
          }
          update: {
            args: Prisma.alertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload>
          }
          deleteMany: {
            args: Prisma.alertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.alertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.alertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload>[]
          }
          upsert: {
            args: Prisma.alertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.alertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.alertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      device: {
        payload: Prisma.$devicePayload<ExtArgs>
        fields: Prisma.deviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.deviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.deviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload>
          }
          findFirst: {
            args: Prisma.deviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.deviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload>
          }
          findMany: {
            args: Prisma.deviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload>[]
          }
          create: {
            args: Prisma.deviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload>
          }
          createMany: {
            args: Prisma.deviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.deviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload>[]
          }
          delete: {
            args: Prisma.deviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload>
          }
          update: {
            args: Prisma.deviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload>
          }
          deleteMany: {
            args: Prisma.deviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.deviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.deviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload>[]
          }
          upsert: {
            args: Prisma.deviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload>
          }
          aggregate: {
            args: Prisma.DeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice>
          }
          groupBy: {
            args: Prisma.deviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.deviceCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceCountAggregateOutputType> | number
          }
        }
      }
      device_type: {
        payload: Prisma.$device_typePayload<ExtArgs>
        fields: Prisma.device_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.device_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.device_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_typePayload>
          }
          findFirst: {
            args: Prisma.device_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.device_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_typePayload>
          }
          findMany: {
            args: Prisma.device_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_typePayload>[]
          }
          create: {
            args: Prisma.device_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_typePayload>
          }
          createMany: {
            args: Prisma.device_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.device_typeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_typePayload>[]
          }
          delete: {
            args: Prisma.device_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_typePayload>
          }
          update: {
            args: Prisma.device_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_typePayload>
          }
          deleteMany: {
            args: Prisma.device_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.device_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.device_typeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_typePayload>[]
          }
          upsert: {
            args: Prisma.device_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_typePayload>
          }
          aggregate: {
            args: Prisma.Device_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice_type>
          }
          groupBy: {
            args: Prisma.device_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Device_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.device_typeCountArgs<ExtArgs>
            result: $Utils.Optional<Device_typeCountAggregateOutputType> | number
          }
        }
      }
      emergency_contact: {
        payload: Prisma.$emergency_contactPayload<ExtArgs>
        fields: Prisma.emergency_contactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.emergency_contactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emergency_contactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.emergency_contactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emergency_contactPayload>
          }
          findFirst: {
            args: Prisma.emergency_contactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emergency_contactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.emergency_contactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emergency_contactPayload>
          }
          findMany: {
            args: Prisma.emergency_contactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emergency_contactPayload>[]
          }
          create: {
            args: Prisma.emergency_contactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emergency_contactPayload>
          }
          createMany: {
            args: Prisma.emergency_contactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.emergency_contactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emergency_contactPayload>[]
          }
          delete: {
            args: Prisma.emergency_contactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emergency_contactPayload>
          }
          update: {
            args: Prisma.emergency_contactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emergency_contactPayload>
          }
          deleteMany: {
            args: Prisma.emergency_contactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.emergency_contactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.emergency_contactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emergency_contactPayload>[]
          }
          upsert: {
            args: Prisma.emergency_contactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emergency_contactPayload>
          }
          aggregate: {
            args: Prisma.Emergency_contactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmergency_contact>
          }
          groupBy: {
            args: Prisma.emergency_contactGroupByArgs<ExtArgs>
            result: $Utils.Optional<Emergency_contactGroupByOutputType>[]
          }
          count: {
            args: Prisma.emergency_contactCountArgs<ExtArgs>
            result: $Utils.Optional<Emergency_contactCountAggregateOutputType> | number
          }
        }
      }
      env_delimiter: {
        payload: Prisma.$env_delimiterPayload<ExtArgs>
        fields: Prisma.env_delimiterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.env_delimiterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_delimiterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.env_delimiterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_delimiterPayload>
          }
          findFirst: {
            args: Prisma.env_delimiterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_delimiterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.env_delimiterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_delimiterPayload>
          }
          findMany: {
            args: Prisma.env_delimiterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_delimiterPayload>[]
          }
          create: {
            args: Prisma.env_delimiterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_delimiterPayload>
          }
          createMany: {
            args: Prisma.env_delimiterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.env_delimiterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_delimiterPayload>[]
          }
          delete: {
            args: Prisma.env_delimiterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_delimiterPayload>
          }
          update: {
            args: Prisma.env_delimiterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_delimiterPayload>
          }
          deleteMany: {
            args: Prisma.env_delimiterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.env_delimiterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.env_delimiterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_delimiterPayload>[]
          }
          upsert: {
            args: Prisma.env_delimiterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_delimiterPayload>
          }
          aggregate: {
            args: Prisma.Env_delimiterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnv_delimiter>
          }
          groupBy: {
            args: Prisma.env_delimiterGroupByArgs<ExtArgs>
            result: $Utils.Optional<Env_delimiterGroupByOutputType>[]
          }
          count: {
            args: Prisma.env_delimiterCountArgs<ExtArgs>
            result: $Utils.Optional<Env_delimiterCountAggregateOutputType> | number
          }
        }
      }
      env_user: {
        payload: Prisma.$env_userPayload<ExtArgs>
        fields: Prisma.env_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.env_userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.env_userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_userPayload>
          }
          findFirst: {
            args: Prisma.env_userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.env_userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_userPayload>
          }
          findMany: {
            args: Prisma.env_userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_userPayload>[]
          }
          create: {
            args: Prisma.env_userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_userPayload>
          }
          createMany: {
            args: Prisma.env_userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.env_userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_userPayload>[]
          }
          delete: {
            args: Prisma.env_userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_userPayload>
          }
          update: {
            args: Prisma.env_userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_userPayload>
          }
          deleteMany: {
            args: Prisma.env_userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.env_userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.env_userUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_userPayload>[]
          }
          upsert: {
            args: Prisma.env_userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$env_userPayload>
          }
          aggregate: {
            args: Prisma.Env_userAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnv_user>
          }
          groupBy: {
            args: Prisma.env_userGroupByArgs<ExtArgs>
            result: $Utils.Optional<Env_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.env_userCountArgs<ExtArgs>
            result: $Utils.Optional<Env_userCountAggregateOutputType> | number
          }
        }
      }
      environment: {
        payload: Prisma.$environmentPayload<ExtArgs>
        fields: Prisma.environmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.environmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$environmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.environmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$environmentPayload>
          }
          findFirst: {
            args: Prisma.environmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$environmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.environmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$environmentPayload>
          }
          findMany: {
            args: Prisma.environmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$environmentPayload>[]
          }
          create: {
            args: Prisma.environmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$environmentPayload>
          }
          createMany: {
            args: Prisma.environmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.environmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$environmentPayload>[]
          }
          delete: {
            args: Prisma.environmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$environmentPayload>
          }
          update: {
            args: Prisma.environmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$environmentPayload>
          }
          deleteMany: {
            args: Prisma.environmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.environmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.environmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$environmentPayload>[]
          }
          upsert: {
            args: Prisma.environmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$environmentPayload>
          }
          aggregate: {
            args: Prisma.EnvironmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnvironment>
          }
          groupBy: {
            args: Prisma.environmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnvironmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.environmentCountArgs<ExtArgs>
            result: $Utils.Optional<EnvironmentCountAggregateOutputType> | number
          }
        }
      }
      expense: {
        payload: Prisma.$expensePayload<ExtArgs>
        fields: Prisma.expenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.expenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.expenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expensePayload>
          }
          findFirst: {
            args: Prisma.expenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.expenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expensePayload>
          }
          findMany: {
            args: Prisma.expenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expensePayload>[]
          }
          create: {
            args: Prisma.expenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expensePayload>
          }
          createMany: {
            args: Prisma.expenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.expenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expensePayload>[]
          }
          delete: {
            args: Prisma.expenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expensePayload>
          }
          update: {
            args: Prisma.expenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expensePayload>
          }
          deleteMany: {
            args: Prisma.expenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.expenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.expenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expensePayload>[]
          }
          upsert: {
            args: Prisma.expenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.expenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.expenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      format: {
        payload: Prisma.$formatPayload<ExtArgs>
        fields: Prisma.formatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.formatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.formatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formatPayload>
          }
          findFirst: {
            args: Prisma.formatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.formatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formatPayload>
          }
          findMany: {
            args: Prisma.formatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formatPayload>[]
          }
          create: {
            args: Prisma.formatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formatPayload>
          }
          createMany: {
            args: Prisma.formatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.formatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formatPayload>[]
          }
          delete: {
            args: Prisma.formatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formatPayload>
          }
          update: {
            args: Prisma.formatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formatPayload>
          }
          deleteMany: {
            args: Prisma.formatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.formatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.formatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formatPayload>[]
          }
          upsert: {
            args: Prisma.formatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formatPayload>
          }
          aggregate: {
            args: Prisma.FormatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormat>
          }
          groupBy: {
            args: Prisma.formatGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormatGroupByOutputType>[]
          }
          count: {
            args: Prisma.formatCountArgs<ExtArgs>
            result: $Utils.Optional<FormatCountAggregateOutputType> | number
          }
        }
      }
      helper_user: {
        payload: Prisma.$helper_userPayload<ExtArgs>
        fields: Prisma.helper_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.helper_userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helper_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.helper_userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helper_userPayload>
          }
          findFirst: {
            args: Prisma.helper_userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helper_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.helper_userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helper_userPayload>
          }
          findMany: {
            args: Prisma.helper_userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helper_userPayload>[]
          }
          create: {
            args: Prisma.helper_userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helper_userPayload>
          }
          createMany: {
            args: Prisma.helper_userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.helper_userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helper_userPayload>[]
          }
          delete: {
            args: Prisma.helper_userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helper_userPayload>
          }
          update: {
            args: Prisma.helper_userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helper_userPayload>
          }
          deleteMany: {
            args: Prisma.helper_userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.helper_userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.helper_userUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helper_userPayload>[]
          }
          upsert: {
            args: Prisma.helper_userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$helper_userPayload>
          }
          aggregate: {
            args: Prisma.Helper_userAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelper_user>
          }
          groupBy: {
            args: Prisma.helper_userGroupByArgs<ExtArgs>
            result: $Utils.Optional<Helper_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.helper_userCountArgs<ExtArgs>
            result: $Utils.Optional<Helper_userCountAggregateOutputType> | number
          }
        }
      }
      intervention_history: {
        payload: Prisma.$intervention_historyPayload<ExtArgs>
        fields: Prisma.intervention_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.intervention_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intervention_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.intervention_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intervention_historyPayload>
          }
          findFirst: {
            args: Prisma.intervention_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intervention_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.intervention_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intervention_historyPayload>
          }
          findMany: {
            args: Prisma.intervention_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intervention_historyPayload>[]
          }
          create: {
            args: Prisma.intervention_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intervention_historyPayload>
          }
          createMany: {
            args: Prisma.intervention_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.intervention_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intervention_historyPayload>[]
          }
          delete: {
            args: Prisma.intervention_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intervention_historyPayload>
          }
          update: {
            args: Prisma.intervention_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intervention_historyPayload>
          }
          deleteMany: {
            args: Prisma.intervention_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.intervention_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.intervention_historyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intervention_historyPayload>[]
          }
          upsert: {
            args: Prisma.intervention_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intervention_historyPayload>
          }
          aggregate: {
            args: Prisma.Intervention_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntervention_history>
          }
          groupBy: {
            args: Prisma.intervention_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Intervention_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.intervention_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Intervention_historyCountAggregateOutputType> | number
          }
        }
      }
      localisation: {
        payload: Prisma.$localisationPayload<ExtArgs>
        fields: Prisma.localisationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.localisationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localisationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.localisationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localisationPayload>
          }
          findFirst: {
            args: Prisma.localisationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localisationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.localisationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localisationPayload>
          }
          findMany: {
            args: Prisma.localisationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localisationPayload>[]
          }
          create: {
            args: Prisma.localisationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localisationPayload>
          }
          createMany: {
            args: Prisma.localisationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.localisationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localisationPayload>[]
          }
          delete: {
            args: Prisma.localisationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localisationPayload>
          }
          update: {
            args: Prisma.localisationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localisationPayload>
          }
          deleteMany: {
            args: Prisma.localisationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.localisationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.localisationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localisationPayload>[]
          }
          upsert: {
            args: Prisma.localisationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localisationPayload>
          }
          aggregate: {
            args: Prisma.LocalisationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocalisation>
          }
          groupBy: {
            args: Prisma.localisationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocalisationGroupByOutputType>[]
          }
          count: {
            args: Prisma.localisationCountArgs<ExtArgs>
            result: $Utils.Optional<LocalisationCountAggregateOutputType> | number
          }
        }
      }
      map: {
        payload: Prisma.$mapPayload<ExtArgs>
        fields: Prisma.mapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mapPayload>
          }
          findFirst: {
            args: Prisma.mapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mapPayload>
          }
          findMany: {
            args: Prisma.mapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mapPayload>[]
          }
          create: {
            args: Prisma.mapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mapPayload>
          }
          createMany: {
            args: Prisma.mapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mapPayload>[]
          }
          delete: {
            args: Prisma.mapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mapPayload>
          }
          update: {
            args: Prisma.mapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mapPayload>
          }
          deleteMany: {
            args: Prisma.mapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mapPayload>[]
          }
          upsert: {
            args: Prisma.mapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mapPayload>
          }
          aggregate: {
            args: Prisma.MapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMap>
          }
          groupBy: {
            args: Prisma.mapGroupByArgs<ExtArgs>
            result: $Utils.Optional<MapGroupByOutputType>[]
          }
          count: {
            args: Prisma.mapCountArgs<ExtArgs>
            result: $Utils.Optional<MapCountAggregateOutputType> | number
          }
        }
      }
      market_potentiel: {
        payload: Prisma.$market_potentielPayload<ExtArgs>
        fields: Prisma.market_potentielFieldRefs
        operations: {
          findUnique: {
            args: Prisma.market_potentielFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_potentielPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.market_potentielFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_potentielPayload>
          }
          findFirst: {
            args: Prisma.market_potentielFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_potentielPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.market_potentielFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_potentielPayload>
          }
          findMany: {
            args: Prisma.market_potentielFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_potentielPayload>[]
          }
          create: {
            args: Prisma.market_potentielCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_potentielPayload>
          }
          createMany: {
            args: Prisma.market_potentielCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.market_potentielCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_potentielPayload>[]
          }
          delete: {
            args: Prisma.market_potentielDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_potentielPayload>
          }
          update: {
            args: Prisma.market_potentielUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_potentielPayload>
          }
          deleteMany: {
            args: Prisma.market_potentielDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.market_potentielUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.market_potentielUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_potentielPayload>[]
          }
          upsert: {
            args: Prisma.market_potentielUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$market_potentielPayload>
          }
          aggregate: {
            args: Prisma.Market_potentielAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarket_potentiel>
          }
          groupBy: {
            args: Prisma.market_potentielGroupByArgs<ExtArgs>
            result: $Utils.Optional<Market_potentielGroupByOutputType>[]
          }
          count: {
            args: Prisma.market_potentielCountArgs<ExtArgs>
            result: $Utils.Optional<Market_potentielCountAggregateOutputType> | number
          }
        }
      }
      panne_history: {
        payload: Prisma.$panne_historyPayload<ExtArgs>
        fields: Prisma.panne_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.panne_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panne_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.panne_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panne_historyPayload>
          }
          findFirst: {
            args: Prisma.panne_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panne_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.panne_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panne_historyPayload>
          }
          findMany: {
            args: Prisma.panne_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panne_historyPayload>[]
          }
          create: {
            args: Prisma.panne_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panne_historyPayload>
          }
          createMany: {
            args: Prisma.panne_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.panne_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panne_historyPayload>[]
          }
          delete: {
            args: Prisma.panne_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panne_historyPayload>
          }
          update: {
            args: Prisma.panne_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panne_historyPayload>
          }
          deleteMany: {
            args: Prisma.panne_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.panne_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.panne_historyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panne_historyPayload>[]
          }
          upsert: {
            args: Prisma.panne_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panne_historyPayload>
          }
          aggregate: {
            args: Prisma.Panne_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePanne_history>
          }
          groupBy: {
            args: Prisma.panne_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Panne_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.panne_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Panne_historyCountAggregateOutputType> | number
          }
        }
      }
      poi: {
        payload: Prisma.$poiPayload<ExtArgs>
        fields: Prisma.poiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.poiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.poiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poiPayload>
          }
          findFirst: {
            args: Prisma.poiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.poiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poiPayload>
          }
          findMany: {
            args: Prisma.poiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poiPayload>[]
          }
          create: {
            args: Prisma.poiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poiPayload>
          }
          createMany: {
            args: Prisma.poiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.poiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poiPayload>[]
          }
          delete: {
            args: Prisma.poiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poiPayload>
          }
          update: {
            args: Prisma.poiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poiPayload>
          }
          deleteMany: {
            args: Prisma.poiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.poiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.poiUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poiPayload>[]
          }
          upsert: {
            args: Prisma.poiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poiPayload>
          }
          aggregate: {
            args: Prisma.PoiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePoi>
          }
          groupBy: {
            args: Prisma.poiGroupByArgs<ExtArgs>
            result: $Utils.Optional<PoiGroupByOutputType>[]
          }
          count: {
            args: Prisma.poiCountArgs<ExtArgs>
            result: $Utils.Optional<PoiCountAggregateOutputType> | number
          }
        }
      }
      poi_category: {
        payload: Prisma.$poi_categoryPayload<ExtArgs>
        fields: Prisma.poi_categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.poi_categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.poi_categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_categoryPayload>
          }
          findFirst: {
            args: Prisma.poi_categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.poi_categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_categoryPayload>
          }
          findMany: {
            args: Prisma.poi_categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_categoryPayload>[]
          }
          create: {
            args: Prisma.poi_categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_categoryPayload>
          }
          createMany: {
            args: Prisma.poi_categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.poi_categoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_categoryPayload>[]
          }
          delete: {
            args: Prisma.poi_categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_categoryPayload>
          }
          update: {
            args: Prisma.poi_categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_categoryPayload>
          }
          deleteMany: {
            args: Prisma.poi_categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.poi_categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.poi_categoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_categoryPayload>[]
          }
          upsert: {
            args: Prisma.poi_categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_categoryPayload>
          }
          aggregate: {
            args: Prisma.Poi_categoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePoi_category>
          }
          groupBy: {
            args: Prisma.poi_categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Poi_categoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.poi_categoryCountArgs<ExtArgs>
            result: $Utils.Optional<Poi_categoryCountAggregateOutputType> | number
          }
        }
      }
      poi_zone: {
        payload: Prisma.$poi_zonePayload<ExtArgs>
        fields: Prisma.poi_zoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.poi_zoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_zonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.poi_zoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_zonePayload>
          }
          findFirst: {
            args: Prisma.poi_zoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_zonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.poi_zoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_zonePayload>
          }
          findMany: {
            args: Prisma.poi_zoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_zonePayload>[]
          }
          create: {
            args: Prisma.poi_zoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_zonePayload>
          }
          createMany: {
            args: Prisma.poi_zoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.poi_zoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_zonePayload>[]
          }
          delete: {
            args: Prisma.poi_zoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_zonePayload>
          }
          update: {
            args: Prisma.poi_zoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_zonePayload>
          }
          deleteMany: {
            args: Prisma.poi_zoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.poi_zoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.poi_zoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_zonePayload>[]
          }
          upsert: {
            args: Prisma.poi_zoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$poi_zonePayload>
          }
          aggregate: {
            args: Prisma.Poi_zoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePoi_zone>
          }
          groupBy: {
            args: Prisma.poi_zoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<Poi_zoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.poi_zoneCountArgs<ExtArgs>
            result: $Utils.Optional<Poi_zoneCountAggregateOutputType> | number
          }
        }
      }
      pricing: {
        payload: Prisma.$pricingPayload<ExtArgs>
        fields: Prisma.pricingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pricingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pricingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingPayload>
          }
          findFirst: {
            args: Prisma.pricingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pricingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingPayload>
          }
          findMany: {
            args: Prisma.pricingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingPayload>[]
          }
          create: {
            args: Prisma.pricingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingPayload>
          }
          createMany: {
            args: Prisma.pricingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pricingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingPayload>[]
          }
          delete: {
            args: Prisma.pricingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingPayload>
          }
          update: {
            args: Prisma.pricingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingPayload>
          }
          deleteMany: {
            args: Prisma.pricingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pricingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pricingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingPayload>[]
          }
          upsert: {
            args: Prisma.pricingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricingPayload>
          }
          aggregate: {
            args: Prisma.PricingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePricing>
          }
          groupBy: {
            args: Prisma.pricingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PricingGroupByOutputType>[]
          }
          count: {
            args: Prisma.pricingCountArgs<ExtArgs>
            result: $Utils.Optional<PricingCountAggregateOutputType> | number
          }
        }
      }
      purchase_history: {
        payload: Prisma.$purchase_historyPayload<ExtArgs>
        fields: Prisma.purchase_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.purchase_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$purchase_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.purchase_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$purchase_historyPayload>
          }
          findFirst: {
            args: Prisma.purchase_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$purchase_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.purchase_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$purchase_historyPayload>
          }
          findMany: {
            args: Prisma.purchase_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$purchase_historyPayload>[]
          }
          create: {
            args: Prisma.purchase_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$purchase_historyPayload>
          }
          createMany: {
            args: Prisma.purchase_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.purchase_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$purchase_historyPayload>[]
          }
          delete: {
            args: Prisma.purchase_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$purchase_historyPayload>
          }
          update: {
            args: Prisma.purchase_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$purchase_historyPayload>
          }
          deleteMany: {
            args: Prisma.purchase_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.purchase_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.purchase_historyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$purchase_historyPayload>[]
          }
          upsert: {
            args: Prisma.purchase_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$purchase_historyPayload>
          }
          aggregate: {
            args: Prisma.Purchase_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase_history>
          }
          groupBy: {
            args: Prisma.purchase_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Purchase_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.purchase_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Purchase_historyCountAggregateOutputType> | number
          }
        }
      }
      state_type: {
        payload: Prisma.$state_typePayload<ExtArgs>
        fields: Prisma.state_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.state_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$state_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.state_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$state_typePayload>
          }
          findFirst: {
            args: Prisma.state_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$state_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.state_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$state_typePayload>
          }
          findMany: {
            args: Prisma.state_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$state_typePayload>[]
          }
          create: {
            args: Prisma.state_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$state_typePayload>
          }
          createMany: {
            args: Prisma.state_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.state_typeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$state_typePayload>[]
          }
          delete: {
            args: Prisma.state_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$state_typePayload>
          }
          update: {
            args: Prisma.state_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$state_typePayload>
          }
          deleteMany: {
            args: Prisma.state_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.state_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.state_typeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$state_typePayload>[]
          }
          upsert: {
            args: Prisma.state_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$state_typePayload>
          }
          aggregate: {
            args: Prisma.State_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateState_type>
          }
          groupBy: {
            args: Prisma.state_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<State_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.state_typeCountArgs<ExtArgs>
            result: $Utils.Optional<State_typeCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      user_type: {
        payload: Prisma.$user_typePayload<ExtArgs>
        fields: Prisma.user_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typePayload>
          }
          findFirst: {
            args: Prisma.user_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typePayload>
          }
          findMany: {
            args: Prisma.user_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typePayload>[]
          }
          create: {
            args: Prisma.user_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typePayload>
          }
          createMany: {
            args: Prisma.user_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_typeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typePayload>[]
          }
          delete: {
            args: Prisma.user_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typePayload>
          }
          update: {
            args: Prisma.user_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typePayload>
          }
          deleteMany: {
            args: Prisma.user_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_typeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typePayload>[]
          }
          upsert: {
            args: Prisma.user_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typePayload>
          }
          aggregate: {
            args: Prisma.User_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_type>
          }
          groupBy: {
            args: Prisma.user_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_typeCountArgs<ExtArgs>
            result: $Utils.Optional<User_typeCountAggregateOutputType> | number
          }
        }
      }
      zone: {
        payload: Prisma.$zonePayload<ExtArgs>
        fields: Prisma.zoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.zoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.zoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          findFirst: {
            args: Prisma.zoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.zoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          findMany: {
            args: Prisma.zoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>[]
          }
          create: {
            args: Prisma.zoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          createMany: {
            args: Prisma.zoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.zoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>[]
          }
          delete: {
            args: Prisma.zoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          update: {
            args: Prisma.zoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          deleteMany: {
            args: Prisma.zoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.zoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.zoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>[]
          }
          upsert: {
            args: Prisma.zoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          aggregate: {
            args: Prisma.ZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZone>
          }
          groupBy: {
            args: Prisma.zoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.zoneCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneCountAggregateOutputType> | number
          }
        }
      }
      zone_type: {
        payload: Prisma.$zone_typePayload<ExtArgs>
        fields: Prisma.zone_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.zone_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zone_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.zone_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zone_typePayload>
          }
          findFirst: {
            args: Prisma.zone_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zone_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.zone_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zone_typePayload>
          }
          findMany: {
            args: Prisma.zone_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zone_typePayload>[]
          }
          create: {
            args: Prisma.zone_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zone_typePayload>
          }
          createMany: {
            args: Prisma.zone_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.zone_typeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zone_typePayload>[]
          }
          delete: {
            args: Prisma.zone_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zone_typePayload>
          }
          update: {
            args: Prisma.zone_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zone_typePayload>
          }
          deleteMany: {
            args: Prisma.zone_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.zone_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.zone_typeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zone_typePayload>[]
          }
          upsert: {
            args: Prisma.zone_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zone_typePayload>
          }
          aggregate: {
            args: Prisma.Zone_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZone_type>
          }
          groupBy: {
            args: Prisma.zone_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Zone_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.zone_typeCountArgs<ExtArgs>
            result: $Utils.Optional<Zone_typeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    alert?: alertOmit
    device?: deviceOmit
    device_type?: device_typeOmit
    emergency_contact?: emergency_contactOmit
    env_delimiter?: env_delimiterOmit
    env_user?: env_userOmit
    environment?: environmentOmit
    expense?: expenseOmit
    format?: formatOmit
    helper_user?: helper_userOmit
    intervention_history?: intervention_historyOmit
    localisation?: localisationOmit
    map?: mapOmit
    market_potentiel?: market_potentielOmit
    panne_history?: panne_historyOmit
    poi?: poiOmit
    poi_category?: poi_categoryOmit
    poi_zone?: poi_zoneOmit
    pricing?: pricingOmit
    purchase_history?: purchase_historyOmit
    state_type?: state_typeOmit
    user?: userOmit
    user_type?: user_typeOmit
    zone?: zoneOmit
    zone_type?: zone_typeOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AlertCountOutputType
   */

  export type AlertCountOutputType = {
    panne_history: number
  }

  export type AlertCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panne_history?: boolean | AlertCountOutputTypeCountPanne_historyArgs
  }

  // Custom InputTypes
  /**
   * AlertCountOutputType without action
   */
  export type AlertCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCountOutputType
     */
    select?: AlertCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlertCountOutputType without action
   */
  export type AlertCountOutputTypeCountPanne_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: panne_historyWhereInput
  }


  /**
   * Count Type DeviceCountOutputType
   */

  export type DeviceCountOutputType = {
    alert: number
    purchase_history: number
  }

  export type DeviceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | DeviceCountOutputTypeCountAlertArgs
    purchase_history?: boolean | DeviceCountOutputTypeCountPurchase_historyArgs
  }

  // Custom InputTypes
  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCountOutputType
     */
    select?: DeviceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alertWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountPurchase_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: purchase_historyWhereInput
  }


  /**
   * Count Type Device_typeCountOutputType
   */

  export type Device_typeCountOutputType = {
    device: number
  }

  export type Device_typeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | Device_typeCountOutputTypeCountDeviceArgs
  }

  // Custom InputTypes
  /**
   * Device_typeCountOutputType without action
   */
  export type Device_typeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device_typeCountOutputType
     */
    select?: Device_typeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Device_typeCountOutputType without action
   */
  export type Device_typeCountOutputTypeCountDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deviceWhereInput
  }


  /**
   * Count Type EnvironmentCountOutputType
   */

  export type EnvironmentCountOutputType = {
    env_delimiter: number
    env_user: number
    poi: number
    zone: number
  }

  export type EnvironmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    env_delimiter?: boolean | EnvironmentCountOutputTypeCountEnv_delimiterArgs
    env_user?: boolean | EnvironmentCountOutputTypeCountEnv_userArgs
    poi?: boolean | EnvironmentCountOutputTypeCountPoiArgs
    zone?: boolean | EnvironmentCountOutputTypeCountZoneArgs
  }

  // Custom InputTypes
  /**
   * EnvironmentCountOutputType without action
   */
  export type EnvironmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentCountOutputType
     */
    select?: EnvironmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EnvironmentCountOutputType without action
   */
  export type EnvironmentCountOutputTypeCountEnv_delimiterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: env_delimiterWhereInput
  }

  /**
   * EnvironmentCountOutputType without action
   */
  export type EnvironmentCountOutputTypeCountEnv_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: env_userWhereInput
  }

  /**
   * EnvironmentCountOutputType without action
   */
  export type EnvironmentCountOutputTypeCountPoiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: poiWhereInput
  }

  /**
   * EnvironmentCountOutputType without action
   */
  export type EnvironmentCountOutputTypeCountZoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zoneWhereInput
  }


  /**
   * Count Type FormatCountOutputType
   */

  export type FormatCountOutputType = {
    map: number
  }

  export type FormatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    map?: boolean | FormatCountOutputTypeCountMapArgs
  }

  // Custom InputTypes
  /**
   * FormatCountOutputType without action
   */
  export type FormatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormatCountOutputType
     */
    select?: FormatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormatCountOutputType without action
   */
  export type FormatCountOutputTypeCountMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mapWhereInput
  }


  /**
   * Count Type MapCountOutputType
   */

  export type MapCountOutputType = {
    environment: number
    poi: number
    zone: number
  }

  export type MapCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | MapCountOutputTypeCountEnvironmentArgs
    poi?: boolean | MapCountOutputTypeCountPoiArgs
    zone?: boolean | MapCountOutputTypeCountZoneArgs
  }

  // Custom InputTypes
  /**
   * MapCountOutputType without action
   */
  export type MapCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapCountOutputType
     */
    select?: MapCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MapCountOutputType without action
   */
  export type MapCountOutputTypeCountEnvironmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: environmentWhereInput
  }

  /**
   * MapCountOutputType without action
   */
  export type MapCountOutputTypeCountPoiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: poiWhereInput
  }

  /**
   * MapCountOutputType without action
   */
  export type MapCountOutputTypeCountZoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zoneWhereInput
  }


  /**
   * Count Type PoiCountOutputType
   */

  export type PoiCountOutputType = {
    poi_zone: number
  }

  export type PoiCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poi_zone?: boolean | PoiCountOutputTypeCountPoi_zoneArgs
  }

  // Custom InputTypes
  /**
   * PoiCountOutputType without action
   */
  export type PoiCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoiCountOutputType
     */
    select?: PoiCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PoiCountOutputType without action
   */
  export type PoiCountOutputTypeCountPoi_zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: poi_zoneWhereInput
  }


  /**
   * Count Type Poi_categoryCountOutputType
   */

  export type Poi_categoryCountOutputType = {
    poi: number
  }

  export type Poi_categoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poi?: boolean | Poi_categoryCountOutputTypeCountPoiArgs
  }

  // Custom InputTypes
  /**
   * Poi_categoryCountOutputType without action
   */
  export type Poi_categoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poi_categoryCountOutputType
     */
    select?: Poi_categoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Poi_categoryCountOutputType without action
   */
  export type Poi_categoryCountOutputTypeCountPoiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: poiWhereInput
  }


  /**
   * Count Type State_typeCountOutputType
   */

  export type State_typeCountOutputType = {
    device: number
  }

  export type State_typeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | State_typeCountOutputTypeCountDeviceArgs
  }

  // Custom InputTypes
  /**
   * State_typeCountOutputType without action
   */
  export type State_typeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State_typeCountOutputType
     */
    select?: State_typeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * State_typeCountOutputType without action
   */
  export type State_typeCountOutputTypeCountDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deviceWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    device: number
    env_user: number
    helper_user_helper_user_helper_idTouser: number
    helper_user_helper_user_user_idTouser: number
    intervention_history: number
    purchase_history: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | UserCountOutputTypeCountDeviceArgs
    env_user?: boolean | UserCountOutputTypeCountEnv_userArgs
    helper_user_helper_user_helper_idTouser?: boolean | UserCountOutputTypeCountHelper_user_helper_user_helper_idTouserArgs
    helper_user_helper_user_user_idTouser?: boolean | UserCountOutputTypeCountHelper_user_helper_user_user_idTouserArgs
    intervention_history?: boolean | UserCountOutputTypeCountIntervention_historyArgs
    purchase_history?: boolean | UserCountOutputTypeCountPurchase_historyArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deviceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnv_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: env_userWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHelper_user_helper_user_helper_idTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: helper_userWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHelper_user_helper_user_user_idTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: helper_userWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIntervention_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: intervention_historyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchase_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: purchase_historyWhereInput
  }


  /**
   * Count Type User_typeCountOutputType
   */

  export type User_typeCountOutputType = {
    user: number
  }

  export type User_typeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | User_typeCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * User_typeCountOutputType without action
   */
  export type User_typeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_typeCountOutputType
     */
    select?: User_typeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * User_typeCountOutputType without action
   */
  export type User_typeCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }


  /**
   * Count Type ZoneCountOutputType
   */

  export type ZoneCountOutputType = {
    poi_zone: number
  }

  export type ZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poi_zone?: boolean | ZoneCountOutputTypeCountPoi_zoneArgs
  }

  // Custom InputTypes
  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneCountOutputType
     */
    select?: ZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountPoi_zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: poi_zoneWhereInput
  }


  /**
   * Count Type Zone_typeCountOutputType
   */

  export type Zone_typeCountOutputType = {
    zone_zone_type_idTozone_type: number
    zone_zone_zone_typeTozone_type: number
  }

  export type Zone_typeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone_zone_type_idTozone_type?: boolean | Zone_typeCountOutputTypeCountZone_zone_type_idTozone_typeArgs
    zone_zone_zone_typeTozone_type?: boolean | Zone_typeCountOutputTypeCountZone_zone_zone_typeTozone_typeArgs
  }

  // Custom InputTypes
  /**
   * Zone_typeCountOutputType without action
   */
  export type Zone_typeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone_typeCountOutputType
     */
    select?: Zone_typeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Zone_typeCountOutputType without action
   */
  export type Zone_typeCountOutputTypeCountZone_zone_type_idTozone_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zoneWhereInput
  }

  /**
   * Zone_typeCountOutputType without action
   */
  export type Zone_typeCountOutputTypeCountZone_zone_zone_typeTozone_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zoneWhereInput
  }


  /**
   * Models
   */

  /**
   * Model alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _avg: AlertAvgAggregateOutputType | null
    _sum: AlertSumAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertAvgAggregateOutputType = {
    id: number | null
    device_id: number | null
  }

  export type AlertSumAggregateOutputType = {
    id: number | null
    device_id: number | null
  }

  export type AlertMinAggregateOutputType = {
    id: number | null
    type: string | null
    time: Date | null
    date: Date | null
    zone: string | null
    status: string | null
    level: $Enums.level_new | null
    device_id: number | null
  }

  export type AlertMaxAggregateOutputType = {
    id: number | null
    type: string | null
    time: Date | null
    date: Date | null
    zone: string | null
    status: string | null
    level: $Enums.level_new | null
    device_id: number | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    type: number
    time: number
    date: number
    zone: number
    status: number
    level: number
    device_id: number
    _all: number
  }


  export type AlertAvgAggregateInputType = {
    id?: true
    device_id?: true
  }

  export type AlertSumAggregateInputType = {
    id?: true
    device_id?: true
  }

  export type AlertMinAggregateInputType = {
    id?: true
    type?: true
    time?: true
    date?: true
    zone?: true
    status?: true
    level?: true
    device_id?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    type?: true
    time?: true
    date?: true
    zone?: true
    status?: true
    level?: true
    device_id?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    type?: true
    time?: true
    date?: true
    zone?: true
    status?: true
    level?: true
    device_id?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alert to aggregate.
     */
    where?: alertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alerts to fetch.
     */
    orderBy?: alertOrderByWithRelationInput | alertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: alertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type alertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alertWhereInput
    orderBy?: alertOrderByWithAggregationInput | alertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: alertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _avg?: AlertAvgAggregateInputType
    _sum?: AlertSumAggregateInputType
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: number
    type: string
    time: Date
    date: Date
    zone: string
    status: string
    level: $Enums.level_new
    device_id: number | null
    _count: AlertCountAggregateOutputType | null
    _avg: AlertAvgAggregateOutputType | null
    _sum: AlertSumAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends alertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type alertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    time?: boolean
    date?: boolean
    zone?: boolean
    status?: boolean
    level?: boolean
    device_id?: boolean
    device?: boolean | alert$deviceArgs<ExtArgs>
    panne_history?: boolean | alert$panne_historyArgs<ExtArgs>
    _count?: boolean | AlertCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type alertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    time?: boolean
    date?: boolean
    zone?: boolean
    status?: boolean
    level?: boolean
    device_id?: boolean
    device?: boolean | alert$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type alertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    time?: boolean
    date?: boolean
    zone?: boolean
    status?: boolean
    level?: boolean
    device_id?: boolean
    device?: boolean | alert$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type alertSelectScalar = {
    id?: boolean
    type?: boolean
    time?: boolean
    date?: boolean
    zone?: boolean
    status?: boolean
    level?: boolean
    device_id?: boolean
  }

  export type alertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "time" | "date" | "zone" | "status" | "level" | "device_id", ExtArgs["result"]["alert"]>
  export type alertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | alert$deviceArgs<ExtArgs>
    panne_history?: boolean | alert$panne_historyArgs<ExtArgs>
    _count?: boolean | AlertCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type alertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | alert$deviceArgs<ExtArgs>
  }
  export type alertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | alert$deviceArgs<ExtArgs>
  }

  export type $alertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "alert"
    objects: {
      device: Prisma.$devicePayload<ExtArgs> | null
      panne_history: Prisma.$panne_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      time: Date
      date: Date
      zone: string
      status: string
      level: $Enums.level_new
      device_id: number | null
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type alertGetPayload<S extends boolean | null | undefined | alertDefaultArgs> = $Result.GetResult<Prisma.$alertPayload, S>

  type alertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<alertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface alertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['alert'], meta: { name: 'alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {alertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends alertFindUniqueArgs>(args: SelectSubset<T, alertFindUniqueArgs<ExtArgs>>): Prisma__alertClient<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {alertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends alertFindUniqueOrThrowArgs>(args: SelectSubset<T, alertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__alertClient<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends alertFindFirstArgs>(args?: SelectSubset<T, alertFindFirstArgs<ExtArgs>>): Prisma__alertClient<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends alertFindFirstOrThrowArgs>(args?: SelectSubset<T, alertFindFirstOrThrowArgs<ExtArgs>>): Prisma__alertClient<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends alertFindManyArgs>(args?: SelectSubset<T, alertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Alert.
     * @param {alertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends alertCreateArgs>(args: SelectSubset<T, alertCreateArgs<ExtArgs>>): Prisma__alertClient<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Alerts.
     * @param {alertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends alertCreateManyArgs>(args?: SelectSubset<T, alertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alerts and returns the data saved in the database.
     * @param {alertCreateManyAndReturnArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends alertCreateManyAndReturnArgs>(args?: SelectSubset<T, alertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Alert.
     * @param {alertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends alertDeleteArgs>(args: SelectSubset<T, alertDeleteArgs<ExtArgs>>): Prisma__alertClient<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Alert.
     * @param {alertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends alertUpdateArgs>(args: SelectSubset<T, alertUpdateArgs<ExtArgs>>): Prisma__alertClient<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Alerts.
     * @param {alertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends alertDeleteManyArgs>(args?: SelectSubset<T, alertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends alertUpdateManyArgs>(args: SelectSubset<T, alertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts and returns the data updated in the database.
     * @param {alertUpdateManyAndReturnArgs} args - Arguments to update many Alerts.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends alertUpdateManyAndReturnArgs>(args: SelectSubset<T, alertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Alert.
     * @param {alertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends alertUpsertArgs>(args: SelectSubset<T, alertUpsertArgs<ExtArgs>>): Prisma__alertClient<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends alertCountArgs>(
      args?: Subset<T, alertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends alertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: alertGroupByArgs['orderBy'] }
        : { orderBy?: alertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, alertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the alert model
   */
  readonly fields: alertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__alertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends alert$deviceArgs<ExtArgs> = {}>(args?: Subset<T, alert$deviceArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    panne_history<T extends alert$panne_historyArgs<ExtArgs> = {}>(args?: Subset<T, alert$panne_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$panne_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the alert model
   */
  interface alertFieldRefs {
    readonly id: FieldRef<"alert", 'Int'>
    readonly type: FieldRef<"alert", 'String'>
    readonly time: FieldRef<"alert", 'DateTime'>
    readonly date: FieldRef<"alert", 'DateTime'>
    readonly zone: FieldRef<"alert", 'String'>
    readonly status: FieldRef<"alert", 'String'>
    readonly level: FieldRef<"alert", 'level_new'>
    readonly device_id: FieldRef<"alert", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * alert findUnique
   */
  export type alertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alert
     */
    omit?: alertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * Filter, which alert to fetch.
     */
    where: alertWhereUniqueInput
  }

  /**
   * alert findUniqueOrThrow
   */
  export type alertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alert
     */
    omit?: alertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * Filter, which alert to fetch.
     */
    where: alertWhereUniqueInput
  }

  /**
   * alert findFirst
   */
  export type alertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alert
     */
    omit?: alertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * Filter, which alert to fetch.
     */
    where?: alertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alerts to fetch.
     */
    orderBy?: alertOrderByWithRelationInput | alertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alerts.
     */
    cursor?: alertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * alert findFirstOrThrow
   */
  export type alertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alert
     */
    omit?: alertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * Filter, which alert to fetch.
     */
    where?: alertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alerts to fetch.
     */
    orderBy?: alertOrderByWithRelationInput | alertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alerts.
     */
    cursor?: alertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * alert findMany
   */
  export type alertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alert
     */
    omit?: alertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * Filter, which alerts to fetch.
     */
    where?: alertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alerts to fetch.
     */
    orderBy?: alertOrderByWithRelationInput | alertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing alerts.
     */
    cursor?: alertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * alert create
   */
  export type alertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alert
     */
    omit?: alertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * The data needed to create a alert.
     */
    data: XOR<alertCreateInput, alertUncheckedCreateInput>
  }

  /**
   * alert createMany
   */
  export type alertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many alerts.
     */
    data: alertCreateManyInput | alertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * alert createManyAndReturn
   */
  export type alertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the alert
     */
    omit?: alertOmit<ExtArgs> | null
    /**
     * The data used to create many alerts.
     */
    data: alertCreateManyInput | alertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * alert update
   */
  export type alertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alert
     */
    omit?: alertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * The data needed to update a alert.
     */
    data: XOR<alertUpdateInput, alertUncheckedUpdateInput>
    /**
     * Choose, which alert to update.
     */
    where: alertWhereUniqueInput
  }

  /**
   * alert updateMany
   */
  export type alertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update alerts.
     */
    data: XOR<alertUpdateManyMutationInput, alertUncheckedUpdateManyInput>
    /**
     * Filter which alerts to update
     */
    where?: alertWhereInput
    /**
     * Limit how many alerts to update.
     */
    limit?: number
  }

  /**
   * alert updateManyAndReturn
   */
  export type alertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the alert
     */
    omit?: alertOmit<ExtArgs> | null
    /**
     * The data used to update alerts.
     */
    data: XOR<alertUpdateManyMutationInput, alertUncheckedUpdateManyInput>
    /**
     * Filter which alerts to update
     */
    where?: alertWhereInput
    /**
     * Limit how many alerts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * alert upsert
   */
  export type alertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alert
     */
    omit?: alertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * The filter to search for the alert to update in case it exists.
     */
    where: alertWhereUniqueInput
    /**
     * In case the alert found by the `where` argument doesn't exist, create a new alert with this data.
     */
    create: XOR<alertCreateInput, alertUncheckedCreateInput>
    /**
     * In case the alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<alertUpdateInput, alertUncheckedUpdateInput>
  }

  /**
   * alert delete
   */
  export type alertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alert
     */
    omit?: alertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * Filter which alert to delete.
     */
    where: alertWhereUniqueInput
  }

  /**
   * alert deleteMany
   */
  export type alertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alerts to delete
     */
    where?: alertWhereInput
    /**
     * Limit how many alerts to delete.
     */
    limit?: number
  }

  /**
   * alert.device
   */
  export type alert$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    where?: deviceWhereInput
  }

  /**
   * alert.panne_history
   */
  export type alert$panne_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panne_history
     */
    select?: panne_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the panne_history
     */
    omit?: panne_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panne_historyInclude<ExtArgs> | null
    where?: panne_historyWhereInput
    orderBy?: panne_historyOrderByWithRelationInput | panne_historyOrderByWithRelationInput[]
    cursor?: panne_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Panne_historyScalarFieldEnum | Panne_historyScalarFieldEnum[]
  }

  /**
   * alert without action
   */
  export type alertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alert
     */
    omit?: alertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
  }


  /**
   * Model device
   */

  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceAvgAggregateOutputType = {
    id: number | null
    type_id: number | null
    state_type_id: number | null
    user_id: number | null
    battery_capacity: number | null
    price: number | null
  }

  export type DeviceSumAggregateOutputType = {
    id: number | null
    type_id: number | null
    state_type_id: number | null
    user_id: number | null
    battery_capacity: number | null
    price: number | null
  }

  export type DeviceMinAggregateOutputType = {
    id: number | null
    type_id: number | null
    state_type_id: number | null
    user_id: number | null
    mac_address: string | null
    software_version: string | null
    date_of_service: Date | null
    comm_state: boolean | null
    connection_state: boolean | null
    battery_capacity: number | null
    price: number | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: number | null
    type_id: number | null
    state_type_id: number | null
    user_id: number | null
    mac_address: string | null
    software_version: string | null
    date_of_service: Date | null
    comm_state: boolean | null
    connection_state: boolean | null
    battery_capacity: number | null
    price: number | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    type_id: number
    state_type_id: number
    user_id: number
    mac_address: number
    software_version: number
    date_of_service: number
    comm_state: number
    connection_state: number
    battery_capacity: number
    price: number
    _all: number
  }


  export type DeviceAvgAggregateInputType = {
    id?: true
    type_id?: true
    state_type_id?: true
    user_id?: true
    battery_capacity?: true
    price?: true
  }

  export type DeviceSumAggregateInputType = {
    id?: true
    type_id?: true
    state_type_id?: true
    user_id?: true
    battery_capacity?: true
    price?: true
  }

  export type DeviceMinAggregateInputType = {
    id?: true
    type_id?: true
    state_type_id?: true
    user_id?: true
    mac_address?: true
    software_version?: true
    date_of_service?: true
    comm_state?: true
    connection_state?: true
    battery_capacity?: true
    price?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    type_id?: true
    state_type_id?: true
    user_id?: true
    mac_address?: true
    software_version?: true
    date_of_service?: true
    comm_state?: true
    connection_state?: true
    battery_capacity?: true
    price?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    type_id?: true
    state_type_id?: true
    user_id?: true
    mac_address?: true
    software_version?: true
    date_of_service?: true
    comm_state?: true
    connection_state?: true
    battery_capacity?: true
    price?: true
    _all?: true
  }

  export type DeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which device to aggregate.
     */
    where?: deviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of devices to fetch.
     */
    orderBy?: deviceOrderByWithRelationInput | deviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: deviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type deviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deviceWhereInput
    orderBy?: deviceOrderByWithAggregationInput | deviceOrderByWithAggregationInput[]
    by: DeviceScalarFieldEnum[] | DeviceScalarFieldEnum
    having?: deviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _avg?: DeviceAvgAggregateInputType
    _sum?: DeviceSumAggregateInputType
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }

  export type DeviceGroupByOutputType = {
    id: number
    type_id: number
    state_type_id: number
    user_id: number | null
    mac_address: string
    software_version: string
    date_of_service: Date
    comm_state: boolean
    connection_state: boolean | null
    battery_capacity: number
    price: number | null
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends deviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type deviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type_id?: boolean
    state_type_id?: boolean
    user_id?: boolean
    mac_address?: boolean
    software_version?: boolean
    date_of_service?: boolean
    comm_state?: boolean
    connection_state?: boolean
    battery_capacity?: boolean
    price?: boolean
    alert?: boolean | device$alertArgs<ExtArgs>
    state_type?: boolean | state_typeDefaultArgs<ExtArgs>
    device_type?: boolean | device_typeDefaultArgs<ExtArgs>
    user?: boolean | device$userArgs<ExtArgs>
    purchase_history?: boolean | device$purchase_historyArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type deviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type_id?: boolean
    state_type_id?: boolean
    user_id?: boolean
    mac_address?: boolean
    software_version?: boolean
    date_of_service?: boolean
    comm_state?: boolean
    connection_state?: boolean
    battery_capacity?: boolean
    price?: boolean
    state_type?: boolean | state_typeDefaultArgs<ExtArgs>
    device_type?: boolean | device_typeDefaultArgs<ExtArgs>
    user?: boolean | device$userArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type deviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type_id?: boolean
    state_type_id?: boolean
    user_id?: boolean
    mac_address?: boolean
    software_version?: boolean
    date_of_service?: boolean
    comm_state?: boolean
    connection_state?: boolean
    battery_capacity?: boolean
    price?: boolean
    state_type?: boolean | state_typeDefaultArgs<ExtArgs>
    device_type?: boolean | device_typeDefaultArgs<ExtArgs>
    user?: boolean | device$userArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type deviceSelectScalar = {
    id?: boolean
    type_id?: boolean
    state_type_id?: boolean
    user_id?: boolean
    mac_address?: boolean
    software_version?: boolean
    date_of_service?: boolean
    comm_state?: boolean
    connection_state?: boolean
    battery_capacity?: boolean
    price?: boolean
  }

  export type deviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type_id" | "state_type_id" | "user_id" | "mac_address" | "software_version" | "date_of_service" | "comm_state" | "connection_state" | "battery_capacity" | "price", ExtArgs["result"]["device"]>
  export type deviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | device$alertArgs<ExtArgs>
    state_type?: boolean | state_typeDefaultArgs<ExtArgs>
    device_type?: boolean | device_typeDefaultArgs<ExtArgs>
    user?: boolean | device$userArgs<ExtArgs>
    purchase_history?: boolean | device$purchase_historyArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type deviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    state_type?: boolean | state_typeDefaultArgs<ExtArgs>
    device_type?: boolean | device_typeDefaultArgs<ExtArgs>
    user?: boolean | device$userArgs<ExtArgs>
  }
  export type deviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    state_type?: boolean | state_typeDefaultArgs<ExtArgs>
    device_type?: boolean | device_typeDefaultArgs<ExtArgs>
    user?: boolean | device$userArgs<ExtArgs>
  }

  export type $devicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "device"
    objects: {
      alert: Prisma.$alertPayload<ExtArgs>[]
      state_type: Prisma.$state_typePayload<ExtArgs>
      device_type: Prisma.$device_typePayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs> | null
      purchase_history: Prisma.$purchase_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type_id: number
      state_type_id: number
      user_id: number | null
      mac_address: string
      software_version: string
      date_of_service: Date
      comm_state: boolean
      connection_state: boolean | null
      battery_capacity: number
      price: number | null
    }, ExtArgs["result"]["device"]>
    composites: {}
  }

  type deviceGetPayload<S extends boolean | null | undefined | deviceDefaultArgs> = $Result.GetResult<Prisma.$devicePayload, S>

  type deviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<deviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface deviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['device'], meta: { name: 'device' } }
    /**
     * Find zero or one Device that matches the filter.
     * @param {deviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends deviceFindUniqueArgs>(args: SelectSubset<T, deviceFindUniqueArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Device that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {deviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends deviceFindUniqueOrThrowArgs>(args: SelectSubset<T, deviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends deviceFindFirstArgs>(args?: SelectSubset<T, deviceFindFirstArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends deviceFindFirstOrThrowArgs>(args?: SelectSubset<T, deviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends deviceFindManyArgs>(args?: SelectSubset<T, deviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Device.
     * @param {deviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
     */
    create<T extends deviceCreateArgs>(args: SelectSubset<T, deviceCreateArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Devices.
     * @param {deviceCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends deviceCreateManyArgs>(args?: SelectSubset<T, deviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Devices and returns the data saved in the database.
     * @param {deviceCreateManyAndReturnArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends deviceCreateManyAndReturnArgs>(args?: SelectSubset<T, deviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Device.
     * @param {deviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
     */
    delete<T extends deviceDeleteArgs>(args: SelectSubset<T, deviceDeleteArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Device.
     * @param {deviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends deviceUpdateArgs>(args: SelectSubset<T, deviceUpdateArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Devices.
     * @param {deviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends deviceDeleteManyArgs>(args?: SelectSubset<T, deviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends deviceUpdateManyArgs>(args: SelectSubset<T, deviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices and returns the data updated in the database.
     * @param {deviceUpdateManyAndReturnArgs} args - Arguments to update many Devices.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends deviceUpdateManyAndReturnArgs>(args: SelectSubset<T, deviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Device.
     * @param {deviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
     */
    upsert<T extends deviceUpsertArgs>(args: SelectSubset<T, deviceUpsertArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends deviceCountArgs>(
      args?: Subset<T, deviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends deviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: deviceGroupByArgs['orderBy'] }
        : { orderBy?: deviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, deviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the device model
   */
  readonly fields: deviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__deviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alert<T extends device$alertArgs<ExtArgs> = {}>(args?: Subset<T, device$alertArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    state_type<T extends state_typeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, state_typeDefaultArgs<ExtArgs>>): Prisma__state_typeClient<$Result.GetResult<Prisma.$state_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    device_type<T extends device_typeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, device_typeDefaultArgs<ExtArgs>>): Prisma__device_typeClient<$Result.GetResult<Prisma.$device_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends device$userArgs<ExtArgs> = {}>(args?: Subset<T, device$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    purchase_history<T extends device$purchase_historyArgs<ExtArgs> = {}>(args?: Subset<T, device$purchase_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$purchase_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the device model
   */
  interface deviceFieldRefs {
    readonly id: FieldRef<"device", 'Int'>
    readonly type_id: FieldRef<"device", 'Int'>
    readonly state_type_id: FieldRef<"device", 'Int'>
    readonly user_id: FieldRef<"device", 'Int'>
    readonly mac_address: FieldRef<"device", 'String'>
    readonly software_version: FieldRef<"device", 'String'>
    readonly date_of_service: FieldRef<"device", 'DateTime'>
    readonly comm_state: FieldRef<"device", 'Boolean'>
    readonly connection_state: FieldRef<"device", 'Boolean'>
    readonly battery_capacity: FieldRef<"device", 'Int'>
    readonly price: FieldRef<"device", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * device findUnique
   */
  export type deviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * Filter, which device to fetch.
     */
    where: deviceWhereUniqueInput
  }

  /**
   * device findUniqueOrThrow
   */
  export type deviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * Filter, which device to fetch.
     */
    where: deviceWhereUniqueInput
  }

  /**
   * device findFirst
   */
  export type deviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * Filter, which device to fetch.
     */
    where?: deviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of devices to fetch.
     */
    orderBy?: deviceOrderByWithRelationInput | deviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for devices.
     */
    cursor?: deviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * device findFirstOrThrow
   */
  export type deviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * Filter, which device to fetch.
     */
    where?: deviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of devices to fetch.
     */
    orderBy?: deviceOrderByWithRelationInput | deviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for devices.
     */
    cursor?: deviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * device findMany
   */
  export type deviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * Filter, which devices to fetch.
     */
    where?: deviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of devices to fetch.
     */
    orderBy?: deviceOrderByWithRelationInput | deviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing devices.
     */
    cursor?: deviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` devices.
     */
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * device create
   */
  export type deviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * The data needed to create a device.
     */
    data: XOR<deviceCreateInput, deviceUncheckedCreateInput>
  }

  /**
   * device createMany
   */
  export type deviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many devices.
     */
    data: deviceCreateManyInput | deviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * device createManyAndReturn
   */
  export type deviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * The data used to create many devices.
     */
    data: deviceCreateManyInput | deviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * device update
   */
  export type deviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * The data needed to update a device.
     */
    data: XOR<deviceUpdateInput, deviceUncheckedUpdateInput>
    /**
     * Choose, which device to update.
     */
    where: deviceWhereUniqueInput
  }

  /**
   * device updateMany
   */
  export type deviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update devices.
     */
    data: XOR<deviceUpdateManyMutationInput, deviceUncheckedUpdateManyInput>
    /**
     * Filter which devices to update
     */
    where?: deviceWhereInput
    /**
     * Limit how many devices to update.
     */
    limit?: number
  }

  /**
   * device updateManyAndReturn
   */
  export type deviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * The data used to update devices.
     */
    data: XOR<deviceUpdateManyMutationInput, deviceUncheckedUpdateManyInput>
    /**
     * Filter which devices to update
     */
    where?: deviceWhereInput
    /**
     * Limit how many devices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * device upsert
   */
  export type deviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * The filter to search for the device to update in case it exists.
     */
    where: deviceWhereUniqueInput
    /**
     * In case the device found by the `where` argument doesn't exist, create a new device with this data.
     */
    create: XOR<deviceCreateInput, deviceUncheckedCreateInput>
    /**
     * In case the device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<deviceUpdateInput, deviceUncheckedUpdateInput>
  }

  /**
   * device delete
   */
  export type deviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * Filter which device to delete.
     */
    where: deviceWhereUniqueInput
  }

  /**
   * device deleteMany
   */
  export type deviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which devices to delete
     */
    where?: deviceWhereInput
    /**
     * Limit how many devices to delete.
     */
    limit?: number
  }

  /**
   * device.alert
   */
  export type device$alertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alert
     */
    omit?: alertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    where?: alertWhereInput
    orderBy?: alertOrderByWithRelationInput | alertOrderByWithRelationInput[]
    cursor?: alertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * device.user
   */
  export type device$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * device.purchase_history
   */
  export type device$purchase_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase_history
     */
    select?: purchase_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the purchase_history
     */
    omit?: purchase_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchase_historyInclude<ExtArgs> | null
    where?: purchase_historyWhereInput
    orderBy?: purchase_historyOrderByWithRelationInput | purchase_historyOrderByWithRelationInput[]
    cursor?: purchase_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Purchase_historyScalarFieldEnum | Purchase_historyScalarFieldEnum[]
  }

  /**
   * device without action
   */
  export type deviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
  }


  /**
   * Model device_type
   */

  export type AggregateDevice_type = {
    _count: Device_typeCountAggregateOutputType | null
    _avg: Device_typeAvgAggregateOutputType | null
    _sum: Device_typeSumAggregateOutputType | null
    _min: Device_typeMinAggregateOutputType | null
    _max: Device_typeMaxAggregateOutputType | null
  }

  export type Device_typeAvgAggregateOutputType = {
    id: number | null
  }

  export type Device_typeSumAggregateOutputType = {
    id: number | null
  }

  export type Device_typeMinAggregateOutputType = {
    id: number | null
    type: string | null
  }

  export type Device_typeMaxAggregateOutputType = {
    id: number | null
    type: string | null
  }

  export type Device_typeCountAggregateOutputType = {
    id: number
    type: number
    _all: number
  }


  export type Device_typeAvgAggregateInputType = {
    id?: true
  }

  export type Device_typeSumAggregateInputType = {
    id?: true
  }

  export type Device_typeMinAggregateInputType = {
    id?: true
    type?: true
  }

  export type Device_typeMaxAggregateInputType = {
    id?: true
    type?: true
  }

  export type Device_typeCountAggregateInputType = {
    id?: true
    type?: true
    _all?: true
  }

  export type Device_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which device_type to aggregate.
     */
    where?: device_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of device_types to fetch.
     */
    orderBy?: device_typeOrderByWithRelationInput | device_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: device_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` device_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` device_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned device_types
    **/
    _count?: true | Device_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Device_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Device_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Device_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Device_typeMaxAggregateInputType
  }

  export type GetDevice_typeAggregateType<T extends Device_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice_type[P]>
      : GetScalarType<T[P], AggregateDevice_type[P]>
  }




  export type device_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: device_typeWhereInput
    orderBy?: device_typeOrderByWithAggregationInput | device_typeOrderByWithAggregationInput[]
    by: Device_typeScalarFieldEnum[] | Device_typeScalarFieldEnum
    having?: device_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Device_typeCountAggregateInputType | true
    _avg?: Device_typeAvgAggregateInputType
    _sum?: Device_typeSumAggregateInputType
    _min?: Device_typeMinAggregateInputType
    _max?: Device_typeMaxAggregateInputType
  }

  export type Device_typeGroupByOutputType = {
    id: number
    type: string
    _count: Device_typeCountAggregateOutputType | null
    _avg: Device_typeAvgAggregateOutputType | null
    _sum: Device_typeSumAggregateOutputType | null
    _min: Device_typeMinAggregateOutputType | null
    _max: Device_typeMaxAggregateOutputType | null
  }

  type GetDevice_typeGroupByPayload<T extends device_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Device_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Device_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Device_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Device_typeGroupByOutputType[P]>
        }
      >
    >


  export type device_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    device?: boolean | device_type$deviceArgs<ExtArgs>
    _count?: boolean | Device_typeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device_type"]>

  export type device_typeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
  }, ExtArgs["result"]["device_type"]>

  export type device_typeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
  }, ExtArgs["result"]["device_type"]>

  export type device_typeSelectScalar = {
    id?: boolean
    type?: boolean
  }

  export type device_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type", ExtArgs["result"]["device_type"]>
  export type device_typeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | device_type$deviceArgs<ExtArgs>
    _count?: boolean | Device_typeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type device_typeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type device_typeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $device_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "device_type"
    objects: {
      device: Prisma.$devicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
    }, ExtArgs["result"]["device_type"]>
    composites: {}
  }

  type device_typeGetPayload<S extends boolean | null | undefined | device_typeDefaultArgs> = $Result.GetResult<Prisma.$device_typePayload, S>

  type device_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<device_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Device_typeCountAggregateInputType | true
    }

  export interface device_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['device_type'], meta: { name: 'device_type' } }
    /**
     * Find zero or one Device_type that matches the filter.
     * @param {device_typeFindUniqueArgs} args - Arguments to find a Device_type
     * @example
     * // Get one Device_type
     * const device_type = await prisma.device_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends device_typeFindUniqueArgs>(args: SelectSubset<T, device_typeFindUniqueArgs<ExtArgs>>): Prisma__device_typeClient<$Result.GetResult<Prisma.$device_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Device_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {device_typeFindUniqueOrThrowArgs} args - Arguments to find a Device_type
     * @example
     * // Get one Device_type
     * const device_type = await prisma.device_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends device_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, device_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__device_typeClient<$Result.GetResult<Prisma.$device_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_typeFindFirstArgs} args - Arguments to find a Device_type
     * @example
     * // Get one Device_type
     * const device_type = await prisma.device_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends device_typeFindFirstArgs>(args?: SelectSubset<T, device_typeFindFirstArgs<ExtArgs>>): Prisma__device_typeClient<$Result.GetResult<Prisma.$device_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_typeFindFirstOrThrowArgs} args - Arguments to find a Device_type
     * @example
     * // Get one Device_type
     * const device_type = await prisma.device_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends device_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, device_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__device_typeClient<$Result.GetResult<Prisma.$device_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Device_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Device_types
     * const device_types = await prisma.device_type.findMany()
     * 
     * // Get first 10 Device_types
     * const device_types = await prisma.device_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const device_typeWithIdOnly = await prisma.device_type.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends device_typeFindManyArgs>(args?: SelectSubset<T, device_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$device_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Device_type.
     * @param {device_typeCreateArgs} args - Arguments to create a Device_type.
     * @example
     * // Create one Device_type
     * const Device_type = await prisma.device_type.create({
     *   data: {
     *     // ... data to create a Device_type
     *   }
     * })
     * 
     */
    create<T extends device_typeCreateArgs>(args: SelectSubset<T, device_typeCreateArgs<ExtArgs>>): Prisma__device_typeClient<$Result.GetResult<Prisma.$device_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Device_types.
     * @param {device_typeCreateManyArgs} args - Arguments to create many Device_types.
     * @example
     * // Create many Device_types
     * const device_type = await prisma.device_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends device_typeCreateManyArgs>(args?: SelectSubset<T, device_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Device_types and returns the data saved in the database.
     * @param {device_typeCreateManyAndReturnArgs} args - Arguments to create many Device_types.
     * @example
     * // Create many Device_types
     * const device_type = await prisma.device_type.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Device_types and only return the `id`
     * const device_typeWithIdOnly = await prisma.device_type.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends device_typeCreateManyAndReturnArgs>(args?: SelectSubset<T, device_typeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$device_typePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Device_type.
     * @param {device_typeDeleteArgs} args - Arguments to delete one Device_type.
     * @example
     * // Delete one Device_type
     * const Device_type = await prisma.device_type.delete({
     *   where: {
     *     // ... filter to delete one Device_type
     *   }
     * })
     * 
     */
    delete<T extends device_typeDeleteArgs>(args: SelectSubset<T, device_typeDeleteArgs<ExtArgs>>): Prisma__device_typeClient<$Result.GetResult<Prisma.$device_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Device_type.
     * @param {device_typeUpdateArgs} args - Arguments to update one Device_type.
     * @example
     * // Update one Device_type
     * const device_type = await prisma.device_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends device_typeUpdateArgs>(args: SelectSubset<T, device_typeUpdateArgs<ExtArgs>>): Prisma__device_typeClient<$Result.GetResult<Prisma.$device_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Device_types.
     * @param {device_typeDeleteManyArgs} args - Arguments to filter Device_types to delete.
     * @example
     * // Delete a few Device_types
     * const { count } = await prisma.device_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends device_typeDeleteManyArgs>(args?: SelectSubset<T, device_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Device_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Device_types
     * const device_type = await prisma.device_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends device_typeUpdateManyArgs>(args: SelectSubset<T, device_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Device_types and returns the data updated in the database.
     * @param {device_typeUpdateManyAndReturnArgs} args - Arguments to update many Device_types.
     * @example
     * // Update many Device_types
     * const device_type = await prisma.device_type.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Device_types and only return the `id`
     * const device_typeWithIdOnly = await prisma.device_type.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends device_typeUpdateManyAndReturnArgs>(args: SelectSubset<T, device_typeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$device_typePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Device_type.
     * @param {device_typeUpsertArgs} args - Arguments to update or create a Device_type.
     * @example
     * // Update or create a Device_type
     * const device_type = await prisma.device_type.upsert({
     *   create: {
     *     // ... data to create a Device_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device_type we want to update
     *   }
     * })
     */
    upsert<T extends device_typeUpsertArgs>(args: SelectSubset<T, device_typeUpsertArgs<ExtArgs>>): Prisma__device_typeClient<$Result.GetResult<Prisma.$device_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Device_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_typeCountArgs} args - Arguments to filter Device_types to count.
     * @example
     * // Count the number of Device_types
     * const count = await prisma.device_type.count({
     *   where: {
     *     // ... the filter for the Device_types we want to count
     *   }
     * })
    **/
    count<T extends device_typeCountArgs>(
      args?: Subset<T, device_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Device_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Device_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Device_typeAggregateArgs>(args: Subset<T, Device_typeAggregateArgs>): Prisma.PrismaPromise<GetDevice_typeAggregateType<T>>

    /**
     * Group by Device_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends device_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: device_typeGroupByArgs['orderBy'] }
        : { orderBy?: device_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, device_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDevice_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the device_type model
   */
  readonly fields: device_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for device_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__device_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends device_type$deviceArgs<ExtArgs> = {}>(args?: Subset<T, device_type$deviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the device_type model
   */
  interface device_typeFieldRefs {
    readonly id: FieldRef<"device_type", 'Int'>
    readonly type: FieldRef<"device_type", 'String'>
  }
    

  // Custom InputTypes
  /**
   * device_type findUnique
   */
  export type device_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_type
     */
    select?: device_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_type
     */
    omit?: device_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_typeInclude<ExtArgs> | null
    /**
     * Filter, which device_type to fetch.
     */
    where: device_typeWhereUniqueInput
  }

  /**
   * device_type findUniqueOrThrow
   */
  export type device_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_type
     */
    select?: device_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_type
     */
    omit?: device_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_typeInclude<ExtArgs> | null
    /**
     * Filter, which device_type to fetch.
     */
    where: device_typeWhereUniqueInput
  }

  /**
   * device_type findFirst
   */
  export type device_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_type
     */
    select?: device_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_type
     */
    omit?: device_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_typeInclude<ExtArgs> | null
    /**
     * Filter, which device_type to fetch.
     */
    where?: device_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of device_types to fetch.
     */
    orderBy?: device_typeOrderByWithRelationInput | device_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for device_types.
     */
    cursor?: device_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` device_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` device_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of device_types.
     */
    distinct?: Device_typeScalarFieldEnum | Device_typeScalarFieldEnum[]
  }

  /**
   * device_type findFirstOrThrow
   */
  export type device_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_type
     */
    select?: device_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_type
     */
    omit?: device_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_typeInclude<ExtArgs> | null
    /**
     * Filter, which device_type to fetch.
     */
    where?: device_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of device_types to fetch.
     */
    orderBy?: device_typeOrderByWithRelationInput | device_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for device_types.
     */
    cursor?: device_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` device_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` device_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of device_types.
     */
    distinct?: Device_typeScalarFieldEnum | Device_typeScalarFieldEnum[]
  }

  /**
   * device_type findMany
   */
  export type device_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_type
     */
    select?: device_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_type
     */
    omit?: device_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_typeInclude<ExtArgs> | null
    /**
     * Filter, which device_types to fetch.
     */
    where?: device_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of device_types to fetch.
     */
    orderBy?: device_typeOrderByWithRelationInput | device_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing device_types.
     */
    cursor?: device_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` device_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` device_types.
     */
    skip?: number
    distinct?: Device_typeScalarFieldEnum | Device_typeScalarFieldEnum[]
  }

  /**
   * device_type create
   */
  export type device_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_type
     */
    select?: device_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_type
     */
    omit?: device_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_typeInclude<ExtArgs> | null
    /**
     * The data needed to create a device_type.
     */
    data: XOR<device_typeCreateInput, device_typeUncheckedCreateInput>
  }

  /**
   * device_type createMany
   */
  export type device_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many device_types.
     */
    data: device_typeCreateManyInput | device_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * device_type createManyAndReturn
   */
  export type device_typeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_type
     */
    select?: device_typeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the device_type
     */
    omit?: device_typeOmit<ExtArgs> | null
    /**
     * The data used to create many device_types.
     */
    data: device_typeCreateManyInput | device_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * device_type update
   */
  export type device_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_type
     */
    select?: device_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_type
     */
    omit?: device_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_typeInclude<ExtArgs> | null
    /**
     * The data needed to update a device_type.
     */
    data: XOR<device_typeUpdateInput, device_typeUncheckedUpdateInput>
    /**
     * Choose, which device_type to update.
     */
    where: device_typeWhereUniqueInput
  }

  /**
   * device_type updateMany
   */
  export type device_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update device_types.
     */
    data: XOR<device_typeUpdateManyMutationInput, device_typeUncheckedUpdateManyInput>
    /**
     * Filter which device_types to update
     */
    where?: device_typeWhereInput
    /**
     * Limit how many device_types to update.
     */
    limit?: number
  }

  /**
   * device_type updateManyAndReturn
   */
  export type device_typeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_type
     */
    select?: device_typeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the device_type
     */
    omit?: device_typeOmit<ExtArgs> | null
    /**
     * The data used to update device_types.
     */
    data: XOR<device_typeUpdateManyMutationInput, device_typeUncheckedUpdateManyInput>
    /**
     * Filter which device_types to update
     */
    where?: device_typeWhereInput
    /**
     * Limit how many device_types to update.
     */
    limit?: number
  }

  /**
   * device_type upsert
   */
  export type device_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_type
     */
    select?: device_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_type
     */
    omit?: device_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_typeInclude<ExtArgs> | null
    /**
     * The filter to search for the device_type to update in case it exists.
     */
    where: device_typeWhereUniqueInput
    /**
     * In case the device_type found by the `where` argument doesn't exist, create a new device_type with this data.
     */
    create: XOR<device_typeCreateInput, device_typeUncheckedCreateInput>
    /**
     * In case the device_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<device_typeUpdateInput, device_typeUncheckedUpdateInput>
  }

  /**
   * device_type delete
   */
  export type device_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_type
     */
    select?: device_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_type
     */
    omit?: device_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_typeInclude<ExtArgs> | null
    /**
     * Filter which device_type to delete.
     */
    where: device_typeWhereUniqueInput
  }

  /**
   * device_type deleteMany
   */
  export type device_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which device_types to delete
     */
    where?: device_typeWhereInput
    /**
     * Limit how many device_types to delete.
     */
    limit?: number
  }

  /**
   * device_type.device
   */
  export type device_type$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    where?: deviceWhereInput
    orderBy?: deviceOrderByWithRelationInput | deviceOrderByWithRelationInput[]
    cursor?: deviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * device_type without action
   */
  export type device_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_type
     */
    select?: device_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_type
     */
    omit?: device_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_typeInclude<ExtArgs> | null
  }


  /**
   * Model emergency_contact
   */

  export type AggregateEmergency_contact = {
    _count: Emergency_contactCountAggregateOutputType | null
    _avg: Emergency_contactAvgAggregateOutputType | null
    _sum: Emergency_contactSumAggregateOutputType | null
    _min: Emergency_contactMinAggregateOutputType | null
    _max: Emergency_contactMaxAggregateOutputType | null
  }

  export type Emergency_contactAvgAggregateOutputType = {
    id: number | null
  }

  export type Emergency_contactSumAggregateOutputType = {
    id: bigint | null
  }

  export type Emergency_contactMinAggregateOutputType = {
    id: bigint | null
    label: string | null
    number: string | null
  }

  export type Emergency_contactMaxAggregateOutputType = {
    id: bigint | null
    label: string | null
    number: string | null
  }

  export type Emergency_contactCountAggregateOutputType = {
    id: number
    label: number
    number: number
    _all: number
  }


  export type Emergency_contactAvgAggregateInputType = {
    id?: true
  }

  export type Emergency_contactSumAggregateInputType = {
    id?: true
  }

  export type Emergency_contactMinAggregateInputType = {
    id?: true
    label?: true
    number?: true
  }

  export type Emergency_contactMaxAggregateInputType = {
    id?: true
    label?: true
    number?: true
  }

  export type Emergency_contactCountAggregateInputType = {
    id?: true
    label?: true
    number?: true
    _all?: true
  }

  export type Emergency_contactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which emergency_contact to aggregate.
     */
    where?: emergency_contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emergency_contacts to fetch.
     */
    orderBy?: emergency_contactOrderByWithRelationInput | emergency_contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: emergency_contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emergency_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emergency_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned emergency_contacts
    **/
    _count?: true | Emergency_contactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Emergency_contactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Emergency_contactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Emergency_contactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Emergency_contactMaxAggregateInputType
  }

  export type GetEmergency_contactAggregateType<T extends Emergency_contactAggregateArgs> = {
        [P in keyof T & keyof AggregateEmergency_contact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmergency_contact[P]>
      : GetScalarType<T[P], AggregateEmergency_contact[P]>
  }




  export type emergency_contactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: emergency_contactWhereInput
    orderBy?: emergency_contactOrderByWithAggregationInput | emergency_contactOrderByWithAggregationInput[]
    by: Emergency_contactScalarFieldEnum[] | Emergency_contactScalarFieldEnum
    having?: emergency_contactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Emergency_contactCountAggregateInputType | true
    _avg?: Emergency_contactAvgAggregateInputType
    _sum?: Emergency_contactSumAggregateInputType
    _min?: Emergency_contactMinAggregateInputType
    _max?: Emergency_contactMaxAggregateInputType
  }

  export type Emergency_contactGroupByOutputType = {
    id: bigint
    label: string | null
    number: string | null
    _count: Emergency_contactCountAggregateOutputType | null
    _avg: Emergency_contactAvgAggregateOutputType | null
    _sum: Emergency_contactSumAggregateOutputType | null
    _min: Emergency_contactMinAggregateOutputType | null
    _max: Emergency_contactMaxAggregateOutputType | null
  }

  type GetEmergency_contactGroupByPayload<T extends emergency_contactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Emergency_contactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Emergency_contactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Emergency_contactGroupByOutputType[P]>
            : GetScalarType<T[P], Emergency_contactGroupByOutputType[P]>
        }
      >
    >


  export type emergency_contactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    number?: boolean
  }, ExtArgs["result"]["emergency_contact"]>

  export type emergency_contactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    number?: boolean
  }, ExtArgs["result"]["emergency_contact"]>

  export type emergency_contactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    number?: boolean
  }, ExtArgs["result"]["emergency_contact"]>

  export type emergency_contactSelectScalar = {
    id?: boolean
    label?: boolean
    number?: boolean
  }

  export type emergency_contactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "number", ExtArgs["result"]["emergency_contact"]>

  export type $emergency_contactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "emergency_contact"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      label: string | null
      number: string | null
    }, ExtArgs["result"]["emergency_contact"]>
    composites: {}
  }

  type emergency_contactGetPayload<S extends boolean | null | undefined | emergency_contactDefaultArgs> = $Result.GetResult<Prisma.$emergency_contactPayload, S>

  type emergency_contactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<emergency_contactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Emergency_contactCountAggregateInputType | true
    }

  export interface emergency_contactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['emergency_contact'], meta: { name: 'emergency_contact' } }
    /**
     * Find zero or one Emergency_contact that matches the filter.
     * @param {emergency_contactFindUniqueArgs} args - Arguments to find a Emergency_contact
     * @example
     * // Get one Emergency_contact
     * const emergency_contact = await prisma.emergency_contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends emergency_contactFindUniqueArgs>(args: SelectSubset<T, emergency_contactFindUniqueArgs<ExtArgs>>): Prisma__emergency_contactClient<$Result.GetResult<Prisma.$emergency_contactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Emergency_contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {emergency_contactFindUniqueOrThrowArgs} args - Arguments to find a Emergency_contact
     * @example
     * // Get one Emergency_contact
     * const emergency_contact = await prisma.emergency_contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends emergency_contactFindUniqueOrThrowArgs>(args: SelectSubset<T, emergency_contactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__emergency_contactClient<$Result.GetResult<Prisma.$emergency_contactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emergency_contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emergency_contactFindFirstArgs} args - Arguments to find a Emergency_contact
     * @example
     * // Get one Emergency_contact
     * const emergency_contact = await prisma.emergency_contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends emergency_contactFindFirstArgs>(args?: SelectSubset<T, emergency_contactFindFirstArgs<ExtArgs>>): Prisma__emergency_contactClient<$Result.GetResult<Prisma.$emergency_contactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emergency_contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emergency_contactFindFirstOrThrowArgs} args - Arguments to find a Emergency_contact
     * @example
     * // Get one Emergency_contact
     * const emergency_contact = await prisma.emergency_contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends emergency_contactFindFirstOrThrowArgs>(args?: SelectSubset<T, emergency_contactFindFirstOrThrowArgs<ExtArgs>>): Prisma__emergency_contactClient<$Result.GetResult<Prisma.$emergency_contactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Emergency_contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emergency_contactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emergency_contacts
     * const emergency_contacts = await prisma.emergency_contact.findMany()
     * 
     * // Get first 10 Emergency_contacts
     * const emergency_contacts = await prisma.emergency_contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emergency_contactWithIdOnly = await prisma.emergency_contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends emergency_contactFindManyArgs>(args?: SelectSubset<T, emergency_contactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$emergency_contactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Emergency_contact.
     * @param {emergency_contactCreateArgs} args - Arguments to create a Emergency_contact.
     * @example
     * // Create one Emergency_contact
     * const Emergency_contact = await prisma.emergency_contact.create({
     *   data: {
     *     // ... data to create a Emergency_contact
     *   }
     * })
     * 
     */
    create<T extends emergency_contactCreateArgs>(args: SelectSubset<T, emergency_contactCreateArgs<ExtArgs>>): Prisma__emergency_contactClient<$Result.GetResult<Prisma.$emergency_contactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Emergency_contacts.
     * @param {emergency_contactCreateManyArgs} args - Arguments to create many Emergency_contacts.
     * @example
     * // Create many Emergency_contacts
     * const emergency_contact = await prisma.emergency_contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends emergency_contactCreateManyArgs>(args?: SelectSubset<T, emergency_contactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Emergency_contacts and returns the data saved in the database.
     * @param {emergency_contactCreateManyAndReturnArgs} args - Arguments to create many Emergency_contacts.
     * @example
     * // Create many Emergency_contacts
     * const emergency_contact = await prisma.emergency_contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Emergency_contacts and only return the `id`
     * const emergency_contactWithIdOnly = await prisma.emergency_contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends emergency_contactCreateManyAndReturnArgs>(args?: SelectSubset<T, emergency_contactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$emergency_contactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Emergency_contact.
     * @param {emergency_contactDeleteArgs} args - Arguments to delete one Emergency_contact.
     * @example
     * // Delete one Emergency_contact
     * const Emergency_contact = await prisma.emergency_contact.delete({
     *   where: {
     *     // ... filter to delete one Emergency_contact
     *   }
     * })
     * 
     */
    delete<T extends emergency_contactDeleteArgs>(args: SelectSubset<T, emergency_contactDeleteArgs<ExtArgs>>): Prisma__emergency_contactClient<$Result.GetResult<Prisma.$emergency_contactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Emergency_contact.
     * @param {emergency_contactUpdateArgs} args - Arguments to update one Emergency_contact.
     * @example
     * // Update one Emergency_contact
     * const emergency_contact = await prisma.emergency_contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends emergency_contactUpdateArgs>(args: SelectSubset<T, emergency_contactUpdateArgs<ExtArgs>>): Prisma__emergency_contactClient<$Result.GetResult<Prisma.$emergency_contactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Emergency_contacts.
     * @param {emergency_contactDeleteManyArgs} args - Arguments to filter Emergency_contacts to delete.
     * @example
     * // Delete a few Emergency_contacts
     * const { count } = await prisma.emergency_contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends emergency_contactDeleteManyArgs>(args?: SelectSubset<T, emergency_contactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emergency_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emergency_contactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emergency_contacts
     * const emergency_contact = await prisma.emergency_contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends emergency_contactUpdateManyArgs>(args: SelectSubset<T, emergency_contactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emergency_contacts and returns the data updated in the database.
     * @param {emergency_contactUpdateManyAndReturnArgs} args - Arguments to update many Emergency_contacts.
     * @example
     * // Update many Emergency_contacts
     * const emergency_contact = await prisma.emergency_contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Emergency_contacts and only return the `id`
     * const emergency_contactWithIdOnly = await prisma.emergency_contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends emergency_contactUpdateManyAndReturnArgs>(args: SelectSubset<T, emergency_contactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$emergency_contactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Emergency_contact.
     * @param {emergency_contactUpsertArgs} args - Arguments to update or create a Emergency_contact.
     * @example
     * // Update or create a Emergency_contact
     * const emergency_contact = await prisma.emergency_contact.upsert({
     *   create: {
     *     // ... data to create a Emergency_contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Emergency_contact we want to update
     *   }
     * })
     */
    upsert<T extends emergency_contactUpsertArgs>(args: SelectSubset<T, emergency_contactUpsertArgs<ExtArgs>>): Prisma__emergency_contactClient<$Result.GetResult<Prisma.$emergency_contactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Emergency_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emergency_contactCountArgs} args - Arguments to filter Emergency_contacts to count.
     * @example
     * // Count the number of Emergency_contacts
     * const count = await prisma.emergency_contact.count({
     *   where: {
     *     // ... the filter for the Emergency_contacts we want to count
     *   }
     * })
    **/
    count<T extends emergency_contactCountArgs>(
      args?: Subset<T, emergency_contactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Emergency_contactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Emergency_contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Emergency_contactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Emergency_contactAggregateArgs>(args: Subset<T, Emergency_contactAggregateArgs>): Prisma.PrismaPromise<GetEmergency_contactAggregateType<T>>

    /**
     * Group by Emergency_contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emergency_contactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends emergency_contactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: emergency_contactGroupByArgs['orderBy'] }
        : { orderBy?: emergency_contactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, emergency_contactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmergency_contactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the emergency_contact model
   */
  readonly fields: emergency_contactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for emergency_contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__emergency_contactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the emergency_contact model
   */
  interface emergency_contactFieldRefs {
    readonly id: FieldRef<"emergency_contact", 'BigInt'>
    readonly label: FieldRef<"emergency_contact", 'String'>
    readonly number: FieldRef<"emergency_contact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * emergency_contact findUnique
   */
  export type emergency_contactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emergency_contact
     */
    select?: emergency_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emergency_contact
     */
    omit?: emergency_contactOmit<ExtArgs> | null
    /**
     * Filter, which emergency_contact to fetch.
     */
    where: emergency_contactWhereUniqueInput
  }

  /**
   * emergency_contact findUniqueOrThrow
   */
  export type emergency_contactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emergency_contact
     */
    select?: emergency_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emergency_contact
     */
    omit?: emergency_contactOmit<ExtArgs> | null
    /**
     * Filter, which emergency_contact to fetch.
     */
    where: emergency_contactWhereUniqueInput
  }

  /**
   * emergency_contact findFirst
   */
  export type emergency_contactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emergency_contact
     */
    select?: emergency_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emergency_contact
     */
    omit?: emergency_contactOmit<ExtArgs> | null
    /**
     * Filter, which emergency_contact to fetch.
     */
    where?: emergency_contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emergency_contacts to fetch.
     */
    orderBy?: emergency_contactOrderByWithRelationInput | emergency_contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for emergency_contacts.
     */
    cursor?: emergency_contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emergency_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emergency_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of emergency_contacts.
     */
    distinct?: Emergency_contactScalarFieldEnum | Emergency_contactScalarFieldEnum[]
  }

  /**
   * emergency_contact findFirstOrThrow
   */
  export type emergency_contactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emergency_contact
     */
    select?: emergency_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emergency_contact
     */
    omit?: emergency_contactOmit<ExtArgs> | null
    /**
     * Filter, which emergency_contact to fetch.
     */
    where?: emergency_contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emergency_contacts to fetch.
     */
    orderBy?: emergency_contactOrderByWithRelationInput | emergency_contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for emergency_contacts.
     */
    cursor?: emergency_contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emergency_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emergency_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of emergency_contacts.
     */
    distinct?: Emergency_contactScalarFieldEnum | Emergency_contactScalarFieldEnum[]
  }

  /**
   * emergency_contact findMany
   */
  export type emergency_contactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emergency_contact
     */
    select?: emergency_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emergency_contact
     */
    omit?: emergency_contactOmit<ExtArgs> | null
    /**
     * Filter, which emergency_contacts to fetch.
     */
    where?: emergency_contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emergency_contacts to fetch.
     */
    orderBy?: emergency_contactOrderByWithRelationInput | emergency_contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing emergency_contacts.
     */
    cursor?: emergency_contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emergency_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emergency_contacts.
     */
    skip?: number
    distinct?: Emergency_contactScalarFieldEnum | Emergency_contactScalarFieldEnum[]
  }

  /**
   * emergency_contact create
   */
  export type emergency_contactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emergency_contact
     */
    select?: emergency_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emergency_contact
     */
    omit?: emergency_contactOmit<ExtArgs> | null
    /**
     * The data needed to create a emergency_contact.
     */
    data?: XOR<emergency_contactCreateInput, emergency_contactUncheckedCreateInput>
  }

  /**
   * emergency_contact createMany
   */
  export type emergency_contactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many emergency_contacts.
     */
    data: emergency_contactCreateManyInput | emergency_contactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * emergency_contact createManyAndReturn
   */
  export type emergency_contactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emergency_contact
     */
    select?: emergency_contactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the emergency_contact
     */
    omit?: emergency_contactOmit<ExtArgs> | null
    /**
     * The data used to create many emergency_contacts.
     */
    data: emergency_contactCreateManyInput | emergency_contactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * emergency_contact update
   */
  export type emergency_contactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emergency_contact
     */
    select?: emergency_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emergency_contact
     */
    omit?: emergency_contactOmit<ExtArgs> | null
    /**
     * The data needed to update a emergency_contact.
     */
    data: XOR<emergency_contactUpdateInput, emergency_contactUncheckedUpdateInput>
    /**
     * Choose, which emergency_contact to update.
     */
    where: emergency_contactWhereUniqueInput
  }

  /**
   * emergency_contact updateMany
   */
  export type emergency_contactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update emergency_contacts.
     */
    data: XOR<emergency_contactUpdateManyMutationInput, emergency_contactUncheckedUpdateManyInput>
    /**
     * Filter which emergency_contacts to update
     */
    where?: emergency_contactWhereInput
    /**
     * Limit how many emergency_contacts to update.
     */
    limit?: number
  }

  /**
   * emergency_contact updateManyAndReturn
   */
  export type emergency_contactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emergency_contact
     */
    select?: emergency_contactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the emergency_contact
     */
    omit?: emergency_contactOmit<ExtArgs> | null
    /**
     * The data used to update emergency_contacts.
     */
    data: XOR<emergency_contactUpdateManyMutationInput, emergency_contactUncheckedUpdateManyInput>
    /**
     * Filter which emergency_contacts to update
     */
    where?: emergency_contactWhereInput
    /**
     * Limit how many emergency_contacts to update.
     */
    limit?: number
  }

  /**
   * emergency_contact upsert
   */
  export type emergency_contactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emergency_contact
     */
    select?: emergency_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emergency_contact
     */
    omit?: emergency_contactOmit<ExtArgs> | null
    /**
     * The filter to search for the emergency_contact to update in case it exists.
     */
    where: emergency_contactWhereUniqueInput
    /**
     * In case the emergency_contact found by the `where` argument doesn't exist, create a new emergency_contact with this data.
     */
    create: XOR<emergency_contactCreateInput, emergency_contactUncheckedCreateInput>
    /**
     * In case the emergency_contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<emergency_contactUpdateInput, emergency_contactUncheckedUpdateInput>
  }

  /**
   * emergency_contact delete
   */
  export type emergency_contactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emergency_contact
     */
    select?: emergency_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emergency_contact
     */
    omit?: emergency_contactOmit<ExtArgs> | null
    /**
     * Filter which emergency_contact to delete.
     */
    where: emergency_contactWhereUniqueInput
  }

  /**
   * emergency_contact deleteMany
   */
  export type emergency_contactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which emergency_contacts to delete
     */
    where?: emergency_contactWhereInput
    /**
     * Limit how many emergency_contacts to delete.
     */
    limit?: number
  }

  /**
   * emergency_contact without action
   */
  export type emergency_contactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the emergency_contact
     */
    select?: emergency_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the emergency_contact
     */
    omit?: emergency_contactOmit<ExtArgs> | null
  }


  /**
   * Model env_delimiter
   */

  export type AggregateEnv_delimiter = {
    _count: Env_delimiterCountAggregateOutputType | null
    _avg: Env_delimiterAvgAggregateOutputType | null
    _sum: Env_delimiterSumAggregateOutputType | null
    _min: Env_delimiterMinAggregateOutputType | null
    _max: Env_delimiterMaxAggregateOutputType | null
  }

  export type Env_delimiterAvgAggregateOutputType = {
    id: number | null
    env_id: number | null
  }

  export type Env_delimiterSumAggregateOutputType = {
    id: number | null
    env_id: number | null
  }

  export type Env_delimiterMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    env_id: number | null
    type: string | null
  }

  export type Env_delimiterMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    env_id: number | null
    type: string | null
  }

  export type Env_delimiterCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    env_id: number
    coordinates: number
    type: number
    _all: number
  }


  export type Env_delimiterAvgAggregateInputType = {
    id?: true
    env_id?: true
  }

  export type Env_delimiterSumAggregateInputType = {
    id?: true
    env_id?: true
  }

  export type Env_delimiterMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    env_id?: true
    type?: true
  }

  export type Env_delimiterMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    env_id?: true
    type?: true
  }

  export type Env_delimiterCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    env_id?: true
    coordinates?: true
    type?: true
    _all?: true
  }

  export type Env_delimiterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which env_delimiter to aggregate.
     */
    where?: env_delimiterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of env_delimiters to fetch.
     */
    orderBy?: env_delimiterOrderByWithRelationInput | env_delimiterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: env_delimiterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` env_delimiters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` env_delimiters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned env_delimiters
    **/
    _count?: true | Env_delimiterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Env_delimiterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Env_delimiterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Env_delimiterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Env_delimiterMaxAggregateInputType
  }

  export type GetEnv_delimiterAggregateType<T extends Env_delimiterAggregateArgs> = {
        [P in keyof T & keyof AggregateEnv_delimiter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnv_delimiter[P]>
      : GetScalarType<T[P], AggregateEnv_delimiter[P]>
  }




  export type env_delimiterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: env_delimiterWhereInput
    orderBy?: env_delimiterOrderByWithAggregationInput | env_delimiterOrderByWithAggregationInput[]
    by: Env_delimiterScalarFieldEnum[] | Env_delimiterScalarFieldEnum
    having?: env_delimiterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Env_delimiterCountAggregateInputType | true
    _avg?: Env_delimiterAvgAggregateInputType
    _sum?: Env_delimiterSumAggregateInputType
    _min?: Env_delimiterMinAggregateInputType
    _max?: Env_delimiterMaxAggregateInputType
  }

  export type Env_delimiterGroupByOutputType = {
    id: number
    created_at: Date
    updated_at: Date | null
    env_id: number | null
    coordinates: JsonValue | null
    type: string | null
    _count: Env_delimiterCountAggregateOutputType | null
    _avg: Env_delimiterAvgAggregateOutputType | null
    _sum: Env_delimiterSumAggregateOutputType | null
    _min: Env_delimiterMinAggregateOutputType | null
    _max: Env_delimiterMaxAggregateOutputType | null
  }

  type GetEnv_delimiterGroupByPayload<T extends env_delimiterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Env_delimiterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Env_delimiterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Env_delimiterGroupByOutputType[P]>
            : GetScalarType<T[P], Env_delimiterGroupByOutputType[P]>
        }
      >
    >


  export type env_delimiterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    env_id?: boolean
    coordinates?: boolean
    type?: boolean
    environment?: boolean | env_delimiter$environmentArgs<ExtArgs>
  }, ExtArgs["result"]["env_delimiter"]>

  export type env_delimiterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    env_id?: boolean
    coordinates?: boolean
    type?: boolean
    environment?: boolean | env_delimiter$environmentArgs<ExtArgs>
  }, ExtArgs["result"]["env_delimiter"]>

  export type env_delimiterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    env_id?: boolean
    coordinates?: boolean
    type?: boolean
    environment?: boolean | env_delimiter$environmentArgs<ExtArgs>
  }, ExtArgs["result"]["env_delimiter"]>

  export type env_delimiterSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    env_id?: boolean
    coordinates?: boolean
    type?: boolean
  }

  export type env_delimiterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "env_id" | "coordinates" | "type", ExtArgs["result"]["env_delimiter"]>
  export type env_delimiterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | env_delimiter$environmentArgs<ExtArgs>
  }
  export type env_delimiterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | env_delimiter$environmentArgs<ExtArgs>
  }
  export type env_delimiterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | env_delimiter$environmentArgs<ExtArgs>
  }

  export type $env_delimiterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "env_delimiter"
    objects: {
      environment: Prisma.$environmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_at: Date
      updated_at: Date | null
      env_id: number | null
      coordinates: Prisma.JsonValue | null
      type: string | null
    }, ExtArgs["result"]["env_delimiter"]>
    composites: {}
  }

  type env_delimiterGetPayload<S extends boolean | null | undefined | env_delimiterDefaultArgs> = $Result.GetResult<Prisma.$env_delimiterPayload, S>

  type env_delimiterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<env_delimiterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Env_delimiterCountAggregateInputType | true
    }

  export interface env_delimiterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['env_delimiter'], meta: { name: 'env_delimiter' } }
    /**
     * Find zero or one Env_delimiter that matches the filter.
     * @param {env_delimiterFindUniqueArgs} args - Arguments to find a Env_delimiter
     * @example
     * // Get one Env_delimiter
     * const env_delimiter = await prisma.env_delimiter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends env_delimiterFindUniqueArgs>(args: SelectSubset<T, env_delimiterFindUniqueArgs<ExtArgs>>): Prisma__env_delimiterClient<$Result.GetResult<Prisma.$env_delimiterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Env_delimiter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {env_delimiterFindUniqueOrThrowArgs} args - Arguments to find a Env_delimiter
     * @example
     * // Get one Env_delimiter
     * const env_delimiter = await prisma.env_delimiter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends env_delimiterFindUniqueOrThrowArgs>(args: SelectSubset<T, env_delimiterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__env_delimiterClient<$Result.GetResult<Prisma.$env_delimiterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Env_delimiter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_delimiterFindFirstArgs} args - Arguments to find a Env_delimiter
     * @example
     * // Get one Env_delimiter
     * const env_delimiter = await prisma.env_delimiter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends env_delimiterFindFirstArgs>(args?: SelectSubset<T, env_delimiterFindFirstArgs<ExtArgs>>): Prisma__env_delimiterClient<$Result.GetResult<Prisma.$env_delimiterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Env_delimiter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_delimiterFindFirstOrThrowArgs} args - Arguments to find a Env_delimiter
     * @example
     * // Get one Env_delimiter
     * const env_delimiter = await prisma.env_delimiter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends env_delimiterFindFirstOrThrowArgs>(args?: SelectSubset<T, env_delimiterFindFirstOrThrowArgs<ExtArgs>>): Prisma__env_delimiterClient<$Result.GetResult<Prisma.$env_delimiterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Env_delimiters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_delimiterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Env_delimiters
     * const env_delimiters = await prisma.env_delimiter.findMany()
     * 
     * // Get first 10 Env_delimiters
     * const env_delimiters = await prisma.env_delimiter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const env_delimiterWithIdOnly = await prisma.env_delimiter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends env_delimiterFindManyArgs>(args?: SelectSubset<T, env_delimiterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$env_delimiterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Env_delimiter.
     * @param {env_delimiterCreateArgs} args - Arguments to create a Env_delimiter.
     * @example
     * // Create one Env_delimiter
     * const Env_delimiter = await prisma.env_delimiter.create({
     *   data: {
     *     // ... data to create a Env_delimiter
     *   }
     * })
     * 
     */
    create<T extends env_delimiterCreateArgs>(args: SelectSubset<T, env_delimiterCreateArgs<ExtArgs>>): Prisma__env_delimiterClient<$Result.GetResult<Prisma.$env_delimiterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Env_delimiters.
     * @param {env_delimiterCreateManyArgs} args - Arguments to create many Env_delimiters.
     * @example
     * // Create many Env_delimiters
     * const env_delimiter = await prisma.env_delimiter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends env_delimiterCreateManyArgs>(args?: SelectSubset<T, env_delimiterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Env_delimiters and returns the data saved in the database.
     * @param {env_delimiterCreateManyAndReturnArgs} args - Arguments to create many Env_delimiters.
     * @example
     * // Create many Env_delimiters
     * const env_delimiter = await prisma.env_delimiter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Env_delimiters and only return the `id`
     * const env_delimiterWithIdOnly = await prisma.env_delimiter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends env_delimiterCreateManyAndReturnArgs>(args?: SelectSubset<T, env_delimiterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$env_delimiterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Env_delimiter.
     * @param {env_delimiterDeleteArgs} args - Arguments to delete one Env_delimiter.
     * @example
     * // Delete one Env_delimiter
     * const Env_delimiter = await prisma.env_delimiter.delete({
     *   where: {
     *     // ... filter to delete one Env_delimiter
     *   }
     * })
     * 
     */
    delete<T extends env_delimiterDeleteArgs>(args: SelectSubset<T, env_delimiterDeleteArgs<ExtArgs>>): Prisma__env_delimiterClient<$Result.GetResult<Prisma.$env_delimiterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Env_delimiter.
     * @param {env_delimiterUpdateArgs} args - Arguments to update one Env_delimiter.
     * @example
     * // Update one Env_delimiter
     * const env_delimiter = await prisma.env_delimiter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends env_delimiterUpdateArgs>(args: SelectSubset<T, env_delimiterUpdateArgs<ExtArgs>>): Prisma__env_delimiterClient<$Result.GetResult<Prisma.$env_delimiterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Env_delimiters.
     * @param {env_delimiterDeleteManyArgs} args - Arguments to filter Env_delimiters to delete.
     * @example
     * // Delete a few Env_delimiters
     * const { count } = await prisma.env_delimiter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends env_delimiterDeleteManyArgs>(args?: SelectSubset<T, env_delimiterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Env_delimiters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_delimiterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Env_delimiters
     * const env_delimiter = await prisma.env_delimiter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends env_delimiterUpdateManyArgs>(args: SelectSubset<T, env_delimiterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Env_delimiters and returns the data updated in the database.
     * @param {env_delimiterUpdateManyAndReturnArgs} args - Arguments to update many Env_delimiters.
     * @example
     * // Update many Env_delimiters
     * const env_delimiter = await prisma.env_delimiter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Env_delimiters and only return the `id`
     * const env_delimiterWithIdOnly = await prisma.env_delimiter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends env_delimiterUpdateManyAndReturnArgs>(args: SelectSubset<T, env_delimiterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$env_delimiterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Env_delimiter.
     * @param {env_delimiterUpsertArgs} args - Arguments to update or create a Env_delimiter.
     * @example
     * // Update or create a Env_delimiter
     * const env_delimiter = await prisma.env_delimiter.upsert({
     *   create: {
     *     // ... data to create a Env_delimiter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Env_delimiter we want to update
     *   }
     * })
     */
    upsert<T extends env_delimiterUpsertArgs>(args: SelectSubset<T, env_delimiterUpsertArgs<ExtArgs>>): Prisma__env_delimiterClient<$Result.GetResult<Prisma.$env_delimiterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Env_delimiters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_delimiterCountArgs} args - Arguments to filter Env_delimiters to count.
     * @example
     * // Count the number of Env_delimiters
     * const count = await prisma.env_delimiter.count({
     *   where: {
     *     // ... the filter for the Env_delimiters we want to count
     *   }
     * })
    **/
    count<T extends env_delimiterCountArgs>(
      args?: Subset<T, env_delimiterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Env_delimiterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Env_delimiter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Env_delimiterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Env_delimiterAggregateArgs>(args: Subset<T, Env_delimiterAggregateArgs>): Prisma.PrismaPromise<GetEnv_delimiterAggregateType<T>>

    /**
     * Group by Env_delimiter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_delimiterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends env_delimiterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: env_delimiterGroupByArgs['orderBy'] }
        : { orderBy?: env_delimiterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, env_delimiterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnv_delimiterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the env_delimiter model
   */
  readonly fields: env_delimiterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for env_delimiter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__env_delimiterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    environment<T extends env_delimiter$environmentArgs<ExtArgs> = {}>(args?: Subset<T, env_delimiter$environmentArgs<ExtArgs>>): Prisma__environmentClient<$Result.GetResult<Prisma.$environmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the env_delimiter model
   */
  interface env_delimiterFieldRefs {
    readonly id: FieldRef<"env_delimiter", 'Int'>
    readonly created_at: FieldRef<"env_delimiter", 'DateTime'>
    readonly updated_at: FieldRef<"env_delimiter", 'DateTime'>
    readonly env_id: FieldRef<"env_delimiter", 'Int'>
    readonly coordinates: FieldRef<"env_delimiter", 'Json'>
    readonly type: FieldRef<"env_delimiter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * env_delimiter findUnique
   */
  export type env_delimiterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_delimiter
     */
    select?: env_delimiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_delimiter
     */
    omit?: env_delimiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_delimiterInclude<ExtArgs> | null
    /**
     * Filter, which env_delimiter to fetch.
     */
    where: env_delimiterWhereUniqueInput
  }

  /**
   * env_delimiter findUniqueOrThrow
   */
  export type env_delimiterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_delimiter
     */
    select?: env_delimiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_delimiter
     */
    omit?: env_delimiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_delimiterInclude<ExtArgs> | null
    /**
     * Filter, which env_delimiter to fetch.
     */
    where: env_delimiterWhereUniqueInput
  }

  /**
   * env_delimiter findFirst
   */
  export type env_delimiterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_delimiter
     */
    select?: env_delimiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_delimiter
     */
    omit?: env_delimiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_delimiterInclude<ExtArgs> | null
    /**
     * Filter, which env_delimiter to fetch.
     */
    where?: env_delimiterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of env_delimiters to fetch.
     */
    orderBy?: env_delimiterOrderByWithRelationInput | env_delimiterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for env_delimiters.
     */
    cursor?: env_delimiterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` env_delimiters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` env_delimiters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of env_delimiters.
     */
    distinct?: Env_delimiterScalarFieldEnum | Env_delimiterScalarFieldEnum[]
  }

  /**
   * env_delimiter findFirstOrThrow
   */
  export type env_delimiterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_delimiter
     */
    select?: env_delimiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_delimiter
     */
    omit?: env_delimiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_delimiterInclude<ExtArgs> | null
    /**
     * Filter, which env_delimiter to fetch.
     */
    where?: env_delimiterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of env_delimiters to fetch.
     */
    orderBy?: env_delimiterOrderByWithRelationInput | env_delimiterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for env_delimiters.
     */
    cursor?: env_delimiterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` env_delimiters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` env_delimiters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of env_delimiters.
     */
    distinct?: Env_delimiterScalarFieldEnum | Env_delimiterScalarFieldEnum[]
  }

  /**
   * env_delimiter findMany
   */
  export type env_delimiterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_delimiter
     */
    select?: env_delimiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_delimiter
     */
    omit?: env_delimiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_delimiterInclude<ExtArgs> | null
    /**
     * Filter, which env_delimiters to fetch.
     */
    where?: env_delimiterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of env_delimiters to fetch.
     */
    orderBy?: env_delimiterOrderByWithRelationInput | env_delimiterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing env_delimiters.
     */
    cursor?: env_delimiterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` env_delimiters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` env_delimiters.
     */
    skip?: number
    distinct?: Env_delimiterScalarFieldEnum | Env_delimiterScalarFieldEnum[]
  }

  /**
   * env_delimiter create
   */
  export type env_delimiterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_delimiter
     */
    select?: env_delimiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_delimiter
     */
    omit?: env_delimiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_delimiterInclude<ExtArgs> | null
    /**
     * The data needed to create a env_delimiter.
     */
    data?: XOR<env_delimiterCreateInput, env_delimiterUncheckedCreateInput>
  }

  /**
   * env_delimiter createMany
   */
  export type env_delimiterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many env_delimiters.
     */
    data: env_delimiterCreateManyInput | env_delimiterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * env_delimiter createManyAndReturn
   */
  export type env_delimiterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_delimiter
     */
    select?: env_delimiterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the env_delimiter
     */
    omit?: env_delimiterOmit<ExtArgs> | null
    /**
     * The data used to create many env_delimiters.
     */
    data: env_delimiterCreateManyInput | env_delimiterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_delimiterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * env_delimiter update
   */
  export type env_delimiterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_delimiter
     */
    select?: env_delimiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_delimiter
     */
    omit?: env_delimiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_delimiterInclude<ExtArgs> | null
    /**
     * The data needed to update a env_delimiter.
     */
    data: XOR<env_delimiterUpdateInput, env_delimiterUncheckedUpdateInput>
    /**
     * Choose, which env_delimiter to update.
     */
    where: env_delimiterWhereUniqueInput
  }

  /**
   * env_delimiter updateMany
   */
  export type env_delimiterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update env_delimiters.
     */
    data: XOR<env_delimiterUpdateManyMutationInput, env_delimiterUncheckedUpdateManyInput>
    /**
     * Filter which env_delimiters to update
     */
    where?: env_delimiterWhereInput
    /**
     * Limit how many env_delimiters to update.
     */
    limit?: number
  }

  /**
   * env_delimiter updateManyAndReturn
   */
  export type env_delimiterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_delimiter
     */
    select?: env_delimiterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the env_delimiter
     */
    omit?: env_delimiterOmit<ExtArgs> | null
    /**
     * The data used to update env_delimiters.
     */
    data: XOR<env_delimiterUpdateManyMutationInput, env_delimiterUncheckedUpdateManyInput>
    /**
     * Filter which env_delimiters to update
     */
    where?: env_delimiterWhereInput
    /**
     * Limit how many env_delimiters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_delimiterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * env_delimiter upsert
   */
  export type env_delimiterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_delimiter
     */
    select?: env_delimiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_delimiter
     */
    omit?: env_delimiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_delimiterInclude<ExtArgs> | null
    /**
     * The filter to search for the env_delimiter to update in case it exists.
     */
    where: env_delimiterWhereUniqueInput
    /**
     * In case the env_delimiter found by the `where` argument doesn't exist, create a new env_delimiter with this data.
     */
    create: XOR<env_delimiterCreateInput, env_delimiterUncheckedCreateInput>
    /**
     * In case the env_delimiter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<env_delimiterUpdateInput, env_delimiterUncheckedUpdateInput>
  }

  /**
   * env_delimiter delete
   */
  export type env_delimiterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_delimiter
     */
    select?: env_delimiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_delimiter
     */
    omit?: env_delimiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_delimiterInclude<ExtArgs> | null
    /**
     * Filter which env_delimiter to delete.
     */
    where: env_delimiterWhereUniqueInput
  }

  /**
   * env_delimiter deleteMany
   */
  export type env_delimiterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which env_delimiters to delete
     */
    where?: env_delimiterWhereInput
    /**
     * Limit how many env_delimiters to delete.
     */
    limit?: number
  }

  /**
   * env_delimiter.environment
   */
  export type env_delimiter$environmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the environment
     */
    select?: environmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the environment
     */
    omit?: environmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: environmentInclude<ExtArgs> | null
    where?: environmentWhereInput
  }

  /**
   * env_delimiter without action
   */
  export type env_delimiterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_delimiter
     */
    select?: env_delimiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_delimiter
     */
    omit?: env_delimiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_delimiterInclude<ExtArgs> | null
  }


  /**
   * Model env_user
   */

  export type AggregateEnv_user = {
    _count: Env_userCountAggregateOutputType | null
    _avg: Env_userAvgAggregateOutputType | null
    _sum: Env_userSumAggregateOutputType | null
    _min: Env_userMinAggregateOutputType | null
    _max: Env_userMaxAggregateOutputType | null
  }

  export type Env_userAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    env_id: number | null
  }

  export type Env_userSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    env_id: number | null
  }

  export type Env_userMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    env_id: number | null
  }

  export type Env_userMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    env_id: number | null
  }

  export type Env_userCountAggregateOutputType = {
    id: number
    user_id: number
    env_id: number
    _all: number
  }


  export type Env_userAvgAggregateInputType = {
    id?: true
    user_id?: true
    env_id?: true
  }

  export type Env_userSumAggregateInputType = {
    id?: true
    user_id?: true
    env_id?: true
  }

  export type Env_userMinAggregateInputType = {
    id?: true
    user_id?: true
    env_id?: true
  }

  export type Env_userMaxAggregateInputType = {
    id?: true
    user_id?: true
    env_id?: true
  }

  export type Env_userCountAggregateInputType = {
    id?: true
    user_id?: true
    env_id?: true
    _all?: true
  }

  export type Env_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which env_user to aggregate.
     */
    where?: env_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of env_users to fetch.
     */
    orderBy?: env_userOrderByWithRelationInput | env_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: env_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` env_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` env_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned env_users
    **/
    _count?: true | Env_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Env_userAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Env_userSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Env_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Env_userMaxAggregateInputType
  }

  export type GetEnv_userAggregateType<T extends Env_userAggregateArgs> = {
        [P in keyof T & keyof AggregateEnv_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnv_user[P]>
      : GetScalarType<T[P], AggregateEnv_user[P]>
  }




  export type env_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: env_userWhereInput
    orderBy?: env_userOrderByWithAggregationInput | env_userOrderByWithAggregationInput[]
    by: Env_userScalarFieldEnum[] | Env_userScalarFieldEnum
    having?: env_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Env_userCountAggregateInputType | true
    _avg?: Env_userAvgAggregateInputType
    _sum?: Env_userSumAggregateInputType
    _min?: Env_userMinAggregateInputType
    _max?: Env_userMaxAggregateInputType
  }

  export type Env_userGroupByOutputType = {
    id: number
    user_id: number
    env_id: number | null
    _count: Env_userCountAggregateOutputType | null
    _avg: Env_userAvgAggregateOutputType | null
    _sum: Env_userSumAggregateOutputType | null
    _min: Env_userMinAggregateOutputType | null
    _max: Env_userMaxAggregateOutputType | null
  }

  type GetEnv_userGroupByPayload<T extends env_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Env_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Env_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Env_userGroupByOutputType[P]>
            : GetScalarType<T[P], Env_userGroupByOutputType[P]>
        }
      >
    >


  export type env_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    env_id?: boolean
    environment?: boolean | env_user$environmentArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["env_user"]>

  export type env_userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    env_id?: boolean
    environment?: boolean | env_user$environmentArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["env_user"]>

  export type env_userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    env_id?: boolean
    environment?: boolean | env_user$environmentArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["env_user"]>

  export type env_userSelectScalar = {
    id?: boolean
    user_id?: boolean
    env_id?: boolean
  }

  export type env_userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "env_id", ExtArgs["result"]["env_user"]>
  export type env_userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | env_user$environmentArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type env_userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | env_user$environmentArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type env_userIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | env_user$environmentArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $env_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "env_user"
    objects: {
      environment: Prisma.$environmentPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      env_id: number | null
    }, ExtArgs["result"]["env_user"]>
    composites: {}
  }

  type env_userGetPayload<S extends boolean | null | undefined | env_userDefaultArgs> = $Result.GetResult<Prisma.$env_userPayload, S>

  type env_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<env_userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Env_userCountAggregateInputType | true
    }

  export interface env_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['env_user'], meta: { name: 'env_user' } }
    /**
     * Find zero or one Env_user that matches the filter.
     * @param {env_userFindUniqueArgs} args - Arguments to find a Env_user
     * @example
     * // Get one Env_user
     * const env_user = await prisma.env_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends env_userFindUniqueArgs>(args: SelectSubset<T, env_userFindUniqueArgs<ExtArgs>>): Prisma__env_userClient<$Result.GetResult<Prisma.$env_userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Env_user that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {env_userFindUniqueOrThrowArgs} args - Arguments to find a Env_user
     * @example
     * // Get one Env_user
     * const env_user = await prisma.env_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends env_userFindUniqueOrThrowArgs>(args: SelectSubset<T, env_userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__env_userClient<$Result.GetResult<Prisma.$env_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Env_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_userFindFirstArgs} args - Arguments to find a Env_user
     * @example
     * // Get one Env_user
     * const env_user = await prisma.env_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends env_userFindFirstArgs>(args?: SelectSubset<T, env_userFindFirstArgs<ExtArgs>>): Prisma__env_userClient<$Result.GetResult<Prisma.$env_userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Env_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_userFindFirstOrThrowArgs} args - Arguments to find a Env_user
     * @example
     * // Get one Env_user
     * const env_user = await prisma.env_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends env_userFindFirstOrThrowArgs>(args?: SelectSubset<T, env_userFindFirstOrThrowArgs<ExtArgs>>): Prisma__env_userClient<$Result.GetResult<Prisma.$env_userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Env_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Env_users
     * const env_users = await prisma.env_user.findMany()
     * 
     * // Get first 10 Env_users
     * const env_users = await prisma.env_user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const env_userWithIdOnly = await prisma.env_user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends env_userFindManyArgs>(args?: SelectSubset<T, env_userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$env_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Env_user.
     * @param {env_userCreateArgs} args - Arguments to create a Env_user.
     * @example
     * // Create one Env_user
     * const Env_user = await prisma.env_user.create({
     *   data: {
     *     // ... data to create a Env_user
     *   }
     * })
     * 
     */
    create<T extends env_userCreateArgs>(args: SelectSubset<T, env_userCreateArgs<ExtArgs>>): Prisma__env_userClient<$Result.GetResult<Prisma.$env_userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Env_users.
     * @param {env_userCreateManyArgs} args - Arguments to create many Env_users.
     * @example
     * // Create many Env_users
     * const env_user = await prisma.env_user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends env_userCreateManyArgs>(args?: SelectSubset<T, env_userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Env_users and returns the data saved in the database.
     * @param {env_userCreateManyAndReturnArgs} args - Arguments to create many Env_users.
     * @example
     * // Create many Env_users
     * const env_user = await prisma.env_user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Env_users and only return the `id`
     * const env_userWithIdOnly = await prisma.env_user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends env_userCreateManyAndReturnArgs>(args?: SelectSubset<T, env_userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$env_userPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Env_user.
     * @param {env_userDeleteArgs} args - Arguments to delete one Env_user.
     * @example
     * // Delete one Env_user
     * const Env_user = await prisma.env_user.delete({
     *   where: {
     *     // ... filter to delete one Env_user
     *   }
     * })
     * 
     */
    delete<T extends env_userDeleteArgs>(args: SelectSubset<T, env_userDeleteArgs<ExtArgs>>): Prisma__env_userClient<$Result.GetResult<Prisma.$env_userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Env_user.
     * @param {env_userUpdateArgs} args - Arguments to update one Env_user.
     * @example
     * // Update one Env_user
     * const env_user = await prisma.env_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends env_userUpdateArgs>(args: SelectSubset<T, env_userUpdateArgs<ExtArgs>>): Prisma__env_userClient<$Result.GetResult<Prisma.$env_userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Env_users.
     * @param {env_userDeleteManyArgs} args - Arguments to filter Env_users to delete.
     * @example
     * // Delete a few Env_users
     * const { count } = await prisma.env_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends env_userDeleteManyArgs>(args?: SelectSubset<T, env_userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Env_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Env_users
     * const env_user = await prisma.env_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends env_userUpdateManyArgs>(args: SelectSubset<T, env_userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Env_users and returns the data updated in the database.
     * @param {env_userUpdateManyAndReturnArgs} args - Arguments to update many Env_users.
     * @example
     * // Update many Env_users
     * const env_user = await prisma.env_user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Env_users and only return the `id`
     * const env_userWithIdOnly = await prisma.env_user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends env_userUpdateManyAndReturnArgs>(args: SelectSubset<T, env_userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$env_userPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Env_user.
     * @param {env_userUpsertArgs} args - Arguments to update or create a Env_user.
     * @example
     * // Update or create a Env_user
     * const env_user = await prisma.env_user.upsert({
     *   create: {
     *     // ... data to create a Env_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Env_user we want to update
     *   }
     * })
     */
    upsert<T extends env_userUpsertArgs>(args: SelectSubset<T, env_userUpsertArgs<ExtArgs>>): Prisma__env_userClient<$Result.GetResult<Prisma.$env_userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Env_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_userCountArgs} args - Arguments to filter Env_users to count.
     * @example
     * // Count the number of Env_users
     * const count = await prisma.env_user.count({
     *   where: {
     *     // ... the filter for the Env_users we want to count
     *   }
     * })
    **/
    count<T extends env_userCountArgs>(
      args?: Subset<T, env_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Env_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Env_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Env_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Env_userAggregateArgs>(args: Subset<T, Env_userAggregateArgs>): Prisma.PrismaPromise<GetEnv_userAggregateType<T>>

    /**
     * Group by Env_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {env_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends env_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: env_userGroupByArgs['orderBy'] }
        : { orderBy?: env_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, env_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnv_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the env_user model
   */
  readonly fields: env_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for env_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__env_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    environment<T extends env_user$environmentArgs<ExtArgs> = {}>(args?: Subset<T, env_user$environmentArgs<ExtArgs>>): Prisma__environmentClient<$Result.GetResult<Prisma.$environmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the env_user model
   */
  interface env_userFieldRefs {
    readonly id: FieldRef<"env_user", 'Int'>
    readonly user_id: FieldRef<"env_user", 'Int'>
    readonly env_id: FieldRef<"env_user", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * env_user findUnique
   */
  export type env_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_user
     */
    select?: env_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_user
     */
    omit?: env_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_userInclude<ExtArgs> | null
    /**
     * Filter, which env_user to fetch.
     */
    where: env_userWhereUniqueInput
  }

  /**
   * env_user findUniqueOrThrow
   */
  export type env_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_user
     */
    select?: env_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_user
     */
    omit?: env_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_userInclude<ExtArgs> | null
    /**
     * Filter, which env_user to fetch.
     */
    where: env_userWhereUniqueInput
  }

  /**
   * env_user findFirst
   */
  export type env_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_user
     */
    select?: env_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_user
     */
    omit?: env_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_userInclude<ExtArgs> | null
    /**
     * Filter, which env_user to fetch.
     */
    where?: env_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of env_users to fetch.
     */
    orderBy?: env_userOrderByWithRelationInput | env_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for env_users.
     */
    cursor?: env_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` env_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` env_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of env_users.
     */
    distinct?: Env_userScalarFieldEnum | Env_userScalarFieldEnum[]
  }

  /**
   * env_user findFirstOrThrow
   */
  export type env_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_user
     */
    select?: env_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_user
     */
    omit?: env_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_userInclude<ExtArgs> | null
    /**
     * Filter, which env_user to fetch.
     */
    where?: env_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of env_users to fetch.
     */
    orderBy?: env_userOrderByWithRelationInput | env_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for env_users.
     */
    cursor?: env_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` env_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` env_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of env_users.
     */
    distinct?: Env_userScalarFieldEnum | Env_userScalarFieldEnum[]
  }

  /**
   * env_user findMany
   */
  export type env_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_user
     */
    select?: env_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_user
     */
    omit?: env_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_userInclude<ExtArgs> | null
    /**
     * Filter, which env_users to fetch.
     */
    where?: env_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of env_users to fetch.
     */
    orderBy?: env_userOrderByWithRelationInput | env_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing env_users.
     */
    cursor?: env_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` env_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` env_users.
     */
    skip?: number
    distinct?: Env_userScalarFieldEnum | Env_userScalarFieldEnum[]
  }

  /**
   * env_user create
   */
  export type env_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_user
     */
    select?: env_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_user
     */
    omit?: env_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_userInclude<ExtArgs> | null
    /**
     * The data needed to create a env_user.
     */
    data: XOR<env_userCreateInput, env_userUncheckedCreateInput>
  }

  /**
   * env_user createMany
   */
  export type env_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many env_users.
     */
    data: env_userCreateManyInput | env_userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * env_user createManyAndReturn
   */
  export type env_userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_user
     */
    select?: env_userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the env_user
     */
    omit?: env_userOmit<ExtArgs> | null
    /**
     * The data used to create many env_users.
     */
    data: env_userCreateManyInput | env_userCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_userIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * env_user update
   */
  export type env_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_user
     */
    select?: env_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_user
     */
    omit?: env_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_userInclude<ExtArgs> | null
    /**
     * The data needed to update a env_user.
     */
    data: XOR<env_userUpdateInput, env_userUncheckedUpdateInput>
    /**
     * Choose, which env_user to update.
     */
    where: env_userWhereUniqueInput
  }

  /**
   * env_user updateMany
   */
  export type env_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update env_users.
     */
    data: XOR<env_userUpdateManyMutationInput, env_userUncheckedUpdateManyInput>
    /**
     * Filter which env_users to update
     */
    where?: env_userWhereInput
    /**
     * Limit how many env_users to update.
     */
    limit?: number
  }

  /**
   * env_user updateManyAndReturn
   */
  export type env_userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_user
     */
    select?: env_userSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the env_user
     */
    omit?: env_userOmit<ExtArgs> | null
    /**
     * The data used to update env_users.
     */
    data: XOR<env_userUpdateManyMutationInput, env_userUncheckedUpdateManyInput>
    /**
     * Filter which env_users to update
     */
    where?: env_userWhereInput
    /**
     * Limit how many env_users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_userIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * env_user upsert
   */
  export type env_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_user
     */
    select?: env_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_user
     */
    omit?: env_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_userInclude<ExtArgs> | null
    /**
     * The filter to search for the env_user to update in case it exists.
     */
    where: env_userWhereUniqueInput
    /**
     * In case the env_user found by the `where` argument doesn't exist, create a new env_user with this data.
     */
    create: XOR<env_userCreateInput, env_userUncheckedCreateInput>
    /**
     * In case the env_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<env_userUpdateInput, env_userUncheckedUpdateInput>
  }

  /**
   * env_user delete
   */
  export type env_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_user
     */
    select?: env_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_user
     */
    omit?: env_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_userInclude<ExtArgs> | null
    /**
     * Filter which env_user to delete.
     */
    where: env_userWhereUniqueInput
  }

  /**
   * env_user deleteMany
   */
  export type env_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which env_users to delete
     */
    where?: env_userWhereInput
    /**
     * Limit how many env_users to delete.
     */
    limit?: number
  }

  /**
   * env_user.environment
   */
  export type env_user$environmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the environment
     */
    select?: environmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the environment
     */
    omit?: environmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: environmentInclude<ExtArgs> | null
    where?: environmentWhereInput
  }

  /**
   * env_user without action
   */
  export type env_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_user
     */
    select?: env_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_user
     */
    omit?: env_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_userInclude<ExtArgs> | null
  }


  /**
   * Model environment
   */

  export type AggregateEnvironment = {
    _count: EnvironmentCountAggregateOutputType | null
    _avg: EnvironmentAvgAggregateOutputType | null
    _sum: EnvironmentSumAggregateOutputType | null
    _min: EnvironmentMinAggregateOutputType | null
    _max: EnvironmentMaxAggregateOutputType | null
  }

  export type EnvironmentAvgAggregateOutputType = {
    id: number | null
    map_id: number | null
    surface: number | null
  }

  export type EnvironmentSumAggregateOutputType = {
    id: number | null
    map_id: number | null
    surface: number | null
  }

  export type EnvironmentMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    address: string | null
    created_at: Date | null
    updated_at: Date | null
    map_id: number | null
    is_public: boolean | null
    surface: number | null
  }

  export type EnvironmentMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    address: string | null
    created_at: Date | null
    updated_at: Date | null
    map_id: number | null
    is_public: boolean | null
    surface: number | null
  }

  export type EnvironmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    address: number
    created_at: number
    updated_at: number
    map_id: number
    is_public: number
    surface: number
    _all: number
  }


  export type EnvironmentAvgAggregateInputType = {
    id?: true
    map_id?: true
    surface?: true
  }

  export type EnvironmentSumAggregateInputType = {
    id?: true
    map_id?: true
    surface?: true
  }

  export type EnvironmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    address?: true
    created_at?: true
    updated_at?: true
    map_id?: true
    is_public?: true
    surface?: true
  }

  export type EnvironmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    address?: true
    created_at?: true
    updated_at?: true
    map_id?: true
    is_public?: true
    surface?: true
  }

  export type EnvironmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    address?: true
    created_at?: true
    updated_at?: true
    map_id?: true
    is_public?: true
    surface?: true
    _all?: true
  }

  export type EnvironmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which environment to aggregate.
     */
    where?: environmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of environments to fetch.
     */
    orderBy?: environmentOrderByWithRelationInput | environmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: environmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` environments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` environments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned environments
    **/
    _count?: true | EnvironmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnvironmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnvironmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnvironmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnvironmentMaxAggregateInputType
  }

  export type GetEnvironmentAggregateType<T extends EnvironmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnvironment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnvironment[P]>
      : GetScalarType<T[P], AggregateEnvironment[P]>
  }




  export type environmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: environmentWhereInput
    orderBy?: environmentOrderByWithAggregationInput | environmentOrderByWithAggregationInput[]
    by: EnvironmentScalarFieldEnum[] | EnvironmentScalarFieldEnum
    having?: environmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnvironmentCountAggregateInputType | true
    _avg?: EnvironmentAvgAggregateInputType
    _sum?: EnvironmentSumAggregateInputType
    _min?: EnvironmentMinAggregateInputType
    _max?: EnvironmentMaxAggregateInputType
  }

  export type EnvironmentGroupByOutputType = {
    id: number
    name: string
    description: string | null
    address: string | null
    created_at: Date | null
    updated_at: Date | null
    map_id: number | null
    is_public: boolean | null
    surface: number | null
    _count: EnvironmentCountAggregateOutputType | null
    _avg: EnvironmentAvgAggregateOutputType | null
    _sum: EnvironmentSumAggregateOutputType | null
    _min: EnvironmentMinAggregateOutputType | null
    _max: EnvironmentMaxAggregateOutputType | null
  }

  type GetEnvironmentGroupByPayload<T extends environmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnvironmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnvironmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnvironmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnvironmentGroupByOutputType[P]>
        }
      >
    >


  export type environmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    address?: boolean
    created_at?: boolean
    updated_at?: boolean
    map_id?: boolean
    is_public?: boolean
    surface?: boolean
    env_delimiter?: boolean | environment$env_delimiterArgs<ExtArgs>
    env_user?: boolean | environment$env_userArgs<ExtArgs>
    map?: boolean | environment$mapArgs<ExtArgs>
    poi?: boolean | environment$poiArgs<ExtArgs>
    zone?: boolean | environment$zoneArgs<ExtArgs>
    _count?: boolean | EnvironmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["environment"]>

  export type environmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    address?: boolean
    created_at?: boolean
    updated_at?: boolean
    map_id?: boolean
    is_public?: boolean
    surface?: boolean
    map?: boolean | environment$mapArgs<ExtArgs>
  }, ExtArgs["result"]["environment"]>

  export type environmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    address?: boolean
    created_at?: boolean
    updated_at?: boolean
    map_id?: boolean
    is_public?: boolean
    surface?: boolean
    map?: boolean | environment$mapArgs<ExtArgs>
  }, ExtArgs["result"]["environment"]>

  export type environmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    address?: boolean
    created_at?: boolean
    updated_at?: boolean
    map_id?: boolean
    is_public?: boolean
    surface?: boolean
  }

  export type environmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "address" | "created_at" | "updated_at" | "map_id" | "is_public" | "surface", ExtArgs["result"]["environment"]>
  export type environmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    env_delimiter?: boolean | environment$env_delimiterArgs<ExtArgs>
    env_user?: boolean | environment$env_userArgs<ExtArgs>
    map?: boolean | environment$mapArgs<ExtArgs>
    poi?: boolean | environment$poiArgs<ExtArgs>
    zone?: boolean | environment$zoneArgs<ExtArgs>
    _count?: boolean | EnvironmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type environmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    map?: boolean | environment$mapArgs<ExtArgs>
  }
  export type environmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    map?: boolean | environment$mapArgs<ExtArgs>
  }

  export type $environmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "environment"
    objects: {
      env_delimiter: Prisma.$env_delimiterPayload<ExtArgs>[]
      env_user: Prisma.$env_userPayload<ExtArgs>[]
      map: Prisma.$mapPayload<ExtArgs> | null
      poi: Prisma.$poiPayload<ExtArgs>[]
      zone: Prisma.$zonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      address: string | null
      created_at: Date | null
      updated_at: Date | null
      map_id: number | null
      is_public: boolean | null
      surface: number | null
    }, ExtArgs["result"]["environment"]>
    composites: {}
  }

  type environmentGetPayload<S extends boolean | null | undefined | environmentDefaultArgs> = $Result.GetResult<Prisma.$environmentPayload, S>

  type environmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<environmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnvironmentCountAggregateInputType | true
    }

  export interface environmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['environment'], meta: { name: 'environment' } }
    /**
     * Find zero or one Environment that matches the filter.
     * @param {environmentFindUniqueArgs} args - Arguments to find a Environment
     * @example
     * // Get one Environment
     * const environment = await prisma.environment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends environmentFindUniqueArgs>(args: SelectSubset<T, environmentFindUniqueArgs<ExtArgs>>): Prisma__environmentClient<$Result.GetResult<Prisma.$environmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Environment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {environmentFindUniqueOrThrowArgs} args - Arguments to find a Environment
     * @example
     * // Get one Environment
     * const environment = await prisma.environment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends environmentFindUniqueOrThrowArgs>(args: SelectSubset<T, environmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__environmentClient<$Result.GetResult<Prisma.$environmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Environment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {environmentFindFirstArgs} args - Arguments to find a Environment
     * @example
     * // Get one Environment
     * const environment = await prisma.environment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends environmentFindFirstArgs>(args?: SelectSubset<T, environmentFindFirstArgs<ExtArgs>>): Prisma__environmentClient<$Result.GetResult<Prisma.$environmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Environment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {environmentFindFirstOrThrowArgs} args - Arguments to find a Environment
     * @example
     * // Get one Environment
     * const environment = await prisma.environment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends environmentFindFirstOrThrowArgs>(args?: SelectSubset<T, environmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__environmentClient<$Result.GetResult<Prisma.$environmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Environments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {environmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Environments
     * const environments = await prisma.environment.findMany()
     * 
     * // Get first 10 Environments
     * const environments = await prisma.environment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const environmentWithIdOnly = await prisma.environment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends environmentFindManyArgs>(args?: SelectSubset<T, environmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$environmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Environment.
     * @param {environmentCreateArgs} args - Arguments to create a Environment.
     * @example
     * // Create one Environment
     * const Environment = await prisma.environment.create({
     *   data: {
     *     // ... data to create a Environment
     *   }
     * })
     * 
     */
    create<T extends environmentCreateArgs>(args: SelectSubset<T, environmentCreateArgs<ExtArgs>>): Prisma__environmentClient<$Result.GetResult<Prisma.$environmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Environments.
     * @param {environmentCreateManyArgs} args - Arguments to create many Environments.
     * @example
     * // Create many Environments
     * const environment = await prisma.environment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends environmentCreateManyArgs>(args?: SelectSubset<T, environmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Environments and returns the data saved in the database.
     * @param {environmentCreateManyAndReturnArgs} args - Arguments to create many Environments.
     * @example
     * // Create many Environments
     * const environment = await prisma.environment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Environments and only return the `id`
     * const environmentWithIdOnly = await prisma.environment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends environmentCreateManyAndReturnArgs>(args?: SelectSubset<T, environmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$environmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Environment.
     * @param {environmentDeleteArgs} args - Arguments to delete one Environment.
     * @example
     * // Delete one Environment
     * const Environment = await prisma.environment.delete({
     *   where: {
     *     // ... filter to delete one Environment
     *   }
     * })
     * 
     */
    delete<T extends environmentDeleteArgs>(args: SelectSubset<T, environmentDeleteArgs<ExtArgs>>): Prisma__environmentClient<$Result.GetResult<Prisma.$environmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Environment.
     * @param {environmentUpdateArgs} args - Arguments to update one Environment.
     * @example
     * // Update one Environment
     * const environment = await prisma.environment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends environmentUpdateArgs>(args: SelectSubset<T, environmentUpdateArgs<ExtArgs>>): Prisma__environmentClient<$Result.GetResult<Prisma.$environmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Environments.
     * @param {environmentDeleteManyArgs} args - Arguments to filter Environments to delete.
     * @example
     * // Delete a few Environments
     * const { count } = await prisma.environment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends environmentDeleteManyArgs>(args?: SelectSubset<T, environmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Environments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {environmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Environments
     * const environment = await prisma.environment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends environmentUpdateManyArgs>(args: SelectSubset<T, environmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Environments and returns the data updated in the database.
     * @param {environmentUpdateManyAndReturnArgs} args - Arguments to update many Environments.
     * @example
     * // Update many Environments
     * const environment = await prisma.environment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Environments and only return the `id`
     * const environmentWithIdOnly = await prisma.environment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends environmentUpdateManyAndReturnArgs>(args: SelectSubset<T, environmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$environmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Environment.
     * @param {environmentUpsertArgs} args - Arguments to update or create a Environment.
     * @example
     * // Update or create a Environment
     * const environment = await prisma.environment.upsert({
     *   create: {
     *     // ... data to create a Environment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Environment we want to update
     *   }
     * })
     */
    upsert<T extends environmentUpsertArgs>(args: SelectSubset<T, environmentUpsertArgs<ExtArgs>>): Prisma__environmentClient<$Result.GetResult<Prisma.$environmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Environments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {environmentCountArgs} args - Arguments to filter Environments to count.
     * @example
     * // Count the number of Environments
     * const count = await prisma.environment.count({
     *   where: {
     *     // ... the filter for the Environments we want to count
     *   }
     * })
    **/
    count<T extends environmentCountArgs>(
      args?: Subset<T, environmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnvironmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Environment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnvironmentAggregateArgs>(args: Subset<T, EnvironmentAggregateArgs>): Prisma.PrismaPromise<GetEnvironmentAggregateType<T>>

    /**
     * Group by Environment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {environmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends environmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: environmentGroupByArgs['orderBy'] }
        : { orderBy?: environmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, environmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnvironmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the environment model
   */
  readonly fields: environmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for environment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__environmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    env_delimiter<T extends environment$env_delimiterArgs<ExtArgs> = {}>(args?: Subset<T, environment$env_delimiterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$env_delimiterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    env_user<T extends environment$env_userArgs<ExtArgs> = {}>(args?: Subset<T, environment$env_userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$env_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    map<T extends environment$mapArgs<ExtArgs> = {}>(args?: Subset<T, environment$mapArgs<ExtArgs>>): Prisma__mapClient<$Result.GetResult<Prisma.$mapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    poi<T extends environment$poiArgs<ExtArgs> = {}>(args?: Subset<T, environment$poiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zone<T extends environment$zoneArgs<ExtArgs> = {}>(args?: Subset<T, environment$zoneArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the environment model
   */
  interface environmentFieldRefs {
    readonly id: FieldRef<"environment", 'Int'>
    readonly name: FieldRef<"environment", 'String'>
    readonly description: FieldRef<"environment", 'String'>
    readonly address: FieldRef<"environment", 'String'>
    readonly created_at: FieldRef<"environment", 'DateTime'>
    readonly updated_at: FieldRef<"environment", 'DateTime'>
    readonly map_id: FieldRef<"environment", 'Int'>
    readonly is_public: FieldRef<"environment", 'Boolean'>
    readonly surface: FieldRef<"environment", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * environment findUnique
   */
  export type environmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the environment
     */
    select?: environmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the environment
     */
    omit?: environmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: environmentInclude<ExtArgs> | null
    /**
     * Filter, which environment to fetch.
     */
    where: environmentWhereUniqueInput
  }

  /**
   * environment findUniqueOrThrow
   */
  export type environmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the environment
     */
    select?: environmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the environment
     */
    omit?: environmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: environmentInclude<ExtArgs> | null
    /**
     * Filter, which environment to fetch.
     */
    where: environmentWhereUniqueInput
  }

  /**
   * environment findFirst
   */
  export type environmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the environment
     */
    select?: environmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the environment
     */
    omit?: environmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: environmentInclude<ExtArgs> | null
    /**
     * Filter, which environment to fetch.
     */
    where?: environmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of environments to fetch.
     */
    orderBy?: environmentOrderByWithRelationInput | environmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for environments.
     */
    cursor?: environmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` environments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` environments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of environments.
     */
    distinct?: EnvironmentScalarFieldEnum | EnvironmentScalarFieldEnum[]
  }

  /**
   * environment findFirstOrThrow
   */
  export type environmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the environment
     */
    select?: environmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the environment
     */
    omit?: environmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: environmentInclude<ExtArgs> | null
    /**
     * Filter, which environment to fetch.
     */
    where?: environmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of environments to fetch.
     */
    orderBy?: environmentOrderByWithRelationInput | environmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for environments.
     */
    cursor?: environmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` environments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` environments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of environments.
     */
    distinct?: EnvironmentScalarFieldEnum | EnvironmentScalarFieldEnum[]
  }

  /**
   * environment findMany
   */
  export type environmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the environment
     */
    select?: environmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the environment
     */
    omit?: environmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: environmentInclude<ExtArgs> | null
    /**
     * Filter, which environments to fetch.
     */
    where?: environmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of environments to fetch.
     */
    orderBy?: environmentOrderByWithRelationInput | environmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing environments.
     */
    cursor?: environmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` environments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` environments.
     */
    skip?: number
    distinct?: EnvironmentScalarFieldEnum | EnvironmentScalarFieldEnum[]
  }

  /**
   * environment create
   */
  export type environmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the environment
     */
    select?: environmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the environment
     */
    omit?: environmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: environmentInclude<ExtArgs> | null
    /**
     * The data needed to create a environment.
     */
    data: XOR<environmentCreateInput, environmentUncheckedCreateInput>
  }

  /**
   * environment createMany
   */
  export type environmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many environments.
     */
    data: environmentCreateManyInput | environmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * environment createManyAndReturn
   */
  export type environmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the environment
     */
    select?: environmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the environment
     */
    omit?: environmentOmit<ExtArgs> | null
    /**
     * The data used to create many environments.
     */
    data: environmentCreateManyInput | environmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: environmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * environment update
   */
  export type environmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the environment
     */
    select?: environmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the environment
     */
    omit?: environmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: environmentInclude<ExtArgs> | null
    /**
     * The data needed to update a environment.
     */
    data: XOR<environmentUpdateInput, environmentUncheckedUpdateInput>
    /**
     * Choose, which environment to update.
     */
    where: environmentWhereUniqueInput
  }

  /**
   * environment updateMany
   */
  export type environmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update environments.
     */
    data: XOR<environmentUpdateManyMutationInput, environmentUncheckedUpdateManyInput>
    /**
     * Filter which environments to update
     */
    where?: environmentWhereInput
    /**
     * Limit how many environments to update.
     */
    limit?: number
  }

  /**
   * environment updateManyAndReturn
   */
  export type environmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the environment
     */
    select?: environmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the environment
     */
    omit?: environmentOmit<ExtArgs> | null
    /**
     * The data used to update environments.
     */
    data: XOR<environmentUpdateManyMutationInput, environmentUncheckedUpdateManyInput>
    /**
     * Filter which environments to update
     */
    where?: environmentWhereInput
    /**
     * Limit how many environments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: environmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * environment upsert
   */
  export type environmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the environment
     */
    select?: environmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the environment
     */
    omit?: environmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: environmentInclude<ExtArgs> | null
    /**
     * The filter to search for the environment to update in case it exists.
     */
    where: environmentWhereUniqueInput
    /**
     * In case the environment found by the `where` argument doesn't exist, create a new environment with this data.
     */
    create: XOR<environmentCreateInput, environmentUncheckedCreateInput>
    /**
     * In case the environment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<environmentUpdateInput, environmentUncheckedUpdateInput>
  }

  /**
   * environment delete
   */
  export type environmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the environment
     */
    select?: environmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the environment
     */
    omit?: environmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: environmentInclude<ExtArgs> | null
    /**
     * Filter which environment to delete.
     */
    where: environmentWhereUniqueInput
  }

  /**
   * environment deleteMany
   */
  export type environmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which environments to delete
     */
    where?: environmentWhereInput
    /**
     * Limit how many environments to delete.
     */
    limit?: number
  }

  /**
   * environment.env_delimiter
   */
  export type environment$env_delimiterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_delimiter
     */
    select?: env_delimiterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_delimiter
     */
    omit?: env_delimiterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_delimiterInclude<ExtArgs> | null
    where?: env_delimiterWhereInput
    orderBy?: env_delimiterOrderByWithRelationInput | env_delimiterOrderByWithRelationInput[]
    cursor?: env_delimiterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Env_delimiterScalarFieldEnum | Env_delimiterScalarFieldEnum[]
  }

  /**
   * environment.env_user
   */
  export type environment$env_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_user
     */
    select?: env_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_user
     */
    omit?: env_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_userInclude<ExtArgs> | null
    where?: env_userWhereInput
    orderBy?: env_userOrderByWithRelationInput | env_userOrderByWithRelationInput[]
    cursor?: env_userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Env_userScalarFieldEnum | Env_userScalarFieldEnum[]
  }

  /**
   * environment.map
   */
  export type environment$mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the map
     */
    select?: mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the map
     */
    omit?: mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mapInclude<ExtArgs> | null
    where?: mapWhereInput
  }

  /**
   * environment.poi
   */
  export type environment$poiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi
     */
    select?: poiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi
     */
    omit?: poiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poiInclude<ExtArgs> | null
    where?: poiWhereInput
    orderBy?: poiOrderByWithRelationInput | poiOrderByWithRelationInput[]
    cursor?: poiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PoiScalarFieldEnum | PoiScalarFieldEnum[]
  }

  /**
   * environment.zone
   */
  export type environment$zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    where?: zoneWhereInput
    orderBy?: zoneOrderByWithRelationInput | zoneOrderByWithRelationInput[]
    cursor?: zoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * environment without action
   */
  export type environmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the environment
     */
    select?: environmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the environment
     */
    omit?: environmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: environmentInclude<ExtArgs> | null
  }


  /**
   * Model expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    id: number | null
    amount: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    id: bigint | null
    amount: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: bigint | null
    created_at: Date | null
    label: string | null
    amount: number | null
    category: $Enums.ExpenseCategory | null
    description: string | null
    date: Date | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: bigint | null
    created_at: Date | null
    label: string | null
    amount: number | null
    category: $Enums.ExpenseCategory | null
    description: string | null
    date: Date | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    created_at: number
    label: number
    amount: number
    category: number
    description: number
    date: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    id?: true
    amount?: true
  }

  export type ExpenseSumAggregateInputType = {
    id?: true
    amount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    created_at?: true
    label?: true
    amount?: true
    category?: true
    description?: true
    date?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    created_at?: true
    label?: true
    amount?: true
    category?: true
    description?: true
    date?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    created_at?: true
    label?: true
    amount?: true
    category?: true
    description?: true
    date?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which expense to aggregate.
     */
    where?: expenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of expenses to fetch.
     */
    orderBy?: expenseOrderByWithRelationInput | expenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: expenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type expenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: expenseWhereInput
    orderBy?: expenseOrderByWithAggregationInput | expenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: expenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: bigint
    created_at: Date
    label: string | null
    amount: number
    category: $Enums.ExpenseCategory | null
    description: string | null
    date: Date | null
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends expenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type expenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    label?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    date?: boolean
  }, ExtArgs["result"]["expense"]>

  export type expenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    label?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    date?: boolean
  }, ExtArgs["result"]["expense"]>

  export type expenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    label?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    date?: boolean
  }, ExtArgs["result"]["expense"]>

  export type expenseSelectScalar = {
    id?: boolean
    created_at?: boolean
    label?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    date?: boolean
  }

  export type expenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "label" | "amount" | "category" | "description" | "date", ExtArgs["result"]["expense"]>

  export type $expensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "expense"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      created_at: Date
      label: string | null
      amount: number
      category: $Enums.ExpenseCategory | null
      description: string | null
      date: Date | null
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type expenseGetPayload<S extends boolean | null | undefined | expenseDefaultArgs> = $Result.GetResult<Prisma.$expensePayload, S>

  type expenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<expenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface expenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['expense'], meta: { name: 'expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {expenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends expenseFindUniqueArgs>(args: SelectSubset<T, expenseFindUniqueArgs<ExtArgs>>): Prisma__expenseClient<$Result.GetResult<Prisma.$expensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {expenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends expenseFindUniqueOrThrowArgs>(args: SelectSubset<T, expenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__expenseClient<$Result.GetResult<Prisma.$expensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {expenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends expenseFindFirstArgs>(args?: SelectSubset<T, expenseFindFirstArgs<ExtArgs>>): Prisma__expenseClient<$Result.GetResult<Prisma.$expensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {expenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends expenseFindFirstOrThrowArgs>(args?: SelectSubset<T, expenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__expenseClient<$Result.GetResult<Prisma.$expensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {expenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends expenseFindManyArgs>(args?: SelectSubset<T, expenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$expensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expense.
     * @param {expenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends expenseCreateArgs>(args: SelectSubset<T, expenseCreateArgs<ExtArgs>>): Prisma__expenseClient<$Result.GetResult<Prisma.$expensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {expenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends expenseCreateManyArgs>(args?: SelectSubset<T, expenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {expenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends expenseCreateManyAndReturnArgs>(args?: SelectSubset<T, expenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$expensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Expense.
     * @param {expenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends expenseDeleteArgs>(args: SelectSubset<T, expenseDeleteArgs<ExtArgs>>): Prisma__expenseClient<$Result.GetResult<Prisma.$expensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expense.
     * @param {expenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends expenseUpdateArgs>(args: SelectSubset<T, expenseUpdateArgs<ExtArgs>>): Prisma__expenseClient<$Result.GetResult<Prisma.$expensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {expenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends expenseDeleteManyArgs>(args?: SelectSubset<T, expenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {expenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends expenseUpdateManyArgs>(args: SelectSubset<T, expenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses and returns the data updated in the database.
     * @param {expenseUpdateManyAndReturnArgs} args - Arguments to update many Expenses.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends expenseUpdateManyAndReturnArgs>(args: SelectSubset<T, expenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$expensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Expense.
     * @param {expenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends expenseUpsertArgs>(args: SelectSubset<T, expenseUpsertArgs<ExtArgs>>): Prisma__expenseClient<$Result.GetResult<Prisma.$expensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {expenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends expenseCountArgs>(
      args?: Subset<T, expenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {expenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends expenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: expenseGroupByArgs['orderBy'] }
        : { orderBy?: expenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, expenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the expense model
   */
  readonly fields: expenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__expenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the expense model
   */
  interface expenseFieldRefs {
    readonly id: FieldRef<"expense", 'BigInt'>
    readonly created_at: FieldRef<"expense", 'DateTime'>
    readonly label: FieldRef<"expense", 'String'>
    readonly amount: FieldRef<"expense", 'Float'>
    readonly category: FieldRef<"expense", 'ExpenseCategory'>
    readonly description: FieldRef<"expense", 'String'>
    readonly date: FieldRef<"expense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * expense findUnique
   */
  export type expenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expense
     */
    select?: expenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the expense
     */
    omit?: expenseOmit<ExtArgs> | null
    /**
     * Filter, which expense to fetch.
     */
    where: expenseWhereUniqueInput
  }

  /**
   * expense findUniqueOrThrow
   */
  export type expenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expense
     */
    select?: expenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the expense
     */
    omit?: expenseOmit<ExtArgs> | null
    /**
     * Filter, which expense to fetch.
     */
    where: expenseWhereUniqueInput
  }

  /**
   * expense findFirst
   */
  export type expenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expense
     */
    select?: expenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the expense
     */
    omit?: expenseOmit<ExtArgs> | null
    /**
     * Filter, which expense to fetch.
     */
    where?: expenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of expenses to fetch.
     */
    orderBy?: expenseOrderByWithRelationInput | expenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for expenses.
     */
    cursor?: expenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * expense findFirstOrThrow
   */
  export type expenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expense
     */
    select?: expenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the expense
     */
    omit?: expenseOmit<ExtArgs> | null
    /**
     * Filter, which expense to fetch.
     */
    where?: expenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of expenses to fetch.
     */
    orderBy?: expenseOrderByWithRelationInput | expenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for expenses.
     */
    cursor?: expenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * expense findMany
   */
  export type expenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expense
     */
    select?: expenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the expense
     */
    omit?: expenseOmit<ExtArgs> | null
    /**
     * Filter, which expenses to fetch.
     */
    where?: expenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of expenses to fetch.
     */
    orderBy?: expenseOrderByWithRelationInput | expenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing expenses.
     */
    cursor?: expenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * expense create
   */
  export type expenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expense
     */
    select?: expenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the expense
     */
    omit?: expenseOmit<ExtArgs> | null
    /**
     * The data needed to create a expense.
     */
    data?: XOR<expenseCreateInput, expenseUncheckedCreateInput>
  }

  /**
   * expense createMany
   */
  export type expenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many expenses.
     */
    data: expenseCreateManyInput | expenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * expense createManyAndReturn
   */
  export type expenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expense
     */
    select?: expenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the expense
     */
    omit?: expenseOmit<ExtArgs> | null
    /**
     * The data used to create many expenses.
     */
    data: expenseCreateManyInput | expenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * expense update
   */
  export type expenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expense
     */
    select?: expenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the expense
     */
    omit?: expenseOmit<ExtArgs> | null
    /**
     * The data needed to update a expense.
     */
    data: XOR<expenseUpdateInput, expenseUncheckedUpdateInput>
    /**
     * Choose, which expense to update.
     */
    where: expenseWhereUniqueInput
  }

  /**
   * expense updateMany
   */
  export type expenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update expenses.
     */
    data: XOR<expenseUpdateManyMutationInput, expenseUncheckedUpdateManyInput>
    /**
     * Filter which expenses to update
     */
    where?: expenseWhereInput
    /**
     * Limit how many expenses to update.
     */
    limit?: number
  }

  /**
   * expense updateManyAndReturn
   */
  export type expenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expense
     */
    select?: expenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the expense
     */
    omit?: expenseOmit<ExtArgs> | null
    /**
     * The data used to update expenses.
     */
    data: XOR<expenseUpdateManyMutationInput, expenseUncheckedUpdateManyInput>
    /**
     * Filter which expenses to update
     */
    where?: expenseWhereInput
    /**
     * Limit how many expenses to update.
     */
    limit?: number
  }

  /**
   * expense upsert
   */
  export type expenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expense
     */
    select?: expenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the expense
     */
    omit?: expenseOmit<ExtArgs> | null
    /**
     * The filter to search for the expense to update in case it exists.
     */
    where: expenseWhereUniqueInput
    /**
     * In case the expense found by the `where` argument doesn't exist, create a new expense with this data.
     */
    create: XOR<expenseCreateInput, expenseUncheckedCreateInput>
    /**
     * In case the expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<expenseUpdateInput, expenseUncheckedUpdateInput>
  }

  /**
   * expense delete
   */
  export type expenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expense
     */
    select?: expenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the expense
     */
    omit?: expenseOmit<ExtArgs> | null
    /**
     * Filter which expense to delete.
     */
    where: expenseWhereUniqueInput
  }

  /**
   * expense deleteMany
   */
  export type expenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which expenses to delete
     */
    where?: expenseWhereInput
    /**
     * Limit how many expenses to delete.
     */
    limit?: number
  }

  /**
   * expense without action
   */
  export type expenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expense
     */
    select?: expenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the expense
     */
    omit?: expenseOmit<ExtArgs> | null
  }


  /**
   * Model format
   */

  export type AggregateFormat = {
    _count: FormatCountAggregateOutputType | null
    _avg: FormatAvgAggregateOutputType | null
    _sum: FormatSumAggregateOutputType | null
    _min: FormatMinAggregateOutputType | null
    _max: FormatMaxAggregateOutputType | null
  }

  export type FormatAvgAggregateOutputType = {
    id: number | null
  }

  export type FormatSumAggregateOutputType = {
    id: number | null
  }

  export type FormatMinAggregateOutputType = {
    id: number | null
    format: string | null
  }

  export type FormatMaxAggregateOutputType = {
    id: number | null
    format: string | null
  }

  export type FormatCountAggregateOutputType = {
    id: number
    format: number
    _all: number
  }


  export type FormatAvgAggregateInputType = {
    id?: true
  }

  export type FormatSumAggregateInputType = {
    id?: true
  }

  export type FormatMinAggregateInputType = {
    id?: true
    format?: true
  }

  export type FormatMaxAggregateInputType = {
    id?: true
    format?: true
  }

  export type FormatCountAggregateInputType = {
    id?: true
    format?: true
    _all?: true
  }

  export type FormatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which format to aggregate.
     */
    where?: formatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formats to fetch.
     */
    orderBy?: formatOrderByWithRelationInput | formatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: formatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned formats
    **/
    _count?: true | FormatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormatMaxAggregateInputType
  }

  export type GetFormatAggregateType<T extends FormatAggregateArgs> = {
        [P in keyof T & keyof AggregateFormat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormat[P]>
      : GetScalarType<T[P], AggregateFormat[P]>
  }




  export type formatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formatWhereInput
    orderBy?: formatOrderByWithAggregationInput | formatOrderByWithAggregationInput[]
    by: FormatScalarFieldEnum[] | FormatScalarFieldEnum
    having?: formatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormatCountAggregateInputType | true
    _avg?: FormatAvgAggregateInputType
    _sum?: FormatSumAggregateInputType
    _min?: FormatMinAggregateInputType
    _max?: FormatMaxAggregateInputType
  }

  export type FormatGroupByOutputType = {
    id: number
    format: string
    _count: FormatCountAggregateOutputType | null
    _avg: FormatAvgAggregateOutputType | null
    _sum: FormatSumAggregateOutputType | null
    _min: FormatMinAggregateOutputType | null
    _max: FormatMaxAggregateOutputType | null
  }

  type GetFormatGroupByPayload<T extends formatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormatGroupByOutputType[P]>
            : GetScalarType<T[P], FormatGroupByOutputType[P]>
        }
      >
    >


  export type formatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    format?: boolean
    map?: boolean | format$mapArgs<ExtArgs>
    _count?: boolean | FormatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["format"]>

  export type formatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    format?: boolean
  }, ExtArgs["result"]["format"]>

  export type formatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    format?: boolean
  }, ExtArgs["result"]["format"]>

  export type formatSelectScalar = {
    id?: boolean
    format?: boolean
  }

  export type formatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "format", ExtArgs["result"]["format"]>
  export type formatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    map?: boolean | format$mapArgs<ExtArgs>
    _count?: boolean | FormatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type formatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type formatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $formatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "format"
    objects: {
      map: Prisma.$mapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      format: string
    }, ExtArgs["result"]["format"]>
    composites: {}
  }

  type formatGetPayload<S extends boolean | null | undefined | formatDefaultArgs> = $Result.GetResult<Prisma.$formatPayload, S>

  type formatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<formatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormatCountAggregateInputType | true
    }

  export interface formatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['format'], meta: { name: 'format' } }
    /**
     * Find zero or one Format that matches the filter.
     * @param {formatFindUniqueArgs} args - Arguments to find a Format
     * @example
     * // Get one Format
     * const format = await prisma.format.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends formatFindUniqueArgs>(args: SelectSubset<T, formatFindUniqueArgs<ExtArgs>>): Prisma__formatClient<$Result.GetResult<Prisma.$formatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Format that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {formatFindUniqueOrThrowArgs} args - Arguments to find a Format
     * @example
     * // Get one Format
     * const format = await prisma.format.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends formatFindUniqueOrThrowArgs>(args: SelectSubset<T, formatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__formatClient<$Result.GetResult<Prisma.$formatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Format that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formatFindFirstArgs} args - Arguments to find a Format
     * @example
     * // Get one Format
     * const format = await prisma.format.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends formatFindFirstArgs>(args?: SelectSubset<T, formatFindFirstArgs<ExtArgs>>): Prisma__formatClient<$Result.GetResult<Prisma.$formatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Format that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formatFindFirstOrThrowArgs} args - Arguments to find a Format
     * @example
     * // Get one Format
     * const format = await prisma.format.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends formatFindFirstOrThrowArgs>(args?: SelectSubset<T, formatFindFirstOrThrowArgs<ExtArgs>>): Prisma__formatClient<$Result.GetResult<Prisma.$formatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Formats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Formats
     * const formats = await prisma.format.findMany()
     * 
     * // Get first 10 Formats
     * const formats = await prisma.format.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formatWithIdOnly = await prisma.format.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends formatFindManyArgs>(args?: SelectSubset<T, formatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Format.
     * @param {formatCreateArgs} args - Arguments to create a Format.
     * @example
     * // Create one Format
     * const Format = await prisma.format.create({
     *   data: {
     *     // ... data to create a Format
     *   }
     * })
     * 
     */
    create<T extends formatCreateArgs>(args: SelectSubset<T, formatCreateArgs<ExtArgs>>): Prisma__formatClient<$Result.GetResult<Prisma.$formatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Formats.
     * @param {formatCreateManyArgs} args - Arguments to create many Formats.
     * @example
     * // Create many Formats
     * const format = await prisma.format.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends formatCreateManyArgs>(args?: SelectSubset<T, formatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Formats and returns the data saved in the database.
     * @param {formatCreateManyAndReturnArgs} args - Arguments to create many Formats.
     * @example
     * // Create many Formats
     * const format = await prisma.format.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Formats and only return the `id`
     * const formatWithIdOnly = await prisma.format.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends formatCreateManyAndReturnArgs>(args?: SelectSubset<T, formatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Format.
     * @param {formatDeleteArgs} args - Arguments to delete one Format.
     * @example
     * // Delete one Format
     * const Format = await prisma.format.delete({
     *   where: {
     *     // ... filter to delete one Format
     *   }
     * })
     * 
     */
    delete<T extends formatDeleteArgs>(args: SelectSubset<T, formatDeleteArgs<ExtArgs>>): Prisma__formatClient<$Result.GetResult<Prisma.$formatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Format.
     * @param {formatUpdateArgs} args - Arguments to update one Format.
     * @example
     * // Update one Format
     * const format = await prisma.format.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends formatUpdateArgs>(args: SelectSubset<T, formatUpdateArgs<ExtArgs>>): Prisma__formatClient<$Result.GetResult<Prisma.$formatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Formats.
     * @param {formatDeleteManyArgs} args - Arguments to filter Formats to delete.
     * @example
     * // Delete a few Formats
     * const { count } = await prisma.format.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends formatDeleteManyArgs>(args?: SelectSubset<T, formatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Formats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Formats
     * const format = await prisma.format.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends formatUpdateManyArgs>(args: SelectSubset<T, formatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Formats and returns the data updated in the database.
     * @param {formatUpdateManyAndReturnArgs} args - Arguments to update many Formats.
     * @example
     * // Update many Formats
     * const format = await prisma.format.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Formats and only return the `id`
     * const formatWithIdOnly = await prisma.format.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends formatUpdateManyAndReturnArgs>(args: SelectSubset<T, formatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Format.
     * @param {formatUpsertArgs} args - Arguments to update or create a Format.
     * @example
     * // Update or create a Format
     * const format = await prisma.format.upsert({
     *   create: {
     *     // ... data to create a Format
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Format we want to update
     *   }
     * })
     */
    upsert<T extends formatUpsertArgs>(args: SelectSubset<T, formatUpsertArgs<ExtArgs>>): Prisma__formatClient<$Result.GetResult<Prisma.$formatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Formats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formatCountArgs} args - Arguments to filter Formats to count.
     * @example
     * // Count the number of Formats
     * const count = await prisma.format.count({
     *   where: {
     *     // ... the filter for the Formats we want to count
     *   }
     * })
    **/
    count<T extends formatCountArgs>(
      args?: Subset<T, formatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Format.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormatAggregateArgs>(args: Subset<T, FormatAggregateArgs>): Prisma.PrismaPromise<GetFormatAggregateType<T>>

    /**
     * Group by Format.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends formatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: formatGroupByArgs['orderBy'] }
        : { orderBy?: formatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, formatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the format model
   */
  readonly fields: formatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for format.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__formatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    map<T extends format$mapArgs<ExtArgs> = {}>(args?: Subset<T, format$mapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the format model
   */
  interface formatFieldRefs {
    readonly id: FieldRef<"format", 'Int'>
    readonly format: FieldRef<"format", 'String'>
  }
    

  // Custom InputTypes
  /**
   * format findUnique
   */
  export type formatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the format
     */
    select?: formatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the format
     */
    omit?: formatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formatInclude<ExtArgs> | null
    /**
     * Filter, which format to fetch.
     */
    where: formatWhereUniqueInput
  }

  /**
   * format findUniqueOrThrow
   */
  export type formatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the format
     */
    select?: formatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the format
     */
    omit?: formatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formatInclude<ExtArgs> | null
    /**
     * Filter, which format to fetch.
     */
    where: formatWhereUniqueInput
  }

  /**
   * format findFirst
   */
  export type formatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the format
     */
    select?: formatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the format
     */
    omit?: formatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formatInclude<ExtArgs> | null
    /**
     * Filter, which format to fetch.
     */
    where?: formatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formats to fetch.
     */
    orderBy?: formatOrderByWithRelationInput | formatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formats.
     */
    cursor?: formatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formats.
     */
    distinct?: FormatScalarFieldEnum | FormatScalarFieldEnum[]
  }

  /**
   * format findFirstOrThrow
   */
  export type formatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the format
     */
    select?: formatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the format
     */
    omit?: formatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formatInclude<ExtArgs> | null
    /**
     * Filter, which format to fetch.
     */
    where?: formatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formats to fetch.
     */
    orderBy?: formatOrderByWithRelationInput | formatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formats.
     */
    cursor?: formatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formats.
     */
    distinct?: FormatScalarFieldEnum | FormatScalarFieldEnum[]
  }

  /**
   * format findMany
   */
  export type formatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the format
     */
    select?: formatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the format
     */
    omit?: formatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formatInclude<ExtArgs> | null
    /**
     * Filter, which formats to fetch.
     */
    where?: formatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formats to fetch.
     */
    orderBy?: formatOrderByWithRelationInput | formatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing formats.
     */
    cursor?: formatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formats.
     */
    skip?: number
    distinct?: FormatScalarFieldEnum | FormatScalarFieldEnum[]
  }

  /**
   * format create
   */
  export type formatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the format
     */
    select?: formatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the format
     */
    omit?: formatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formatInclude<ExtArgs> | null
    /**
     * The data needed to create a format.
     */
    data: XOR<formatCreateInput, formatUncheckedCreateInput>
  }

  /**
   * format createMany
   */
  export type formatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many formats.
     */
    data: formatCreateManyInput | formatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * format createManyAndReturn
   */
  export type formatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the format
     */
    select?: formatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the format
     */
    omit?: formatOmit<ExtArgs> | null
    /**
     * The data used to create many formats.
     */
    data: formatCreateManyInput | formatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * format update
   */
  export type formatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the format
     */
    select?: formatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the format
     */
    omit?: formatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formatInclude<ExtArgs> | null
    /**
     * The data needed to update a format.
     */
    data: XOR<formatUpdateInput, formatUncheckedUpdateInput>
    /**
     * Choose, which format to update.
     */
    where: formatWhereUniqueInput
  }

  /**
   * format updateMany
   */
  export type formatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update formats.
     */
    data: XOR<formatUpdateManyMutationInput, formatUncheckedUpdateManyInput>
    /**
     * Filter which formats to update
     */
    where?: formatWhereInput
    /**
     * Limit how many formats to update.
     */
    limit?: number
  }

  /**
   * format updateManyAndReturn
   */
  export type formatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the format
     */
    select?: formatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the format
     */
    omit?: formatOmit<ExtArgs> | null
    /**
     * The data used to update formats.
     */
    data: XOR<formatUpdateManyMutationInput, formatUncheckedUpdateManyInput>
    /**
     * Filter which formats to update
     */
    where?: formatWhereInput
    /**
     * Limit how many formats to update.
     */
    limit?: number
  }

  /**
   * format upsert
   */
  export type formatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the format
     */
    select?: formatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the format
     */
    omit?: formatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formatInclude<ExtArgs> | null
    /**
     * The filter to search for the format to update in case it exists.
     */
    where: formatWhereUniqueInput
    /**
     * In case the format found by the `where` argument doesn't exist, create a new format with this data.
     */
    create: XOR<formatCreateInput, formatUncheckedCreateInput>
    /**
     * In case the format was found with the provided `where` argument, update it with this data.
     */
    update: XOR<formatUpdateInput, formatUncheckedUpdateInput>
  }

  /**
   * format delete
   */
  export type formatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the format
     */
    select?: formatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the format
     */
    omit?: formatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formatInclude<ExtArgs> | null
    /**
     * Filter which format to delete.
     */
    where: formatWhereUniqueInput
  }

  /**
   * format deleteMany
   */
  export type formatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formats to delete
     */
    where?: formatWhereInput
    /**
     * Limit how many formats to delete.
     */
    limit?: number
  }

  /**
   * format.map
   */
  export type format$mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the map
     */
    select?: mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the map
     */
    omit?: mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mapInclude<ExtArgs> | null
    where?: mapWhereInput
    orderBy?: mapOrderByWithRelationInput | mapOrderByWithRelationInput[]
    cursor?: mapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * format without action
   */
  export type formatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the format
     */
    select?: formatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the format
     */
    omit?: formatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formatInclude<ExtArgs> | null
  }


  /**
   * Model helper_user
   */

  export type AggregateHelper_user = {
    _count: Helper_userCountAggregateOutputType | null
    _avg: Helper_userAvgAggregateOutputType | null
    _sum: Helper_userSumAggregateOutputType | null
    _min: Helper_userMinAggregateOutputType | null
    _max: Helper_userMaxAggregateOutputType | null
  }

  export type Helper_userAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    helper_id: number | null
  }

  export type Helper_userSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    helper_id: number | null
  }

  export type Helper_userMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    helper_id: number | null
    state: string | null
  }

  export type Helper_userMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    helper_id: number | null
    state: string | null
  }

  export type Helper_userCountAggregateOutputType = {
    id: number
    user_id: number
    helper_id: number
    state: number
    _all: number
  }


  export type Helper_userAvgAggregateInputType = {
    id?: true
    user_id?: true
    helper_id?: true
  }

  export type Helper_userSumAggregateInputType = {
    id?: true
    user_id?: true
    helper_id?: true
  }

  export type Helper_userMinAggregateInputType = {
    id?: true
    user_id?: true
    helper_id?: true
    state?: true
  }

  export type Helper_userMaxAggregateInputType = {
    id?: true
    user_id?: true
    helper_id?: true
    state?: true
  }

  export type Helper_userCountAggregateInputType = {
    id?: true
    user_id?: true
    helper_id?: true
    state?: true
    _all?: true
  }

  export type Helper_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which helper_user to aggregate.
     */
    where?: helper_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of helper_users to fetch.
     */
    orderBy?: helper_userOrderByWithRelationInput | helper_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: helper_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` helper_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` helper_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned helper_users
    **/
    _count?: true | Helper_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Helper_userAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Helper_userSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Helper_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Helper_userMaxAggregateInputType
  }

  export type GetHelper_userAggregateType<T extends Helper_userAggregateArgs> = {
        [P in keyof T & keyof AggregateHelper_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelper_user[P]>
      : GetScalarType<T[P], AggregateHelper_user[P]>
  }




  export type helper_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: helper_userWhereInput
    orderBy?: helper_userOrderByWithAggregationInput | helper_userOrderByWithAggregationInput[]
    by: Helper_userScalarFieldEnum[] | Helper_userScalarFieldEnum
    having?: helper_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Helper_userCountAggregateInputType | true
    _avg?: Helper_userAvgAggregateInputType
    _sum?: Helper_userSumAggregateInputType
    _min?: Helper_userMinAggregateInputType
    _max?: Helper_userMaxAggregateInputType
  }

  export type Helper_userGroupByOutputType = {
    id: number
    user_id: number | null
    helper_id: number | null
    state: string | null
    _count: Helper_userCountAggregateOutputType | null
    _avg: Helper_userAvgAggregateOutputType | null
    _sum: Helper_userSumAggregateOutputType | null
    _min: Helper_userMinAggregateOutputType | null
    _max: Helper_userMaxAggregateOutputType | null
  }

  type GetHelper_userGroupByPayload<T extends helper_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Helper_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Helper_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Helper_userGroupByOutputType[P]>
            : GetScalarType<T[P], Helper_userGroupByOutputType[P]>
        }
      >
    >


  export type helper_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    helper_id?: boolean
    state?: boolean
    user_helper_user_helper_idTouser?: boolean | helper_user$user_helper_user_helper_idTouserArgs<ExtArgs>
    user_helper_user_user_idTouser?: boolean | helper_user$user_helper_user_user_idTouserArgs<ExtArgs>
  }, ExtArgs["result"]["helper_user"]>

  export type helper_userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    helper_id?: boolean
    state?: boolean
    user_helper_user_helper_idTouser?: boolean | helper_user$user_helper_user_helper_idTouserArgs<ExtArgs>
    user_helper_user_user_idTouser?: boolean | helper_user$user_helper_user_user_idTouserArgs<ExtArgs>
  }, ExtArgs["result"]["helper_user"]>

  export type helper_userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    helper_id?: boolean
    state?: boolean
    user_helper_user_helper_idTouser?: boolean | helper_user$user_helper_user_helper_idTouserArgs<ExtArgs>
    user_helper_user_user_idTouser?: boolean | helper_user$user_helper_user_user_idTouserArgs<ExtArgs>
  }, ExtArgs["result"]["helper_user"]>

  export type helper_userSelectScalar = {
    id?: boolean
    user_id?: boolean
    helper_id?: boolean
    state?: boolean
  }

  export type helper_userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "helper_id" | "state", ExtArgs["result"]["helper_user"]>
  export type helper_userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_helper_user_helper_idTouser?: boolean | helper_user$user_helper_user_helper_idTouserArgs<ExtArgs>
    user_helper_user_user_idTouser?: boolean | helper_user$user_helper_user_user_idTouserArgs<ExtArgs>
  }
  export type helper_userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_helper_user_helper_idTouser?: boolean | helper_user$user_helper_user_helper_idTouserArgs<ExtArgs>
    user_helper_user_user_idTouser?: boolean | helper_user$user_helper_user_user_idTouserArgs<ExtArgs>
  }
  export type helper_userIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_helper_user_helper_idTouser?: boolean | helper_user$user_helper_user_helper_idTouserArgs<ExtArgs>
    user_helper_user_user_idTouser?: boolean | helper_user$user_helper_user_user_idTouserArgs<ExtArgs>
  }

  export type $helper_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "helper_user"
    objects: {
      user_helper_user_helper_idTouser: Prisma.$userPayload<ExtArgs> | null
      user_helper_user_user_idTouser: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number | null
      helper_id: number | null
      state: string | null
    }, ExtArgs["result"]["helper_user"]>
    composites: {}
  }

  type helper_userGetPayload<S extends boolean | null | undefined | helper_userDefaultArgs> = $Result.GetResult<Prisma.$helper_userPayload, S>

  type helper_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<helper_userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Helper_userCountAggregateInputType | true
    }

  export interface helper_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['helper_user'], meta: { name: 'helper_user' } }
    /**
     * Find zero or one Helper_user that matches the filter.
     * @param {helper_userFindUniqueArgs} args - Arguments to find a Helper_user
     * @example
     * // Get one Helper_user
     * const helper_user = await prisma.helper_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends helper_userFindUniqueArgs>(args: SelectSubset<T, helper_userFindUniqueArgs<ExtArgs>>): Prisma__helper_userClient<$Result.GetResult<Prisma.$helper_userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Helper_user that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {helper_userFindUniqueOrThrowArgs} args - Arguments to find a Helper_user
     * @example
     * // Get one Helper_user
     * const helper_user = await prisma.helper_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends helper_userFindUniqueOrThrowArgs>(args: SelectSubset<T, helper_userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__helper_userClient<$Result.GetResult<Prisma.$helper_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Helper_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helper_userFindFirstArgs} args - Arguments to find a Helper_user
     * @example
     * // Get one Helper_user
     * const helper_user = await prisma.helper_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends helper_userFindFirstArgs>(args?: SelectSubset<T, helper_userFindFirstArgs<ExtArgs>>): Prisma__helper_userClient<$Result.GetResult<Prisma.$helper_userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Helper_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helper_userFindFirstOrThrowArgs} args - Arguments to find a Helper_user
     * @example
     * // Get one Helper_user
     * const helper_user = await prisma.helper_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends helper_userFindFirstOrThrowArgs>(args?: SelectSubset<T, helper_userFindFirstOrThrowArgs<ExtArgs>>): Prisma__helper_userClient<$Result.GetResult<Prisma.$helper_userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Helper_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helper_userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Helper_users
     * const helper_users = await prisma.helper_user.findMany()
     * 
     * // Get first 10 Helper_users
     * const helper_users = await prisma.helper_user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helper_userWithIdOnly = await prisma.helper_user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends helper_userFindManyArgs>(args?: SelectSubset<T, helper_userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helper_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Helper_user.
     * @param {helper_userCreateArgs} args - Arguments to create a Helper_user.
     * @example
     * // Create one Helper_user
     * const Helper_user = await prisma.helper_user.create({
     *   data: {
     *     // ... data to create a Helper_user
     *   }
     * })
     * 
     */
    create<T extends helper_userCreateArgs>(args: SelectSubset<T, helper_userCreateArgs<ExtArgs>>): Prisma__helper_userClient<$Result.GetResult<Prisma.$helper_userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Helper_users.
     * @param {helper_userCreateManyArgs} args - Arguments to create many Helper_users.
     * @example
     * // Create many Helper_users
     * const helper_user = await prisma.helper_user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends helper_userCreateManyArgs>(args?: SelectSubset<T, helper_userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Helper_users and returns the data saved in the database.
     * @param {helper_userCreateManyAndReturnArgs} args - Arguments to create many Helper_users.
     * @example
     * // Create many Helper_users
     * const helper_user = await prisma.helper_user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Helper_users and only return the `id`
     * const helper_userWithIdOnly = await prisma.helper_user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends helper_userCreateManyAndReturnArgs>(args?: SelectSubset<T, helper_userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helper_userPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Helper_user.
     * @param {helper_userDeleteArgs} args - Arguments to delete one Helper_user.
     * @example
     * // Delete one Helper_user
     * const Helper_user = await prisma.helper_user.delete({
     *   where: {
     *     // ... filter to delete one Helper_user
     *   }
     * })
     * 
     */
    delete<T extends helper_userDeleteArgs>(args: SelectSubset<T, helper_userDeleteArgs<ExtArgs>>): Prisma__helper_userClient<$Result.GetResult<Prisma.$helper_userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Helper_user.
     * @param {helper_userUpdateArgs} args - Arguments to update one Helper_user.
     * @example
     * // Update one Helper_user
     * const helper_user = await prisma.helper_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends helper_userUpdateArgs>(args: SelectSubset<T, helper_userUpdateArgs<ExtArgs>>): Prisma__helper_userClient<$Result.GetResult<Prisma.$helper_userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Helper_users.
     * @param {helper_userDeleteManyArgs} args - Arguments to filter Helper_users to delete.
     * @example
     * // Delete a few Helper_users
     * const { count } = await prisma.helper_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends helper_userDeleteManyArgs>(args?: SelectSubset<T, helper_userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Helper_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helper_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Helper_users
     * const helper_user = await prisma.helper_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends helper_userUpdateManyArgs>(args: SelectSubset<T, helper_userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Helper_users and returns the data updated in the database.
     * @param {helper_userUpdateManyAndReturnArgs} args - Arguments to update many Helper_users.
     * @example
     * // Update many Helper_users
     * const helper_user = await prisma.helper_user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Helper_users and only return the `id`
     * const helper_userWithIdOnly = await prisma.helper_user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends helper_userUpdateManyAndReturnArgs>(args: SelectSubset<T, helper_userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helper_userPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Helper_user.
     * @param {helper_userUpsertArgs} args - Arguments to update or create a Helper_user.
     * @example
     * // Update or create a Helper_user
     * const helper_user = await prisma.helper_user.upsert({
     *   create: {
     *     // ... data to create a Helper_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Helper_user we want to update
     *   }
     * })
     */
    upsert<T extends helper_userUpsertArgs>(args: SelectSubset<T, helper_userUpsertArgs<ExtArgs>>): Prisma__helper_userClient<$Result.GetResult<Prisma.$helper_userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Helper_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helper_userCountArgs} args - Arguments to filter Helper_users to count.
     * @example
     * // Count the number of Helper_users
     * const count = await prisma.helper_user.count({
     *   where: {
     *     // ... the filter for the Helper_users we want to count
     *   }
     * })
    **/
    count<T extends helper_userCountArgs>(
      args?: Subset<T, helper_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Helper_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Helper_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Helper_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Helper_userAggregateArgs>(args: Subset<T, Helper_userAggregateArgs>): Prisma.PrismaPromise<GetHelper_userAggregateType<T>>

    /**
     * Group by Helper_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {helper_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends helper_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: helper_userGroupByArgs['orderBy'] }
        : { orderBy?: helper_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, helper_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelper_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the helper_user model
   */
  readonly fields: helper_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for helper_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__helper_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_helper_user_helper_idTouser<T extends helper_user$user_helper_user_helper_idTouserArgs<ExtArgs> = {}>(args?: Subset<T, helper_user$user_helper_user_helper_idTouserArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user_helper_user_user_idTouser<T extends helper_user$user_helper_user_user_idTouserArgs<ExtArgs> = {}>(args?: Subset<T, helper_user$user_helper_user_user_idTouserArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the helper_user model
   */
  interface helper_userFieldRefs {
    readonly id: FieldRef<"helper_user", 'Int'>
    readonly user_id: FieldRef<"helper_user", 'Int'>
    readonly helper_id: FieldRef<"helper_user", 'Int'>
    readonly state: FieldRef<"helper_user", 'String'>
  }
    

  // Custom InputTypes
  /**
   * helper_user findUnique
   */
  export type helper_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helper_user
     */
    select?: helper_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helper_user
     */
    omit?: helper_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helper_userInclude<ExtArgs> | null
    /**
     * Filter, which helper_user to fetch.
     */
    where: helper_userWhereUniqueInput
  }

  /**
   * helper_user findUniqueOrThrow
   */
  export type helper_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helper_user
     */
    select?: helper_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helper_user
     */
    omit?: helper_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helper_userInclude<ExtArgs> | null
    /**
     * Filter, which helper_user to fetch.
     */
    where: helper_userWhereUniqueInput
  }

  /**
   * helper_user findFirst
   */
  export type helper_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helper_user
     */
    select?: helper_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helper_user
     */
    omit?: helper_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helper_userInclude<ExtArgs> | null
    /**
     * Filter, which helper_user to fetch.
     */
    where?: helper_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of helper_users to fetch.
     */
    orderBy?: helper_userOrderByWithRelationInput | helper_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for helper_users.
     */
    cursor?: helper_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` helper_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` helper_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of helper_users.
     */
    distinct?: Helper_userScalarFieldEnum | Helper_userScalarFieldEnum[]
  }

  /**
   * helper_user findFirstOrThrow
   */
  export type helper_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helper_user
     */
    select?: helper_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helper_user
     */
    omit?: helper_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helper_userInclude<ExtArgs> | null
    /**
     * Filter, which helper_user to fetch.
     */
    where?: helper_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of helper_users to fetch.
     */
    orderBy?: helper_userOrderByWithRelationInput | helper_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for helper_users.
     */
    cursor?: helper_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` helper_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` helper_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of helper_users.
     */
    distinct?: Helper_userScalarFieldEnum | Helper_userScalarFieldEnum[]
  }

  /**
   * helper_user findMany
   */
  export type helper_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helper_user
     */
    select?: helper_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helper_user
     */
    omit?: helper_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helper_userInclude<ExtArgs> | null
    /**
     * Filter, which helper_users to fetch.
     */
    where?: helper_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of helper_users to fetch.
     */
    orderBy?: helper_userOrderByWithRelationInput | helper_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing helper_users.
     */
    cursor?: helper_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` helper_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` helper_users.
     */
    skip?: number
    distinct?: Helper_userScalarFieldEnum | Helper_userScalarFieldEnum[]
  }

  /**
   * helper_user create
   */
  export type helper_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helper_user
     */
    select?: helper_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helper_user
     */
    omit?: helper_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helper_userInclude<ExtArgs> | null
    /**
     * The data needed to create a helper_user.
     */
    data?: XOR<helper_userCreateInput, helper_userUncheckedCreateInput>
  }

  /**
   * helper_user createMany
   */
  export type helper_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many helper_users.
     */
    data: helper_userCreateManyInput | helper_userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * helper_user createManyAndReturn
   */
  export type helper_userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helper_user
     */
    select?: helper_userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the helper_user
     */
    omit?: helper_userOmit<ExtArgs> | null
    /**
     * The data used to create many helper_users.
     */
    data: helper_userCreateManyInput | helper_userCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helper_userIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * helper_user update
   */
  export type helper_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helper_user
     */
    select?: helper_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helper_user
     */
    omit?: helper_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helper_userInclude<ExtArgs> | null
    /**
     * The data needed to update a helper_user.
     */
    data: XOR<helper_userUpdateInput, helper_userUncheckedUpdateInput>
    /**
     * Choose, which helper_user to update.
     */
    where: helper_userWhereUniqueInput
  }

  /**
   * helper_user updateMany
   */
  export type helper_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update helper_users.
     */
    data: XOR<helper_userUpdateManyMutationInput, helper_userUncheckedUpdateManyInput>
    /**
     * Filter which helper_users to update
     */
    where?: helper_userWhereInput
    /**
     * Limit how many helper_users to update.
     */
    limit?: number
  }

  /**
   * helper_user updateManyAndReturn
   */
  export type helper_userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helper_user
     */
    select?: helper_userSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the helper_user
     */
    omit?: helper_userOmit<ExtArgs> | null
    /**
     * The data used to update helper_users.
     */
    data: XOR<helper_userUpdateManyMutationInput, helper_userUncheckedUpdateManyInput>
    /**
     * Filter which helper_users to update
     */
    where?: helper_userWhereInput
    /**
     * Limit how many helper_users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helper_userIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * helper_user upsert
   */
  export type helper_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helper_user
     */
    select?: helper_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helper_user
     */
    omit?: helper_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helper_userInclude<ExtArgs> | null
    /**
     * The filter to search for the helper_user to update in case it exists.
     */
    where: helper_userWhereUniqueInput
    /**
     * In case the helper_user found by the `where` argument doesn't exist, create a new helper_user with this data.
     */
    create: XOR<helper_userCreateInput, helper_userUncheckedCreateInput>
    /**
     * In case the helper_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<helper_userUpdateInput, helper_userUncheckedUpdateInput>
  }

  /**
   * helper_user delete
   */
  export type helper_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helper_user
     */
    select?: helper_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helper_user
     */
    omit?: helper_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helper_userInclude<ExtArgs> | null
    /**
     * Filter which helper_user to delete.
     */
    where: helper_userWhereUniqueInput
  }

  /**
   * helper_user deleteMany
   */
  export type helper_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which helper_users to delete
     */
    where?: helper_userWhereInput
    /**
     * Limit how many helper_users to delete.
     */
    limit?: number
  }

  /**
   * helper_user.user_helper_user_helper_idTouser
   */
  export type helper_user$user_helper_user_helper_idTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * helper_user.user_helper_user_user_idTouser
   */
  export type helper_user$user_helper_user_user_idTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * helper_user without action
   */
  export type helper_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helper_user
     */
    select?: helper_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helper_user
     */
    omit?: helper_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helper_userInclude<ExtArgs> | null
  }


  /**
   * Model intervention_history
   */

  export type AggregateIntervention_history = {
    _count: Intervention_historyCountAggregateOutputType | null
    _avg: Intervention_historyAvgAggregateOutputType | null
    _sum: Intervention_historySumAggregateOutputType | null
    _min: Intervention_historyMinAggregateOutputType | null
    _max: Intervention_historyMaxAggregateOutputType | null
  }

  export type Intervention_historyAvgAggregateOutputType = {
    id: number | null
    device_id: number | null
    maintenancier_id: number | null
  }

  export type Intervention_historySumAggregateOutputType = {
    id: number | null
    device_id: number | null
    maintenancier_id: number | null
  }

  export type Intervention_historyMinAggregateOutputType = {
    id: number | null
    device_id: number | null
    maintenancier_id: number | null
    scheduled_date: Date | null
    completion_date: Date | null
    description: string | null
    status: string | null
    type: $Enums.intervention_type | null
    title: string | null
    location: string | null
  }

  export type Intervention_historyMaxAggregateOutputType = {
    id: number | null
    device_id: number | null
    maintenancier_id: number | null
    scheduled_date: Date | null
    completion_date: Date | null
    description: string | null
    status: string | null
    type: $Enums.intervention_type | null
    title: string | null
    location: string | null
  }

  export type Intervention_historyCountAggregateOutputType = {
    id: number
    device_id: number
    maintenancier_id: number
    scheduled_date: number
    completion_date: number
    description: number
    status: number
    type: number
    title: number
    location: number
    _all: number
  }


  export type Intervention_historyAvgAggregateInputType = {
    id?: true
    device_id?: true
    maintenancier_id?: true
  }

  export type Intervention_historySumAggregateInputType = {
    id?: true
    device_id?: true
    maintenancier_id?: true
  }

  export type Intervention_historyMinAggregateInputType = {
    id?: true
    device_id?: true
    maintenancier_id?: true
    scheduled_date?: true
    completion_date?: true
    description?: true
    status?: true
    type?: true
    title?: true
    location?: true
  }

  export type Intervention_historyMaxAggregateInputType = {
    id?: true
    device_id?: true
    maintenancier_id?: true
    scheduled_date?: true
    completion_date?: true
    description?: true
    status?: true
    type?: true
    title?: true
    location?: true
  }

  export type Intervention_historyCountAggregateInputType = {
    id?: true
    device_id?: true
    maintenancier_id?: true
    scheduled_date?: true
    completion_date?: true
    description?: true
    status?: true
    type?: true
    title?: true
    location?: true
    _all?: true
  }

  export type Intervention_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which intervention_history to aggregate.
     */
    where?: intervention_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of intervention_histories to fetch.
     */
    orderBy?: intervention_historyOrderByWithRelationInput | intervention_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: intervention_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` intervention_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` intervention_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned intervention_histories
    **/
    _count?: true | Intervention_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Intervention_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Intervention_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Intervention_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Intervention_historyMaxAggregateInputType
  }

  export type GetIntervention_historyAggregateType<T extends Intervention_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateIntervention_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntervention_history[P]>
      : GetScalarType<T[P], AggregateIntervention_history[P]>
  }




  export type intervention_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: intervention_historyWhereInput
    orderBy?: intervention_historyOrderByWithAggregationInput | intervention_historyOrderByWithAggregationInput[]
    by: Intervention_historyScalarFieldEnum[] | Intervention_historyScalarFieldEnum
    having?: intervention_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Intervention_historyCountAggregateInputType | true
    _avg?: Intervention_historyAvgAggregateInputType
    _sum?: Intervention_historySumAggregateInputType
    _min?: Intervention_historyMinAggregateInputType
    _max?: Intervention_historyMaxAggregateInputType
  }

  export type Intervention_historyGroupByOutputType = {
    id: number
    device_id: number | null
    maintenancier_id: number | null
    scheduled_date: Date
    completion_date: Date | null
    description: string | null
    status: string | null
    type: $Enums.intervention_type | null
    title: string | null
    location: string | null
    _count: Intervention_historyCountAggregateOutputType | null
    _avg: Intervention_historyAvgAggregateOutputType | null
    _sum: Intervention_historySumAggregateOutputType | null
    _min: Intervention_historyMinAggregateOutputType | null
    _max: Intervention_historyMaxAggregateOutputType | null
  }

  type GetIntervention_historyGroupByPayload<T extends intervention_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Intervention_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Intervention_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Intervention_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Intervention_historyGroupByOutputType[P]>
        }
      >
    >


  export type intervention_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_id?: boolean
    maintenancier_id?: boolean
    scheduled_date?: boolean
    completion_date?: boolean
    description?: boolean
    status?: boolean
    type?: boolean
    title?: boolean
    location?: boolean
    user?: boolean | intervention_history$userArgs<ExtArgs>
  }, ExtArgs["result"]["intervention_history"]>

  export type intervention_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_id?: boolean
    maintenancier_id?: boolean
    scheduled_date?: boolean
    completion_date?: boolean
    description?: boolean
    status?: boolean
    type?: boolean
    title?: boolean
    location?: boolean
    user?: boolean | intervention_history$userArgs<ExtArgs>
  }, ExtArgs["result"]["intervention_history"]>

  export type intervention_historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_id?: boolean
    maintenancier_id?: boolean
    scheduled_date?: boolean
    completion_date?: boolean
    description?: boolean
    status?: boolean
    type?: boolean
    title?: boolean
    location?: boolean
    user?: boolean | intervention_history$userArgs<ExtArgs>
  }, ExtArgs["result"]["intervention_history"]>

  export type intervention_historySelectScalar = {
    id?: boolean
    device_id?: boolean
    maintenancier_id?: boolean
    scheduled_date?: boolean
    completion_date?: boolean
    description?: boolean
    status?: boolean
    type?: boolean
    title?: boolean
    location?: boolean
  }

  export type intervention_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "device_id" | "maintenancier_id" | "scheduled_date" | "completion_date" | "description" | "status" | "type" | "title" | "location", ExtArgs["result"]["intervention_history"]>
  export type intervention_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | intervention_history$userArgs<ExtArgs>
  }
  export type intervention_historyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | intervention_history$userArgs<ExtArgs>
  }
  export type intervention_historyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | intervention_history$userArgs<ExtArgs>
  }

  export type $intervention_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "intervention_history"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      device_id: number | null
      maintenancier_id: number | null
      scheduled_date: Date
      completion_date: Date | null
      description: string | null
      status: string | null
      type: $Enums.intervention_type | null
      title: string | null
      location: string | null
    }, ExtArgs["result"]["intervention_history"]>
    composites: {}
  }

  type intervention_historyGetPayload<S extends boolean | null | undefined | intervention_historyDefaultArgs> = $Result.GetResult<Prisma.$intervention_historyPayload, S>

  type intervention_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<intervention_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Intervention_historyCountAggregateInputType | true
    }

  export interface intervention_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['intervention_history'], meta: { name: 'intervention_history' } }
    /**
     * Find zero or one Intervention_history that matches the filter.
     * @param {intervention_historyFindUniqueArgs} args - Arguments to find a Intervention_history
     * @example
     * // Get one Intervention_history
     * const intervention_history = await prisma.intervention_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends intervention_historyFindUniqueArgs>(args: SelectSubset<T, intervention_historyFindUniqueArgs<ExtArgs>>): Prisma__intervention_historyClient<$Result.GetResult<Prisma.$intervention_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Intervention_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {intervention_historyFindUniqueOrThrowArgs} args - Arguments to find a Intervention_history
     * @example
     * // Get one Intervention_history
     * const intervention_history = await prisma.intervention_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends intervention_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, intervention_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__intervention_historyClient<$Result.GetResult<Prisma.$intervention_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Intervention_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intervention_historyFindFirstArgs} args - Arguments to find a Intervention_history
     * @example
     * // Get one Intervention_history
     * const intervention_history = await prisma.intervention_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends intervention_historyFindFirstArgs>(args?: SelectSubset<T, intervention_historyFindFirstArgs<ExtArgs>>): Prisma__intervention_historyClient<$Result.GetResult<Prisma.$intervention_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Intervention_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intervention_historyFindFirstOrThrowArgs} args - Arguments to find a Intervention_history
     * @example
     * // Get one Intervention_history
     * const intervention_history = await prisma.intervention_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends intervention_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, intervention_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__intervention_historyClient<$Result.GetResult<Prisma.$intervention_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Intervention_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intervention_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Intervention_histories
     * const intervention_histories = await prisma.intervention_history.findMany()
     * 
     * // Get first 10 Intervention_histories
     * const intervention_histories = await prisma.intervention_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const intervention_historyWithIdOnly = await prisma.intervention_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends intervention_historyFindManyArgs>(args?: SelectSubset<T, intervention_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$intervention_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Intervention_history.
     * @param {intervention_historyCreateArgs} args - Arguments to create a Intervention_history.
     * @example
     * // Create one Intervention_history
     * const Intervention_history = await prisma.intervention_history.create({
     *   data: {
     *     // ... data to create a Intervention_history
     *   }
     * })
     * 
     */
    create<T extends intervention_historyCreateArgs>(args: SelectSubset<T, intervention_historyCreateArgs<ExtArgs>>): Prisma__intervention_historyClient<$Result.GetResult<Prisma.$intervention_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Intervention_histories.
     * @param {intervention_historyCreateManyArgs} args - Arguments to create many Intervention_histories.
     * @example
     * // Create many Intervention_histories
     * const intervention_history = await prisma.intervention_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends intervention_historyCreateManyArgs>(args?: SelectSubset<T, intervention_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Intervention_histories and returns the data saved in the database.
     * @param {intervention_historyCreateManyAndReturnArgs} args - Arguments to create many Intervention_histories.
     * @example
     * // Create many Intervention_histories
     * const intervention_history = await prisma.intervention_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Intervention_histories and only return the `id`
     * const intervention_historyWithIdOnly = await prisma.intervention_history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends intervention_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, intervention_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$intervention_historyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Intervention_history.
     * @param {intervention_historyDeleteArgs} args - Arguments to delete one Intervention_history.
     * @example
     * // Delete one Intervention_history
     * const Intervention_history = await prisma.intervention_history.delete({
     *   where: {
     *     // ... filter to delete one Intervention_history
     *   }
     * })
     * 
     */
    delete<T extends intervention_historyDeleteArgs>(args: SelectSubset<T, intervention_historyDeleteArgs<ExtArgs>>): Prisma__intervention_historyClient<$Result.GetResult<Prisma.$intervention_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Intervention_history.
     * @param {intervention_historyUpdateArgs} args - Arguments to update one Intervention_history.
     * @example
     * // Update one Intervention_history
     * const intervention_history = await prisma.intervention_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends intervention_historyUpdateArgs>(args: SelectSubset<T, intervention_historyUpdateArgs<ExtArgs>>): Prisma__intervention_historyClient<$Result.GetResult<Prisma.$intervention_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Intervention_histories.
     * @param {intervention_historyDeleteManyArgs} args - Arguments to filter Intervention_histories to delete.
     * @example
     * // Delete a few Intervention_histories
     * const { count } = await prisma.intervention_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends intervention_historyDeleteManyArgs>(args?: SelectSubset<T, intervention_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Intervention_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intervention_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Intervention_histories
     * const intervention_history = await prisma.intervention_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends intervention_historyUpdateManyArgs>(args: SelectSubset<T, intervention_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Intervention_histories and returns the data updated in the database.
     * @param {intervention_historyUpdateManyAndReturnArgs} args - Arguments to update many Intervention_histories.
     * @example
     * // Update many Intervention_histories
     * const intervention_history = await prisma.intervention_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Intervention_histories and only return the `id`
     * const intervention_historyWithIdOnly = await prisma.intervention_history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends intervention_historyUpdateManyAndReturnArgs>(args: SelectSubset<T, intervention_historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$intervention_historyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Intervention_history.
     * @param {intervention_historyUpsertArgs} args - Arguments to update or create a Intervention_history.
     * @example
     * // Update or create a Intervention_history
     * const intervention_history = await prisma.intervention_history.upsert({
     *   create: {
     *     // ... data to create a Intervention_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Intervention_history we want to update
     *   }
     * })
     */
    upsert<T extends intervention_historyUpsertArgs>(args: SelectSubset<T, intervention_historyUpsertArgs<ExtArgs>>): Prisma__intervention_historyClient<$Result.GetResult<Prisma.$intervention_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Intervention_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intervention_historyCountArgs} args - Arguments to filter Intervention_histories to count.
     * @example
     * // Count the number of Intervention_histories
     * const count = await prisma.intervention_history.count({
     *   where: {
     *     // ... the filter for the Intervention_histories we want to count
     *   }
     * })
    **/
    count<T extends intervention_historyCountArgs>(
      args?: Subset<T, intervention_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Intervention_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Intervention_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Intervention_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Intervention_historyAggregateArgs>(args: Subset<T, Intervention_historyAggregateArgs>): Prisma.PrismaPromise<GetIntervention_historyAggregateType<T>>

    /**
     * Group by Intervention_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intervention_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends intervention_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: intervention_historyGroupByArgs['orderBy'] }
        : { orderBy?: intervention_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, intervention_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntervention_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the intervention_history model
   */
  readonly fields: intervention_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for intervention_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__intervention_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends intervention_history$userArgs<ExtArgs> = {}>(args?: Subset<T, intervention_history$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the intervention_history model
   */
  interface intervention_historyFieldRefs {
    readonly id: FieldRef<"intervention_history", 'Int'>
    readonly device_id: FieldRef<"intervention_history", 'Int'>
    readonly maintenancier_id: FieldRef<"intervention_history", 'Int'>
    readonly scheduled_date: FieldRef<"intervention_history", 'DateTime'>
    readonly completion_date: FieldRef<"intervention_history", 'DateTime'>
    readonly description: FieldRef<"intervention_history", 'String'>
    readonly status: FieldRef<"intervention_history", 'String'>
    readonly type: FieldRef<"intervention_history", 'intervention_type'>
    readonly title: FieldRef<"intervention_history", 'String'>
    readonly location: FieldRef<"intervention_history", 'String'>
  }
    

  // Custom InputTypes
  /**
   * intervention_history findUnique
   */
  export type intervention_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intervention_history
     */
    select?: intervention_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the intervention_history
     */
    omit?: intervention_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intervention_historyInclude<ExtArgs> | null
    /**
     * Filter, which intervention_history to fetch.
     */
    where: intervention_historyWhereUniqueInput
  }

  /**
   * intervention_history findUniqueOrThrow
   */
  export type intervention_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intervention_history
     */
    select?: intervention_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the intervention_history
     */
    omit?: intervention_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intervention_historyInclude<ExtArgs> | null
    /**
     * Filter, which intervention_history to fetch.
     */
    where: intervention_historyWhereUniqueInput
  }

  /**
   * intervention_history findFirst
   */
  export type intervention_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intervention_history
     */
    select?: intervention_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the intervention_history
     */
    omit?: intervention_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intervention_historyInclude<ExtArgs> | null
    /**
     * Filter, which intervention_history to fetch.
     */
    where?: intervention_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of intervention_histories to fetch.
     */
    orderBy?: intervention_historyOrderByWithRelationInput | intervention_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for intervention_histories.
     */
    cursor?: intervention_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` intervention_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` intervention_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of intervention_histories.
     */
    distinct?: Intervention_historyScalarFieldEnum | Intervention_historyScalarFieldEnum[]
  }

  /**
   * intervention_history findFirstOrThrow
   */
  export type intervention_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intervention_history
     */
    select?: intervention_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the intervention_history
     */
    omit?: intervention_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intervention_historyInclude<ExtArgs> | null
    /**
     * Filter, which intervention_history to fetch.
     */
    where?: intervention_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of intervention_histories to fetch.
     */
    orderBy?: intervention_historyOrderByWithRelationInput | intervention_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for intervention_histories.
     */
    cursor?: intervention_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` intervention_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` intervention_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of intervention_histories.
     */
    distinct?: Intervention_historyScalarFieldEnum | Intervention_historyScalarFieldEnum[]
  }

  /**
   * intervention_history findMany
   */
  export type intervention_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intervention_history
     */
    select?: intervention_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the intervention_history
     */
    omit?: intervention_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intervention_historyInclude<ExtArgs> | null
    /**
     * Filter, which intervention_histories to fetch.
     */
    where?: intervention_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of intervention_histories to fetch.
     */
    orderBy?: intervention_historyOrderByWithRelationInput | intervention_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing intervention_histories.
     */
    cursor?: intervention_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` intervention_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` intervention_histories.
     */
    skip?: number
    distinct?: Intervention_historyScalarFieldEnum | Intervention_historyScalarFieldEnum[]
  }

  /**
   * intervention_history create
   */
  export type intervention_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intervention_history
     */
    select?: intervention_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the intervention_history
     */
    omit?: intervention_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intervention_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a intervention_history.
     */
    data: XOR<intervention_historyCreateInput, intervention_historyUncheckedCreateInput>
  }

  /**
   * intervention_history createMany
   */
  export type intervention_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many intervention_histories.
     */
    data: intervention_historyCreateManyInput | intervention_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * intervention_history createManyAndReturn
   */
  export type intervention_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intervention_history
     */
    select?: intervention_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the intervention_history
     */
    omit?: intervention_historyOmit<ExtArgs> | null
    /**
     * The data used to create many intervention_histories.
     */
    data: intervention_historyCreateManyInput | intervention_historyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intervention_historyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * intervention_history update
   */
  export type intervention_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intervention_history
     */
    select?: intervention_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the intervention_history
     */
    omit?: intervention_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intervention_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a intervention_history.
     */
    data: XOR<intervention_historyUpdateInput, intervention_historyUncheckedUpdateInput>
    /**
     * Choose, which intervention_history to update.
     */
    where: intervention_historyWhereUniqueInput
  }

  /**
   * intervention_history updateMany
   */
  export type intervention_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update intervention_histories.
     */
    data: XOR<intervention_historyUpdateManyMutationInput, intervention_historyUncheckedUpdateManyInput>
    /**
     * Filter which intervention_histories to update
     */
    where?: intervention_historyWhereInput
    /**
     * Limit how many intervention_histories to update.
     */
    limit?: number
  }

  /**
   * intervention_history updateManyAndReturn
   */
  export type intervention_historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intervention_history
     */
    select?: intervention_historySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the intervention_history
     */
    omit?: intervention_historyOmit<ExtArgs> | null
    /**
     * The data used to update intervention_histories.
     */
    data: XOR<intervention_historyUpdateManyMutationInput, intervention_historyUncheckedUpdateManyInput>
    /**
     * Filter which intervention_histories to update
     */
    where?: intervention_historyWhereInput
    /**
     * Limit how many intervention_histories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intervention_historyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * intervention_history upsert
   */
  export type intervention_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intervention_history
     */
    select?: intervention_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the intervention_history
     */
    omit?: intervention_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intervention_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the intervention_history to update in case it exists.
     */
    where: intervention_historyWhereUniqueInput
    /**
     * In case the intervention_history found by the `where` argument doesn't exist, create a new intervention_history with this data.
     */
    create: XOR<intervention_historyCreateInput, intervention_historyUncheckedCreateInput>
    /**
     * In case the intervention_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<intervention_historyUpdateInput, intervention_historyUncheckedUpdateInput>
  }

  /**
   * intervention_history delete
   */
  export type intervention_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intervention_history
     */
    select?: intervention_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the intervention_history
     */
    omit?: intervention_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intervention_historyInclude<ExtArgs> | null
    /**
     * Filter which intervention_history to delete.
     */
    where: intervention_historyWhereUniqueInput
  }

  /**
   * intervention_history deleteMany
   */
  export type intervention_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which intervention_histories to delete
     */
    where?: intervention_historyWhereInput
    /**
     * Limit how many intervention_histories to delete.
     */
    limit?: number
  }

  /**
   * intervention_history.user
   */
  export type intervention_history$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * intervention_history without action
   */
  export type intervention_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intervention_history
     */
    select?: intervention_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the intervention_history
     */
    omit?: intervention_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intervention_historyInclude<ExtArgs> | null
  }


  /**
   * Model localisation
   */

  export type AggregateLocalisation = {
    _count: LocalisationCountAggregateOutputType | null
    _avg: LocalisationAvgAggregateOutputType | null
    _sum: LocalisationSumAggregateOutputType | null
    _min: LocalisationMinAggregateOutputType | null
    _max: LocalisationMaxAggregateOutputType | null
  }

  export type LocalisationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LocalisationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LocalisationMinAggregateOutputType = {
    id: number | null
    longitude: string | null
    latitude: string | null
    userId: number | null
    updated_at: Date | null
  }

  export type LocalisationMaxAggregateOutputType = {
    id: number | null
    longitude: string | null
    latitude: string | null
    userId: number | null
    updated_at: Date | null
  }

  export type LocalisationCountAggregateOutputType = {
    id: number
    longitude: number
    latitude: number
    userId: number
    updated_at: number
    _all: number
  }


  export type LocalisationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LocalisationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LocalisationMinAggregateInputType = {
    id?: true
    longitude?: true
    latitude?: true
    userId?: true
    updated_at?: true
  }

  export type LocalisationMaxAggregateInputType = {
    id?: true
    longitude?: true
    latitude?: true
    userId?: true
    updated_at?: true
  }

  export type LocalisationCountAggregateInputType = {
    id?: true
    longitude?: true
    latitude?: true
    userId?: true
    updated_at?: true
    _all?: true
  }

  export type LocalisationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which localisation to aggregate.
     */
    where?: localisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localisations to fetch.
     */
    orderBy?: localisationOrderByWithRelationInput | localisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: localisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned localisations
    **/
    _count?: true | LocalisationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocalisationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocalisationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalisationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalisationMaxAggregateInputType
  }

  export type GetLocalisationAggregateType<T extends LocalisationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocalisation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocalisation[P]>
      : GetScalarType<T[P], AggregateLocalisation[P]>
  }




  export type localisationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: localisationWhereInput
    orderBy?: localisationOrderByWithAggregationInput | localisationOrderByWithAggregationInput[]
    by: LocalisationScalarFieldEnum[] | LocalisationScalarFieldEnum
    having?: localisationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalisationCountAggregateInputType | true
    _avg?: LocalisationAvgAggregateInputType
    _sum?: LocalisationSumAggregateInputType
    _min?: LocalisationMinAggregateInputType
    _max?: LocalisationMaxAggregateInputType
  }

  export type LocalisationGroupByOutputType = {
    id: number
    longitude: string
    latitude: string
    userId: number
    updated_at: Date
    _count: LocalisationCountAggregateOutputType | null
    _avg: LocalisationAvgAggregateOutputType | null
    _sum: LocalisationSumAggregateOutputType | null
    _min: LocalisationMinAggregateOutputType | null
    _max: LocalisationMaxAggregateOutputType | null
  }

  type GetLocalisationGroupByPayload<T extends localisationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocalisationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalisationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalisationGroupByOutputType[P]>
            : GetScalarType<T[P], LocalisationGroupByOutputType[P]>
        }
      >
    >


  export type localisationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    longitude?: boolean
    latitude?: boolean
    userId?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localisation"]>

  export type localisationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    longitude?: boolean
    latitude?: boolean
    userId?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localisation"]>

  export type localisationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    longitude?: boolean
    latitude?: boolean
    userId?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localisation"]>

  export type localisationSelectScalar = {
    id?: boolean
    longitude?: boolean
    latitude?: boolean
    userId?: boolean
    updated_at?: boolean
  }

  export type localisationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "longitude" | "latitude" | "userId" | "updated_at", ExtArgs["result"]["localisation"]>
  export type localisationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type localisationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type localisationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $localisationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "localisation"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      longitude: string
      latitude: string
      userId: number
      updated_at: Date
    }, ExtArgs["result"]["localisation"]>
    composites: {}
  }

  type localisationGetPayload<S extends boolean | null | undefined | localisationDefaultArgs> = $Result.GetResult<Prisma.$localisationPayload, S>

  type localisationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<localisationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocalisationCountAggregateInputType | true
    }

  export interface localisationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['localisation'], meta: { name: 'localisation' } }
    /**
     * Find zero or one Localisation that matches the filter.
     * @param {localisationFindUniqueArgs} args - Arguments to find a Localisation
     * @example
     * // Get one Localisation
     * const localisation = await prisma.localisation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends localisationFindUniqueArgs>(args: SelectSubset<T, localisationFindUniqueArgs<ExtArgs>>): Prisma__localisationClient<$Result.GetResult<Prisma.$localisationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Localisation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {localisationFindUniqueOrThrowArgs} args - Arguments to find a Localisation
     * @example
     * // Get one Localisation
     * const localisation = await prisma.localisation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends localisationFindUniqueOrThrowArgs>(args: SelectSubset<T, localisationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__localisationClient<$Result.GetResult<Prisma.$localisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Localisation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localisationFindFirstArgs} args - Arguments to find a Localisation
     * @example
     * // Get one Localisation
     * const localisation = await prisma.localisation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends localisationFindFirstArgs>(args?: SelectSubset<T, localisationFindFirstArgs<ExtArgs>>): Prisma__localisationClient<$Result.GetResult<Prisma.$localisationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Localisation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localisationFindFirstOrThrowArgs} args - Arguments to find a Localisation
     * @example
     * // Get one Localisation
     * const localisation = await prisma.localisation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends localisationFindFirstOrThrowArgs>(args?: SelectSubset<T, localisationFindFirstOrThrowArgs<ExtArgs>>): Prisma__localisationClient<$Result.GetResult<Prisma.$localisationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Localisations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localisationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Localisations
     * const localisations = await prisma.localisation.findMany()
     * 
     * // Get first 10 Localisations
     * const localisations = await prisma.localisation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localisationWithIdOnly = await prisma.localisation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends localisationFindManyArgs>(args?: SelectSubset<T, localisationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localisationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Localisation.
     * @param {localisationCreateArgs} args - Arguments to create a Localisation.
     * @example
     * // Create one Localisation
     * const Localisation = await prisma.localisation.create({
     *   data: {
     *     // ... data to create a Localisation
     *   }
     * })
     * 
     */
    create<T extends localisationCreateArgs>(args: SelectSubset<T, localisationCreateArgs<ExtArgs>>): Prisma__localisationClient<$Result.GetResult<Prisma.$localisationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Localisations.
     * @param {localisationCreateManyArgs} args - Arguments to create many Localisations.
     * @example
     * // Create many Localisations
     * const localisation = await prisma.localisation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends localisationCreateManyArgs>(args?: SelectSubset<T, localisationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Localisations and returns the data saved in the database.
     * @param {localisationCreateManyAndReturnArgs} args - Arguments to create many Localisations.
     * @example
     * // Create many Localisations
     * const localisation = await prisma.localisation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Localisations and only return the `id`
     * const localisationWithIdOnly = await prisma.localisation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends localisationCreateManyAndReturnArgs>(args?: SelectSubset<T, localisationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localisationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Localisation.
     * @param {localisationDeleteArgs} args - Arguments to delete one Localisation.
     * @example
     * // Delete one Localisation
     * const Localisation = await prisma.localisation.delete({
     *   where: {
     *     // ... filter to delete one Localisation
     *   }
     * })
     * 
     */
    delete<T extends localisationDeleteArgs>(args: SelectSubset<T, localisationDeleteArgs<ExtArgs>>): Prisma__localisationClient<$Result.GetResult<Prisma.$localisationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Localisation.
     * @param {localisationUpdateArgs} args - Arguments to update one Localisation.
     * @example
     * // Update one Localisation
     * const localisation = await prisma.localisation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends localisationUpdateArgs>(args: SelectSubset<T, localisationUpdateArgs<ExtArgs>>): Prisma__localisationClient<$Result.GetResult<Prisma.$localisationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Localisations.
     * @param {localisationDeleteManyArgs} args - Arguments to filter Localisations to delete.
     * @example
     * // Delete a few Localisations
     * const { count } = await prisma.localisation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends localisationDeleteManyArgs>(args?: SelectSubset<T, localisationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Localisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localisationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Localisations
     * const localisation = await prisma.localisation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends localisationUpdateManyArgs>(args: SelectSubset<T, localisationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Localisations and returns the data updated in the database.
     * @param {localisationUpdateManyAndReturnArgs} args - Arguments to update many Localisations.
     * @example
     * // Update many Localisations
     * const localisation = await prisma.localisation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Localisations and only return the `id`
     * const localisationWithIdOnly = await prisma.localisation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends localisationUpdateManyAndReturnArgs>(args: SelectSubset<T, localisationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localisationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Localisation.
     * @param {localisationUpsertArgs} args - Arguments to update or create a Localisation.
     * @example
     * // Update or create a Localisation
     * const localisation = await prisma.localisation.upsert({
     *   create: {
     *     // ... data to create a Localisation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Localisation we want to update
     *   }
     * })
     */
    upsert<T extends localisationUpsertArgs>(args: SelectSubset<T, localisationUpsertArgs<ExtArgs>>): Prisma__localisationClient<$Result.GetResult<Prisma.$localisationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Localisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localisationCountArgs} args - Arguments to filter Localisations to count.
     * @example
     * // Count the number of Localisations
     * const count = await prisma.localisation.count({
     *   where: {
     *     // ... the filter for the Localisations we want to count
     *   }
     * })
    **/
    count<T extends localisationCountArgs>(
      args?: Subset<T, localisationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalisationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Localisation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalisationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalisationAggregateArgs>(args: Subset<T, LocalisationAggregateArgs>): Prisma.PrismaPromise<GetLocalisationAggregateType<T>>

    /**
     * Group by Localisation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localisationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends localisationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: localisationGroupByArgs['orderBy'] }
        : { orderBy?: localisationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, localisationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalisationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the localisation model
   */
  readonly fields: localisationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for localisation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__localisationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the localisation model
   */
  interface localisationFieldRefs {
    readonly id: FieldRef<"localisation", 'Int'>
    readonly longitude: FieldRef<"localisation", 'String'>
    readonly latitude: FieldRef<"localisation", 'String'>
    readonly userId: FieldRef<"localisation", 'Int'>
    readonly updated_at: FieldRef<"localisation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * localisation findUnique
   */
  export type localisationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localisation
     */
    select?: localisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localisation
     */
    omit?: localisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localisationInclude<ExtArgs> | null
    /**
     * Filter, which localisation to fetch.
     */
    where: localisationWhereUniqueInput
  }

  /**
   * localisation findUniqueOrThrow
   */
  export type localisationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localisation
     */
    select?: localisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localisation
     */
    omit?: localisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localisationInclude<ExtArgs> | null
    /**
     * Filter, which localisation to fetch.
     */
    where: localisationWhereUniqueInput
  }

  /**
   * localisation findFirst
   */
  export type localisationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localisation
     */
    select?: localisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localisation
     */
    omit?: localisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localisationInclude<ExtArgs> | null
    /**
     * Filter, which localisation to fetch.
     */
    where?: localisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localisations to fetch.
     */
    orderBy?: localisationOrderByWithRelationInput | localisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for localisations.
     */
    cursor?: localisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of localisations.
     */
    distinct?: LocalisationScalarFieldEnum | LocalisationScalarFieldEnum[]
  }

  /**
   * localisation findFirstOrThrow
   */
  export type localisationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localisation
     */
    select?: localisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localisation
     */
    omit?: localisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localisationInclude<ExtArgs> | null
    /**
     * Filter, which localisation to fetch.
     */
    where?: localisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localisations to fetch.
     */
    orderBy?: localisationOrderByWithRelationInput | localisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for localisations.
     */
    cursor?: localisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of localisations.
     */
    distinct?: LocalisationScalarFieldEnum | LocalisationScalarFieldEnum[]
  }

  /**
   * localisation findMany
   */
  export type localisationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localisation
     */
    select?: localisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localisation
     */
    omit?: localisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localisationInclude<ExtArgs> | null
    /**
     * Filter, which localisations to fetch.
     */
    where?: localisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localisations to fetch.
     */
    orderBy?: localisationOrderByWithRelationInput | localisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing localisations.
     */
    cursor?: localisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localisations.
     */
    skip?: number
    distinct?: LocalisationScalarFieldEnum | LocalisationScalarFieldEnum[]
  }

  /**
   * localisation create
   */
  export type localisationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localisation
     */
    select?: localisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localisation
     */
    omit?: localisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localisationInclude<ExtArgs> | null
    /**
     * The data needed to create a localisation.
     */
    data: XOR<localisationCreateInput, localisationUncheckedCreateInput>
  }

  /**
   * localisation createMany
   */
  export type localisationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many localisations.
     */
    data: localisationCreateManyInput | localisationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * localisation createManyAndReturn
   */
  export type localisationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localisation
     */
    select?: localisationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the localisation
     */
    omit?: localisationOmit<ExtArgs> | null
    /**
     * The data used to create many localisations.
     */
    data: localisationCreateManyInput | localisationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localisationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * localisation update
   */
  export type localisationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localisation
     */
    select?: localisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localisation
     */
    omit?: localisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localisationInclude<ExtArgs> | null
    /**
     * The data needed to update a localisation.
     */
    data: XOR<localisationUpdateInput, localisationUncheckedUpdateInput>
    /**
     * Choose, which localisation to update.
     */
    where: localisationWhereUniqueInput
  }

  /**
   * localisation updateMany
   */
  export type localisationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update localisations.
     */
    data: XOR<localisationUpdateManyMutationInput, localisationUncheckedUpdateManyInput>
    /**
     * Filter which localisations to update
     */
    where?: localisationWhereInput
    /**
     * Limit how many localisations to update.
     */
    limit?: number
  }

  /**
   * localisation updateManyAndReturn
   */
  export type localisationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localisation
     */
    select?: localisationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the localisation
     */
    omit?: localisationOmit<ExtArgs> | null
    /**
     * The data used to update localisations.
     */
    data: XOR<localisationUpdateManyMutationInput, localisationUncheckedUpdateManyInput>
    /**
     * Filter which localisations to update
     */
    where?: localisationWhereInput
    /**
     * Limit how many localisations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localisationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * localisation upsert
   */
  export type localisationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localisation
     */
    select?: localisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localisation
     */
    omit?: localisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localisationInclude<ExtArgs> | null
    /**
     * The filter to search for the localisation to update in case it exists.
     */
    where: localisationWhereUniqueInput
    /**
     * In case the localisation found by the `where` argument doesn't exist, create a new localisation with this data.
     */
    create: XOR<localisationCreateInput, localisationUncheckedCreateInput>
    /**
     * In case the localisation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<localisationUpdateInput, localisationUncheckedUpdateInput>
  }

  /**
   * localisation delete
   */
  export type localisationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localisation
     */
    select?: localisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localisation
     */
    omit?: localisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localisationInclude<ExtArgs> | null
    /**
     * Filter which localisation to delete.
     */
    where: localisationWhereUniqueInput
  }

  /**
   * localisation deleteMany
   */
  export type localisationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which localisations to delete
     */
    where?: localisationWhereInput
    /**
     * Limit how many localisations to delete.
     */
    limit?: number
  }

  /**
   * localisation without action
   */
  export type localisationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localisation
     */
    select?: localisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localisation
     */
    omit?: localisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localisationInclude<ExtArgs> | null
  }


  /**
   * Model map
   */

  export type AggregateMap = {
    _count: MapCountAggregateOutputType | null
    _avg: MapAvgAggregateOutputType | null
    _sum: MapSumAggregateOutputType | null
    _min: MapMinAggregateOutputType | null
    _max: MapMaxAggregateOutputType | null
  }

  export type MapAvgAggregateOutputType = {
    id: number | null
    format_id: number | null
  }

  export type MapSumAggregateOutputType = {
    id: number | null
    format_id: number | null
  }

  export type MapMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    format_id: number | null
  }

  export type MapMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    format_id: number | null
  }

  export type MapCountAggregateOutputType = {
    id: number
    created_at: number
    format_id: number
    _all: number
  }


  export type MapAvgAggregateInputType = {
    id?: true
    format_id?: true
  }

  export type MapSumAggregateInputType = {
    id?: true
    format_id?: true
  }

  export type MapMinAggregateInputType = {
    id?: true
    created_at?: true
    format_id?: true
  }

  export type MapMaxAggregateInputType = {
    id?: true
    created_at?: true
    format_id?: true
  }

  export type MapCountAggregateInputType = {
    id?: true
    created_at?: true
    format_id?: true
    _all?: true
  }

  export type MapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which map to aggregate.
     */
    where?: mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maps to fetch.
     */
    orderBy?: mapOrderByWithRelationInput | mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned maps
    **/
    _count?: true | MapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapMaxAggregateInputType
  }

  export type GetMapAggregateType<T extends MapAggregateArgs> = {
        [P in keyof T & keyof AggregateMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMap[P]>
      : GetScalarType<T[P], AggregateMap[P]>
  }




  export type mapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mapWhereInput
    orderBy?: mapOrderByWithAggregationInput | mapOrderByWithAggregationInput[]
    by: MapScalarFieldEnum[] | MapScalarFieldEnum
    having?: mapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapCountAggregateInputType | true
    _avg?: MapAvgAggregateInputType
    _sum?: MapSumAggregateInputType
    _min?: MapMinAggregateInputType
    _max?: MapMaxAggregateInputType
  }

  export type MapGroupByOutputType = {
    id: number
    created_at: Date
    format_id: number | null
    _count: MapCountAggregateOutputType | null
    _avg: MapAvgAggregateOutputType | null
    _sum: MapSumAggregateOutputType | null
    _min: MapMinAggregateOutputType | null
    _max: MapMaxAggregateOutputType | null
  }

  type GetMapGroupByPayload<T extends mapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapGroupByOutputType[P]>
            : GetScalarType<T[P], MapGroupByOutputType[P]>
        }
      >
    >


  export type mapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    format_id?: boolean
    environment?: boolean | map$environmentArgs<ExtArgs>
    format?: boolean | map$formatArgs<ExtArgs>
    poi?: boolean | map$poiArgs<ExtArgs>
    zone?: boolean | map$zoneArgs<ExtArgs>
    _count?: boolean | MapCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["map"]>

  export type mapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    format_id?: boolean
    format?: boolean | map$formatArgs<ExtArgs>
  }, ExtArgs["result"]["map"]>

  export type mapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    format_id?: boolean
    format?: boolean | map$formatArgs<ExtArgs>
  }, ExtArgs["result"]["map"]>

  export type mapSelectScalar = {
    id?: boolean
    created_at?: boolean
    format_id?: boolean
  }

  export type mapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "format_id", ExtArgs["result"]["map"]>
  export type mapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | map$environmentArgs<ExtArgs>
    format?: boolean | map$formatArgs<ExtArgs>
    poi?: boolean | map$poiArgs<ExtArgs>
    zone?: boolean | map$zoneArgs<ExtArgs>
    _count?: boolean | MapCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type mapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    format?: boolean | map$formatArgs<ExtArgs>
  }
  export type mapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    format?: boolean | map$formatArgs<ExtArgs>
  }

  export type $mapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "map"
    objects: {
      environment: Prisma.$environmentPayload<ExtArgs>[]
      format: Prisma.$formatPayload<ExtArgs> | null
      poi: Prisma.$poiPayload<ExtArgs>[]
      zone: Prisma.$zonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_at: Date
      format_id: number | null
    }, ExtArgs["result"]["map"]>
    composites: {}
  }

  type mapGetPayload<S extends boolean | null | undefined | mapDefaultArgs> = $Result.GetResult<Prisma.$mapPayload, S>

  type mapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MapCountAggregateInputType | true
    }

  export interface mapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['map'], meta: { name: 'map' } }
    /**
     * Find zero or one Map that matches the filter.
     * @param {mapFindUniqueArgs} args - Arguments to find a Map
     * @example
     * // Get one Map
     * const map = await prisma.map.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mapFindUniqueArgs>(args: SelectSubset<T, mapFindUniqueArgs<ExtArgs>>): Prisma__mapClient<$Result.GetResult<Prisma.$mapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Map that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mapFindUniqueOrThrowArgs} args - Arguments to find a Map
     * @example
     * // Get one Map
     * const map = await prisma.map.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mapFindUniqueOrThrowArgs>(args: SelectSubset<T, mapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mapClient<$Result.GetResult<Prisma.$mapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Map that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapFindFirstArgs} args - Arguments to find a Map
     * @example
     * // Get one Map
     * const map = await prisma.map.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mapFindFirstArgs>(args?: SelectSubset<T, mapFindFirstArgs<ExtArgs>>): Prisma__mapClient<$Result.GetResult<Prisma.$mapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Map that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapFindFirstOrThrowArgs} args - Arguments to find a Map
     * @example
     * // Get one Map
     * const map = await prisma.map.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mapFindFirstOrThrowArgs>(args?: SelectSubset<T, mapFindFirstOrThrowArgs<ExtArgs>>): Prisma__mapClient<$Result.GetResult<Prisma.$mapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Maps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maps
     * const maps = await prisma.map.findMany()
     * 
     * // Get first 10 Maps
     * const maps = await prisma.map.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mapWithIdOnly = await prisma.map.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mapFindManyArgs>(args?: SelectSubset<T, mapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Map.
     * @param {mapCreateArgs} args - Arguments to create a Map.
     * @example
     * // Create one Map
     * const Map = await prisma.map.create({
     *   data: {
     *     // ... data to create a Map
     *   }
     * })
     * 
     */
    create<T extends mapCreateArgs>(args: SelectSubset<T, mapCreateArgs<ExtArgs>>): Prisma__mapClient<$Result.GetResult<Prisma.$mapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Maps.
     * @param {mapCreateManyArgs} args - Arguments to create many Maps.
     * @example
     * // Create many Maps
     * const map = await prisma.map.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mapCreateManyArgs>(args?: SelectSubset<T, mapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Maps and returns the data saved in the database.
     * @param {mapCreateManyAndReturnArgs} args - Arguments to create many Maps.
     * @example
     * // Create many Maps
     * const map = await prisma.map.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Maps and only return the `id`
     * const mapWithIdOnly = await prisma.map.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mapCreateManyAndReturnArgs>(args?: SelectSubset<T, mapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Map.
     * @param {mapDeleteArgs} args - Arguments to delete one Map.
     * @example
     * // Delete one Map
     * const Map = await prisma.map.delete({
     *   where: {
     *     // ... filter to delete one Map
     *   }
     * })
     * 
     */
    delete<T extends mapDeleteArgs>(args: SelectSubset<T, mapDeleteArgs<ExtArgs>>): Prisma__mapClient<$Result.GetResult<Prisma.$mapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Map.
     * @param {mapUpdateArgs} args - Arguments to update one Map.
     * @example
     * // Update one Map
     * const map = await prisma.map.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mapUpdateArgs>(args: SelectSubset<T, mapUpdateArgs<ExtArgs>>): Prisma__mapClient<$Result.GetResult<Prisma.$mapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Maps.
     * @param {mapDeleteManyArgs} args - Arguments to filter Maps to delete.
     * @example
     * // Delete a few Maps
     * const { count } = await prisma.map.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mapDeleteManyArgs>(args?: SelectSubset<T, mapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maps
     * const map = await prisma.map.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mapUpdateManyArgs>(args: SelectSubset<T, mapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maps and returns the data updated in the database.
     * @param {mapUpdateManyAndReturnArgs} args - Arguments to update many Maps.
     * @example
     * // Update many Maps
     * const map = await prisma.map.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Maps and only return the `id`
     * const mapWithIdOnly = await prisma.map.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mapUpdateManyAndReturnArgs>(args: SelectSubset<T, mapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Map.
     * @param {mapUpsertArgs} args - Arguments to update or create a Map.
     * @example
     * // Update or create a Map
     * const map = await prisma.map.upsert({
     *   create: {
     *     // ... data to create a Map
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Map we want to update
     *   }
     * })
     */
    upsert<T extends mapUpsertArgs>(args: SelectSubset<T, mapUpsertArgs<ExtArgs>>): Prisma__mapClient<$Result.GetResult<Prisma.$mapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapCountArgs} args - Arguments to filter Maps to count.
     * @example
     * // Count the number of Maps
     * const count = await prisma.map.count({
     *   where: {
     *     // ... the filter for the Maps we want to count
     *   }
     * })
    **/
    count<T extends mapCountArgs>(
      args?: Subset<T, mapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapAggregateArgs>(args: Subset<T, MapAggregateArgs>): Prisma.PrismaPromise<GetMapAggregateType<T>>

    /**
     * Group by Map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mapGroupByArgs['orderBy'] }
        : { orderBy?: mapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the map model
   */
  readonly fields: mapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for map.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    environment<T extends map$environmentArgs<ExtArgs> = {}>(args?: Subset<T, map$environmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$environmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    format<T extends map$formatArgs<ExtArgs> = {}>(args?: Subset<T, map$formatArgs<ExtArgs>>): Prisma__formatClient<$Result.GetResult<Prisma.$formatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    poi<T extends map$poiArgs<ExtArgs> = {}>(args?: Subset<T, map$poiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zone<T extends map$zoneArgs<ExtArgs> = {}>(args?: Subset<T, map$zoneArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the map model
   */
  interface mapFieldRefs {
    readonly id: FieldRef<"map", 'Int'>
    readonly created_at: FieldRef<"map", 'DateTime'>
    readonly format_id: FieldRef<"map", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * map findUnique
   */
  export type mapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the map
     */
    select?: mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the map
     */
    omit?: mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mapInclude<ExtArgs> | null
    /**
     * Filter, which map to fetch.
     */
    where: mapWhereUniqueInput
  }

  /**
   * map findUniqueOrThrow
   */
  export type mapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the map
     */
    select?: mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the map
     */
    omit?: mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mapInclude<ExtArgs> | null
    /**
     * Filter, which map to fetch.
     */
    where: mapWhereUniqueInput
  }

  /**
   * map findFirst
   */
  export type mapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the map
     */
    select?: mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the map
     */
    omit?: mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mapInclude<ExtArgs> | null
    /**
     * Filter, which map to fetch.
     */
    where?: mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maps to fetch.
     */
    orderBy?: mapOrderByWithRelationInput | mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for maps.
     */
    cursor?: mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of maps.
     */
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * map findFirstOrThrow
   */
  export type mapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the map
     */
    select?: mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the map
     */
    omit?: mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mapInclude<ExtArgs> | null
    /**
     * Filter, which map to fetch.
     */
    where?: mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maps to fetch.
     */
    orderBy?: mapOrderByWithRelationInput | mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for maps.
     */
    cursor?: mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of maps.
     */
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * map findMany
   */
  export type mapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the map
     */
    select?: mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the map
     */
    omit?: mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mapInclude<ExtArgs> | null
    /**
     * Filter, which maps to fetch.
     */
    where?: mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maps to fetch.
     */
    orderBy?: mapOrderByWithRelationInput | mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing maps.
     */
    cursor?: mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maps.
     */
    skip?: number
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * map create
   */
  export type mapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the map
     */
    select?: mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the map
     */
    omit?: mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mapInclude<ExtArgs> | null
    /**
     * The data needed to create a map.
     */
    data?: XOR<mapCreateInput, mapUncheckedCreateInput>
  }

  /**
   * map createMany
   */
  export type mapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many maps.
     */
    data: mapCreateManyInput | mapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * map createManyAndReturn
   */
  export type mapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the map
     */
    select?: mapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the map
     */
    omit?: mapOmit<ExtArgs> | null
    /**
     * The data used to create many maps.
     */
    data: mapCreateManyInput | mapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * map update
   */
  export type mapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the map
     */
    select?: mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the map
     */
    omit?: mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mapInclude<ExtArgs> | null
    /**
     * The data needed to update a map.
     */
    data: XOR<mapUpdateInput, mapUncheckedUpdateInput>
    /**
     * Choose, which map to update.
     */
    where: mapWhereUniqueInput
  }

  /**
   * map updateMany
   */
  export type mapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update maps.
     */
    data: XOR<mapUpdateManyMutationInput, mapUncheckedUpdateManyInput>
    /**
     * Filter which maps to update
     */
    where?: mapWhereInput
    /**
     * Limit how many maps to update.
     */
    limit?: number
  }

  /**
   * map updateManyAndReturn
   */
  export type mapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the map
     */
    select?: mapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the map
     */
    omit?: mapOmit<ExtArgs> | null
    /**
     * The data used to update maps.
     */
    data: XOR<mapUpdateManyMutationInput, mapUncheckedUpdateManyInput>
    /**
     * Filter which maps to update
     */
    where?: mapWhereInput
    /**
     * Limit how many maps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * map upsert
   */
  export type mapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the map
     */
    select?: mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the map
     */
    omit?: mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mapInclude<ExtArgs> | null
    /**
     * The filter to search for the map to update in case it exists.
     */
    where: mapWhereUniqueInput
    /**
     * In case the map found by the `where` argument doesn't exist, create a new map with this data.
     */
    create: XOR<mapCreateInput, mapUncheckedCreateInput>
    /**
     * In case the map was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mapUpdateInput, mapUncheckedUpdateInput>
  }

  /**
   * map delete
   */
  export type mapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the map
     */
    select?: mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the map
     */
    omit?: mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mapInclude<ExtArgs> | null
    /**
     * Filter which map to delete.
     */
    where: mapWhereUniqueInput
  }

  /**
   * map deleteMany
   */
  export type mapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which maps to delete
     */
    where?: mapWhereInput
    /**
     * Limit how many maps to delete.
     */
    limit?: number
  }

  /**
   * map.environment
   */
  export type map$environmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the environment
     */
    select?: environmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the environment
     */
    omit?: environmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: environmentInclude<ExtArgs> | null
    where?: environmentWhereInput
    orderBy?: environmentOrderByWithRelationInput | environmentOrderByWithRelationInput[]
    cursor?: environmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnvironmentScalarFieldEnum | EnvironmentScalarFieldEnum[]
  }

  /**
   * map.format
   */
  export type map$formatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the format
     */
    select?: formatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the format
     */
    omit?: formatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formatInclude<ExtArgs> | null
    where?: formatWhereInput
  }

  /**
   * map.poi
   */
  export type map$poiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi
     */
    select?: poiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi
     */
    omit?: poiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poiInclude<ExtArgs> | null
    where?: poiWhereInput
    orderBy?: poiOrderByWithRelationInput | poiOrderByWithRelationInput[]
    cursor?: poiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PoiScalarFieldEnum | PoiScalarFieldEnum[]
  }

  /**
   * map.zone
   */
  export type map$zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    where?: zoneWhereInput
    orderBy?: zoneOrderByWithRelationInput | zoneOrderByWithRelationInput[]
    cursor?: zoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * map without action
   */
  export type mapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the map
     */
    select?: mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the map
     */
    omit?: mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mapInclude<ExtArgs> | null
  }


  /**
   * Model market_potentiel
   */

  export type AggregateMarket_potentiel = {
    _count: Market_potentielCountAggregateOutputType | null
    _avg: Market_potentielAvgAggregateOutputType | null
    _sum: Market_potentielSumAggregateOutputType | null
    _min: Market_potentielMinAggregateOutputType | null
    _max: Market_potentielMaxAggregateOutputType | null
  }

  export type Market_potentielAvgAggregateOutputType = {
    id: number | null
    potential_value: number | null
  }

  export type Market_potentielSumAggregateOutputType = {
    id: bigint | null
    potential_value: number | null
  }

  export type Market_potentielMinAggregateOutputType = {
    id: bigint | null
    created_at: Date | null
    city: string | null
    potential_value: number | null
  }

  export type Market_potentielMaxAggregateOutputType = {
    id: bigint | null
    created_at: Date | null
    city: string | null
    potential_value: number | null
  }

  export type Market_potentielCountAggregateOutputType = {
    id: number
    created_at: number
    city: number
    potential_value: number
    _all: number
  }


  export type Market_potentielAvgAggregateInputType = {
    id?: true
    potential_value?: true
  }

  export type Market_potentielSumAggregateInputType = {
    id?: true
    potential_value?: true
  }

  export type Market_potentielMinAggregateInputType = {
    id?: true
    created_at?: true
    city?: true
    potential_value?: true
  }

  export type Market_potentielMaxAggregateInputType = {
    id?: true
    created_at?: true
    city?: true
    potential_value?: true
  }

  export type Market_potentielCountAggregateInputType = {
    id?: true
    created_at?: true
    city?: true
    potential_value?: true
    _all?: true
  }

  export type Market_potentielAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which market_potentiel to aggregate.
     */
    where?: market_potentielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_potentiels to fetch.
     */
    orderBy?: market_potentielOrderByWithRelationInput | market_potentielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: market_potentielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_potentiels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_potentiels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned market_potentiels
    **/
    _count?: true | Market_potentielCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Market_potentielAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Market_potentielSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Market_potentielMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Market_potentielMaxAggregateInputType
  }

  export type GetMarket_potentielAggregateType<T extends Market_potentielAggregateArgs> = {
        [P in keyof T & keyof AggregateMarket_potentiel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarket_potentiel[P]>
      : GetScalarType<T[P], AggregateMarket_potentiel[P]>
  }




  export type market_potentielGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: market_potentielWhereInput
    orderBy?: market_potentielOrderByWithAggregationInput | market_potentielOrderByWithAggregationInput[]
    by: Market_potentielScalarFieldEnum[] | Market_potentielScalarFieldEnum
    having?: market_potentielScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Market_potentielCountAggregateInputType | true
    _avg?: Market_potentielAvgAggregateInputType
    _sum?: Market_potentielSumAggregateInputType
    _min?: Market_potentielMinAggregateInputType
    _max?: Market_potentielMaxAggregateInputType
  }

  export type Market_potentielGroupByOutputType = {
    id: bigint
    created_at: Date
    city: string
    potential_value: number | null
    _count: Market_potentielCountAggregateOutputType | null
    _avg: Market_potentielAvgAggregateOutputType | null
    _sum: Market_potentielSumAggregateOutputType | null
    _min: Market_potentielMinAggregateOutputType | null
    _max: Market_potentielMaxAggregateOutputType | null
  }

  type GetMarket_potentielGroupByPayload<T extends market_potentielGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Market_potentielGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Market_potentielGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Market_potentielGroupByOutputType[P]>
            : GetScalarType<T[P], Market_potentielGroupByOutputType[P]>
        }
      >
    >


  export type market_potentielSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    city?: boolean
    potential_value?: boolean
  }, ExtArgs["result"]["market_potentiel"]>

  export type market_potentielSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    city?: boolean
    potential_value?: boolean
  }, ExtArgs["result"]["market_potentiel"]>

  export type market_potentielSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    city?: boolean
    potential_value?: boolean
  }, ExtArgs["result"]["market_potentiel"]>

  export type market_potentielSelectScalar = {
    id?: boolean
    created_at?: boolean
    city?: boolean
    potential_value?: boolean
  }

  export type market_potentielOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "city" | "potential_value", ExtArgs["result"]["market_potentiel"]>

  export type $market_potentielPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "market_potentiel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      created_at: Date
      city: string
      potential_value: number | null
    }, ExtArgs["result"]["market_potentiel"]>
    composites: {}
  }

  type market_potentielGetPayload<S extends boolean | null | undefined | market_potentielDefaultArgs> = $Result.GetResult<Prisma.$market_potentielPayload, S>

  type market_potentielCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<market_potentielFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Market_potentielCountAggregateInputType | true
    }

  export interface market_potentielDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['market_potentiel'], meta: { name: 'market_potentiel' } }
    /**
     * Find zero or one Market_potentiel that matches the filter.
     * @param {market_potentielFindUniqueArgs} args - Arguments to find a Market_potentiel
     * @example
     * // Get one Market_potentiel
     * const market_potentiel = await prisma.market_potentiel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends market_potentielFindUniqueArgs>(args: SelectSubset<T, market_potentielFindUniqueArgs<ExtArgs>>): Prisma__market_potentielClient<$Result.GetResult<Prisma.$market_potentielPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Market_potentiel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {market_potentielFindUniqueOrThrowArgs} args - Arguments to find a Market_potentiel
     * @example
     * // Get one Market_potentiel
     * const market_potentiel = await prisma.market_potentiel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends market_potentielFindUniqueOrThrowArgs>(args: SelectSubset<T, market_potentielFindUniqueOrThrowArgs<ExtArgs>>): Prisma__market_potentielClient<$Result.GetResult<Prisma.$market_potentielPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Market_potentiel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_potentielFindFirstArgs} args - Arguments to find a Market_potentiel
     * @example
     * // Get one Market_potentiel
     * const market_potentiel = await prisma.market_potentiel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends market_potentielFindFirstArgs>(args?: SelectSubset<T, market_potentielFindFirstArgs<ExtArgs>>): Prisma__market_potentielClient<$Result.GetResult<Prisma.$market_potentielPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Market_potentiel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_potentielFindFirstOrThrowArgs} args - Arguments to find a Market_potentiel
     * @example
     * // Get one Market_potentiel
     * const market_potentiel = await prisma.market_potentiel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends market_potentielFindFirstOrThrowArgs>(args?: SelectSubset<T, market_potentielFindFirstOrThrowArgs<ExtArgs>>): Prisma__market_potentielClient<$Result.GetResult<Prisma.$market_potentielPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Market_potentiels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_potentielFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Market_potentiels
     * const market_potentiels = await prisma.market_potentiel.findMany()
     * 
     * // Get first 10 Market_potentiels
     * const market_potentiels = await prisma.market_potentiel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const market_potentielWithIdOnly = await prisma.market_potentiel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends market_potentielFindManyArgs>(args?: SelectSubset<T, market_potentielFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$market_potentielPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Market_potentiel.
     * @param {market_potentielCreateArgs} args - Arguments to create a Market_potentiel.
     * @example
     * // Create one Market_potentiel
     * const Market_potentiel = await prisma.market_potentiel.create({
     *   data: {
     *     // ... data to create a Market_potentiel
     *   }
     * })
     * 
     */
    create<T extends market_potentielCreateArgs>(args: SelectSubset<T, market_potentielCreateArgs<ExtArgs>>): Prisma__market_potentielClient<$Result.GetResult<Prisma.$market_potentielPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Market_potentiels.
     * @param {market_potentielCreateManyArgs} args - Arguments to create many Market_potentiels.
     * @example
     * // Create many Market_potentiels
     * const market_potentiel = await prisma.market_potentiel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends market_potentielCreateManyArgs>(args?: SelectSubset<T, market_potentielCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Market_potentiels and returns the data saved in the database.
     * @param {market_potentielCreateManyAndReturnArgs} args - Arguments to create many Market_potentiels.
     * @example
     * // Create many Market_potentiels
     * const market_potentiel = await prisma.market_potentiel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Market_potentiels and only return the `id`
     * const market_potentielWithIdOnly = await prisma.market_potentiel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends market_potentielCreateManyAndReturnArgs>(args?: SelectSubset<T, market_potentielCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$market_potentielPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Market_potentiel.
     * @param {market_potentielDeleteArgs} args - Arguments to delete one Market_potentiel.
     * @example
     * // Delete one Market_potentiel
     * const Market_potentiel = await prisma.market_potentiel.delete({
     *   where: {
     *     // ... filter to delete one Market_potentiel
     *   }
     * })
     * 
     */
    delete<T extends market_potentielDeleteArgs>(args: SelectSubset<T, market_potentielDeleteArgs<ExtArgs>>): Prisma__market_potentielClient<$Result.GetResult<Prisma.$market_potentielPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Market_potentiel.
     * @param {market_potentielUpdateArgs} args - Arguments to update one Market_potentiel.
     * @example
     * // Update one Market_potentiel
     * const market_potentiel = await prisma.market_potentiel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends market_potentielUpdateArgs>(args: SelectSubset<T, market_potentielUpdateArgs<ExtArgs>>): Prisma__market_potentielClient<$Result.GetResult<Prisma.$market_potentielPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Market_potentiels.
     * @param {market_potentielDeleteManyArgs} args - Arguments to filter Market_potentiels to delete.
     * @example
     * // Delete a few Market_potentiels
     * const { count } = await prisma.market_potentiel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends market_potentielDeleteManyArgs>(args?: SelectSubset<T, market_potentielDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Market_potentiels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_potentielUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Market_potentiels
     * const market_potentiel = await prisma.market_potentiel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends market_potentielUpdateManyArgs>(args: SelectSubset<T, market_potentielUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Market_potentiels and returns the data updated in the database.
     * @param {market_potentielUpdateManyAndReturnArgs} args - Arguments to update many Market_potentiels.
     * @example
     * // Update many Market_potentiels
     * const market_potentiel = await prisma.market_potentiel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Market_potentiels and only return the `id`
     * const market_potentielWithIdOnly = await prisma.market_potentiel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends market_potentielUpdateManyAndReturnArgs>(args: SelectSubset<T, market_potentielUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$market_potentielPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Market_potentiel.
     * @param {market_potentielUpsertArgs} args - Arguments to update or create a Market_potentiel.
     * @example
     * // Update or create a Market_potentiel
     * const market_potentiel = await prisma.market_potentiel.upsert({
     *   create: {
     *     // ... data to create a Market_potentiel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Market_potentiel we want to update
     *   }
     * })
     */
    upsert<T extends market_potentielUpsertArgs>(args: SelectSubset<T, market_potentielUpsertArgs<ExtArgs>>): Prisma__market_potentielClient<$Result.GetResult<Prisma.$market_potentielPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Market_potentiels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_potentielCountArgs} args - Arguments to filter Market_potentiels to count.
     * @example
     * // Count the number of Market_potentiels
     * const count = await prisma.market_potentiel.count({
     *   where: {
     *     // ... the filter for the Market_potentiels we want to count
     *   }
     * })
    **/
    count<T extends market_potentielCountArgs>(
      args?: Subset<T, market_potentielCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Market_potentielCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Market_potentiel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Market_potentielAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Market_potentielAggregateArgs>(args: Subset<T, Market_potentielAggregateArgs>): Prisma.PrismaPromise<GetMarket_potentielAggregateType<T>>

    /**
     * Group by Market_potentiel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_potentielGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends market_potentielGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: market_potentielGroupByArgs['orderBy'] }
        : { orderBy?: market_potentielGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, market_potentielGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarket_potentielGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the market_potentiel model
   */
  readonly fields: market_potentielFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for market_potentiel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__market_potentielClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the market_potentiel model
   */
  interface market_potentielFieldRefs {
    readonly id: FieldRef<"market_potentiel", 'BigInt'>
    readonly created_at: FieldRef<"market_potentiel", 'DateTime'>
    readonly city: FieldRef<"market_potentiel", 'String'>
    readonly potential_value: FieldRef<"market_potentiel", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * market_potentiel findUnique
   */
  export type market_potentielFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_potentiel
     */
    select?: market_potentielSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_potentiel
     */
    omit?: market_potentielOmit<ExtArgs> | null
    /**
     * Filter, which market_potentiel to fetch.
     */
    where: market_potentielWhereUniqueInput
  }

  /**
   * market_potentiel findUniqueOrThrow
   */
  export type market_potentielFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_potentiel
     */
    select?: market_potentielSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_potentiel
     */
    omit?: market_potentielOmit<ExtArgs> | null
    /**
     * Filter, which market_potentiel to fetch.
     */
    where: market_potentielWhereUniqueInput
  }

  /**
   * market_potentiel findFirst
   */
  export type market_potentielFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_potentiel
     */
    select?: market_potentielSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_potentiel
     */
    omit?: market_potentielOmit<ExtArgs> | null
    /**
     * Filter, which market_potentiel to fetch.
     */
    where?: market_potentielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_potentiels to fetch.
     */
    orderBy?: market_potentielOrderByWithRelationInput | market_potentielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for market_potentiels.
     */
    cursor?: market_potentielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_potentiels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_potentiels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of market_potentiels.
     */
    distinct?: Market_potentielScalarFieldEnum | Market_potentielScalarFieldEnum[]
  }

  /**
   * market_potentiel findFirstOrThrow
   */
  export type market_potentielFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_potentiel
     */
    select?: market_potentielSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_potentiel
     */
    omit?: market_potentielOmit<ExtArgs> | null
    /**
     * Filter, which market_potentiel to fetch.
     */
    where?: market_potentielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_potentiels to fetch.
     */
    orderBy?: market_potentielOrderByWithRelationInput | market_potentielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for market_potentiels.
     */
    cursor?: market_potentielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_potentiels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_potentiels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of market_potentiels.
     */
    distinct?: Market_potentielScalarFieldEnum | Market_potentielScalarFieldEnum[]
  }

  /**
   * market_potentiel findMany
   */
  export type market_potentielFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_potentiel
     */
    select?: market_potentielSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_potentiel
     */
    omit?: market_potentielOmit<ExtArgs> | null
    /**
     * Filter, which market_potentiels to fetch.
     */
    where?: market_potentielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_potentiels to fetch.
     */
    orderBy?: market_potentielOrderByWithRelationInput | market_potentielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing market_potentiels.
     */
    cursor?: market_potentielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_potentiels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_potentiels.
     */
    skip?: number
    distinct?: Market_potentielScalarFieldEnum | Market_potentielScalarFieldEnum[]
  }

  /**
   * market_potentiel create
   */
  export type market_potentielCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_potentiel
     */
    select?: market_potentielSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_potentiel
     */
    omit?: market_potentielOmit<ExtArgs> | null
    /**
     * The data needed to create a market_potentiel.
     */
    data: XOR<market_potentielCreateInput, market_potentielUncheckedCreateInput>
  }

  /**
   * market_potentiel createMany
   */
  export type market_potentielCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many market_potentiels.
     */
    data: market_potentielCreateManyInput | market_potentielCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * market_potentiel createManyAndReturn
   */
  export type market_potentielCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_potentiel
     */
    select?: market_potentielSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the market_potentiel
     */
    omit?: market_potentielOmit<ExtArgs> | null
    /**
     * The data used to create many market_potentiels.
     */
    data: market_potentielCreateManyInput | market_potentielCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * market_potentiel update
   */
  export type market_potentielUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_potentiel
     */
    select?: market_potentielSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_potentiel
     */
    omit?: market_potentielOmit<ExtArgs> | null
    /**
     * The data needed to update a market_potentiel.
     */
    data: XOR<market_potentielUpdateInput, market_potentielUncheckedUpdateInput>
    /**
     * Choose, which market_potentiel to update.
     */
    where: market_potentielWhereUniqueInput
  }

  /**
   * market_potentiel updateMany
   */
  export type market_potentielUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update market_potentiels.
     */
    data: XOR<market_potentielUpdateManyMutationInput, market_potentielUncheckedUpdateManyInput>
    /**
     * Filter which market_potentiels to update
     */
    where?: market_potentielWhereInput
    /**
     * Limit how many market_potentiels to update.
     */
    limit?: number
  }

  /**
   * market_potentiel updateManyAndReturn
   */
  export type market_potentielUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_potentiel
     */
    select?: market_potentielSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the market_potentiel
     */
    omit?: market_potentielOmit<ExtArgs> | null
    /**
     * The data used to update market_potentiels.
     */
    data: XOR<market_potentielUpdateManyMutationInput, market_potentielUncheckedUpdateManyInput>
    /**
     * Filter which market_potentiels to update
     */
    where?: market_potentielWhereInput
    /**
     * Limit how many market_potentiels to update.
     */
    limit?: number
  }

  /**
   * market_potentiel upsert
   */
  export type market_potentielUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_potentiel
     */
    select?: market_potentielSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_potentiel
     */
    omit?: market_potentielOmit<ExtArgs> | null
    /**
     * The filter to search for the market_potentiel to update in case it exists.
     */
    where: market_potentielWhereUniqueInput
    /**
     * In case the market_potentiel found by the `where` argument doesn't exist, create a new market_potentiel with this data.
     */
    create: XOR<market_potentielCreateInput, market_potentielUncheckedCreateInput>
    /**
     * In case the market_potentiel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<market_potentielUpdateInput, market_potentielUncheckedUpdateInput>
  }

  /**
   * market_potentiel delete
   */
  export type market_potentielDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_potentiel
     */
    select?: market_potentielSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_potentiel
     */
    omit?: market_potentielOmit<ExtArgs> | null
    /**
     * Filter which market_potentiel to delete.
     */
    where: market_potentielWhereUniqueInput
  }

  /**
   * market_potentiel deleteMany
   */
  export type market_potentielDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which market_potentiels to delete
     */
    where?: market_potentielWhereInput
    /**
     * Limit how many market_potentiels to delete.
     */
    limit?: number
  }

  /**
   * market_potentiel without action
   */
  export type market_potentielDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_potentiel
     */
    select?: market_potentielSelect<ExtArgs> | null
    /**
     * Omit specific fields from the market_potentiel
     */
    omit?: market_potentielOmit<ExtArgs> | null
  }


  /**
   * Model panne_history
   */

  export type AggregatePanne_history = {
    _count: Panne_historyCountAggregateOutputType | null
    _avg: Panne_historyAvgAggregateOutputType | null
    _sum: Panne_historySumAggregateOutputType | null
    _min: Panne_historyMinAggregateOutputType | null
    _max: Panne_historyMaxAggregateOutputType | null
  }

  export type Panne_historyAvgAggregateOutputType = {
    id: number | null
    alert_id: number | null
  }

  export type Panne_historySumAggregateOutputType = {
    id: number | null
    alert_id: number | null
  }

  export type Panne_historyMinAggregateOutputType = {
    id: number | null
    alert_id: number | null
  }

  export type Panne_historyMaxAggregateOutputType = {
    id: number | null
    alert_id: number | null
  }

  export type Panne_historyCountAggregateOutputType = {
    id: number
    alert_id: number
    _all: number
  }


  export type Panne_historyAvgAggregateInputType = {
    id?: true
    alert_id?: true
  }

  export type Panne_historySumAggregateInputType = {
    id?: true
    alert_id?: true
  }

  export type Panne_historyMinAggregateInputType = {
    id?: true
    alert_id?: true
  }

  export type Panne_historyMaxAggregateInputType = {
    id?: true
    alert_id?: true
  }

  export type Panne_historyCountAggregateInputType = {
    id?: true
    alert_id?: true
    _all?: true
  }

  export type Panne_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which panne_history to aggregate.
     */
    where?: panne_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of panne_histories to fetch.
     */
    orderBy?: panne_historyOrderByWithRelationInput | panne_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: panne_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` panne_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` panne_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned panne_histories
    **/
    _count?: true | Panne_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Panne_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Panne_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Panne_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Panne_historyMaxAggregateInputType
  }

  export type GetPanne_historyAggregateType<T extends Panne_historyAggregateArgs> = {
        [P in keyof T & keyof AggregatePanne_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePanne_history[P]>
      : GetScalarType<T[P], AggregatePanne_history[P]>
  }




  export type panne_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: panne_historyWhereInput
    orderBy?: panne_historyOrderByWithAggregationInput | panne_historyOrderByWithAggregationInput[]
    by: Panne_historyScalarFieldEnum[] | Panne_historyScalarFieldEnum
    having?: panne_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Panne_historyCountAggregateInputType | true
    _avg?: Panne_historyAvgAggregateInputType
    _sum?: Panne_historySumAggregateInputType
    _min?: Panne_historyMinAggregateInputType
    _max?: Panne_historyMaxAggregateInputType
  }

  export type Panne_historyGroupByOutputType = {
    id: number
    alert_id: number | null
    _count: Panne_historyCountAggregateOutputType | null
    _avg: Panne_historyAvgAggregateOutputType | null
    _sum: Panne_historySumAggregateOutputType | null
    _min: Panne_historyMinAggregateOutputType | null
    _max: Panne_historyMaxAggregateOutputType | null
  }

  type GetPanne_historyGroupByPayload<T extends panne_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Panne_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Panne_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Panne_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Panne_historyGroupByOutputType[P]>
        }
      >
    >


  export type panne_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alert_id?: boolean
    alert?: boolean | panne_history$alertArgs<ExtArgs>
  }, ExtArgs["result"]["panne_history"]>

  export type panne_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alert_id?: boolean
    alert?: boolean | panne_history$alertArgs<ExtArgs>
  }, ExtArgs["result"]["panne_history"]>

  export type panne_historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alert_id?: boolean
    alert?: boolean | panne_history$alertArgs<ExtArgs>
  }, ExtArgs["result"]["panne_history"]>

  export type panne_historySelectScalar = {
    id?: boolean
    alert_id?: boolean
  }

  export type panne_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "alert_id", ExtArgs["result"]["panne_history"]>
  export type panne_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | panne_history$alertArgs<ExtArgs>
  }
  export type panne_historyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | panne_history$alertArgs<ExtArgs>
  }
  export type panne_historyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | panne_history$alertArgs<ExtArgs>
  }

  export type $panne_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "panne_history"
    objects: {
      alert: Prisma.$alertPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      alert_id: number | null
    }, ExtArgs["result"]["panne_history"]>
    composites: {}
  }

  type panne_historyGetPayload<S extends boolean | null | undefined | panne_historyDefaultArgs> = $Result.GetResult<Prisma.$panne_historyPayload, S>

  type panne_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<panne_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Panne_historyCountAggregateInputType | true
    }

  export interface panne_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['panne_history'], meta: { name: 'panne_history' } }
    /**
     * Find zero or one Panne_history that matches the filter.
     * @param {panne_historyFindUniqueArgs} args - Arguments to find a Panne_history
     * @example
     * // Get one Panne_history
     * const panne_history = await prisma.panne_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends panne_historyFindUniqueArgs>(args: SelectSubset<T, panne_historyFindUniqueArgs<ExtArgs>>): Prisma__panne_historyClient<$Result.GetResult<Prisma.$panne_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Panne_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {panne_historyFindUniqueOrThrowArgs} args - Arguments to find a Panne_history
     * @example
     * // Get one Panne_history
     * const panne_history = await prisma.panne_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends panne_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, panne_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__panne_historyClient<$Result.GetResult<Prisma.$panne_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Panne_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panne_historyFindFirstArgs} args - Arguments to find a Panne_history
     * @example
     * // Get one Panne_history
     * const panne_history = await prisma.panne_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends panne_historyFindFirstArgs>(args?: SelectSubset<T, panne_historyFindFirstArgs<ExtArgs>>): Prisma__panne_historyClient<$Result.GetResult<Prisma.$panne_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Panne_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panne_historyFindFirstOrThrowArgs} args - Arguments to find a Panne_history
     * @example
     * // Get one Panne_history
     * const panne_history = await prisma.panne_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends panne_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, panne_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__panne_historyClient<$Result.GetResult<Prisma.$panne_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Panne_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panne_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Panne_histories
     * const panne_histories = await prisma.panne_history.findMany()
     * 
     * // Get first 10 Panne_histories
     * const panne_histories = await prisma.panne_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const panne_historyWithIdOnly = await prisma.panne_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends panne_historyFindManyArgs>(args?: SelectSubset<T, panne_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$panne_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Panne_history.
     * @param {panne_historyCreateArgs} args - Arguments to create a Panne_history.
     * @example
     * // Create one Panne_history
     * const Panne_history = await prisma.panne_history.create({
     *   data: {
     *     // ... data to create a Panne_history
     *   }
     * })
     * 
     */
    create<T extends panne_historyCreateArgs>(args: SelectSubset<T, panne_historyCreateArgs<ExtArgs>>): Prisma__panne_historyClient<$Result.GetResult<Prisma.$panne_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Panne_histories.
     * @param {panne_historyCreateManyArgs} args - Arguments to create many Panne_histories.
     * @example
     * // Create many Panne_histories
     * const panne_history = await prisma.panne_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends panne_historyCreateManyArgs>(args?: SelectSubset<T, panne_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Panne_histories and returns the data saved in the database.
     * @param {panne_historyCreateManyAndReturnArgs} args - Arguments to create many Panne_histories.
     * @example
     * // Create many Panne_histories
     * const panne_history = await prisma.panne_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Panne_histories and only return the `id`
     * const panne_historyWithIdOnly = await prisma.panne_history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends panne_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, panne_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$panne_historyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Panne_history.
     * @param {panne_historyDeleteArgs} args - Arguments to delete one Panne_history.
     * @example
     * // Delete one Panne_history
     * const Panne_history = await prisma.panne_history.delete({
     *   where: {
     *     // ... filter to delete one Panne_history
     *   }
     * })
     * 
     */
    delete<T extends panne_historyDeleteArgs>(args: SelectSubset<T, panne_historyDeleteArgs<ExtArgs>>): Prisma__panne_historyClient<$Result.GetResult<Prisma.$panne_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Panne_history.
     * @param {panne_historyUpdateArgs} args - Arguments to update one Panne_history.
     * @example
     * // Update one Panne_history
     * const panne_history = await prisma.panne_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends panne_historyUpdateArgs>(args: SelectSubset<T, panne_historyUpdateArgs<ExtArgs>>): Prisma__panne_historyClient<$Result.GetResult<Prisma.$panne_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Panne_histories.
     * @param {panne_historyDeleteManyArgs} args - Arguments to filter Panne_histories to delete.
     * @example
     * // Delete a few Panne_histories
     * const { count } = await prisma.panne_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends panne_historyDeleteManyArgs>(args?: SelectSubset<T, panne_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Panne_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panne_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Panne_histories
     * const panne_history = await prisma.panne_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends panne_historyUpdateManyArgs>(args: SelectSubset<T, panne_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Panne_histories and returns the data updated in the database.
     * @param {panne_historyUpdateManyAndReturnArgs} args - Arguments to update many Panne_histories.
     * @example
     * // Update many Panne_histories
     * const panne_history = await prisma.panne_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Panne_histories and only return the `id`
     * const panne_historyWithIdOnly = await prisma.panne_history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends panne_historyUpdateManyAndReturnArgs>(args: SelectSubset<T, panne_historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$panne_historyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Panne_history.
     * @param {panne_historyUpsertArgs} args - Arguments to update or create a Panne_history.
     * @example
     * // Update or create a Panne_history
     * const panne_history = await prisma.panne_history.upsert({
     *   create: {
     *     // ... data to create a Panne_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Panne_history we want to update
     *   }
     * })
     */
    upsert<T extends panne_historyUpsertArgs>(args: SelectSubset<T, panne_historyUpsertArgs<ExtArgs>>): Prisma__panne_historyClient<$Result.GetResult<Prisma.$panne_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Panne_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panne_historyCountArgs} args - Arguments to filter Panne_histories to count.
     * @example
     * // Count the number of Panne_histories
     * const count = await prisma.panne_history.count({
     *   where: {
     *     // ... the filter for the Panne_histories we want to count
     *   }
     * })
    **/
    count<T extends panne_historyCountArgs>(
      args?: Subset<T, panne_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Panne_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Panne_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Panne_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Panne_historyAggregateArgs>(args: Subset<T, Panne_historyAggregateArgs>): Prisma.PrismaPromise<GetPanne_historyAggregateType<T>>

    /**
     * Group by Panne_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panne_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends panne_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: panne_historyGroupByArgs['orderBy'] }
        : { orderBy?: panne_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, panne_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPanne_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the panne_history model
   */
  readonly fields: panne_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for panne_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__panne_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alert<T extends panne_history$alertArgs<ExtArgs> = {}>(args?: Subset<T, panne_history$alertArgs<ExtArgs>>): Prisma__alertClient<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the panne_history model
   */
  interface panne_historyFieldRefs {
    readonly id: FieldRef<"panne_history", 'Int'>
    readonly alert_id: FieldRef<"panne_history", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * panne_history findUnique
   */
  export type panne_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panne_history
     */
    select?: panne_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the panne_history
     */
    omit?: panne_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panne_historyInclude<ExtArgs> | null
    /**
     * Filter, which panne_history to fetch.
     */
    where: panne_historyWhereUniqueInput
  }

  /**
   * panne_history findUniqueOrThrow
   */
  export type panne_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panne_history
     */
    select?: panne_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the panne_history
     */
    omit?: panne_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panne_historyInclude<ExtArgs> | null
    /**
     * Filter, which panne_history to fetch.
     */
    where: panne_historyWhereUniqueInput
  }

  /**
   * panne_history findFirst
   */
  export type panne_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panne_history
     */
    select?: panne_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the panne_history
     */
    omit?: panne_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panne_historyInclude<ExtArgs> | null
    /**
     * Filter, which panne_history to fetch.
     */
    where?: panne_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of panne_histories to fetch.
     */
    orderBy?: panne_historyOrderByWithRelationInput | panne_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for panne_histories.
     */
    cursor?: panne_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` panne_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` panne_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of panne_histories.
     */
    distinct?: Panne_historyScalarFieldEnum | Panne_historyScalarFieldEnum[]
  }

  /**
   * panne_history findFirstOrThrow
   */
  export type panne_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panne_history
     */
    select?: panne_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the panne_history
     */
    omit?: panne_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panne_historyInclude<ExtArgs> | null
    /**
     * Filter, which panne_history to fetch.
     */
    where?: panne_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of panne_histories to fetch.
     */
    orderBy?: panne_historyOrderByWithRelationInput | panne_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for panne_histories.
     */
    cursor?: panne_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` panne_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` panne_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of panne_histories.
     */
    distinct?: Panne_historyScalarFieldEnum | Panne_historyScalarFieldEnum[]
  }

  /**
   * panne_history findMany
   */
  export type panne_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panne_history
     */
    select?: panne_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the panne_history
     */
    omit?: panne_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panne_historyInclude<ExtArgs> | null
    /**
     * Filter, which panne_histories to fetch.
     */
    where?: panne_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of panne_histories to fetch.
     */
    orderBy?: panne_historyOrderByWithRelationInput | panne_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing panne_histories.
     */
    cursor?: panne_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` panne_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` panne_histories.
     */
    skip?: number
    distinct?: Panne_historyScalarFieldEnum | Panne_historyScalarFieldEnum[]
  }

  /**
   * panne_history create
   */
  export type panne_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panne_history
     */
    select?: panne_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the panne_history
     */
    omit?: panne_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panne_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a panne_history.
     */
    data?: XOR<panne_historyCreateInput, panne_historyUncheckedCreateInput>
  }

  /**
   * panne_history createMany
   */
  export type panne_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many panne_histories.
     */
    data: panne_historyCreateManyInput | panne_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * panne_history createManyAndReturn
   */
  export type panne_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panne_history
     */
    select?: panne_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the panne_history
     */
    omit?: panne_historyOmit<ExtArgs> | null
    /**
     * The data used to create many panne_histories.
     */
    data: panne_historyCreateManyInput | panne_historyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panne_historyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * panne_history update
   */
  export type panne_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panne_history
     */
    select?: panne_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the panne_history
     */
    omit?: panne_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panne_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a panne_history.
     */
    data: XOR<panne_historyUpdateInput, panne_historyUncheckedUpdateInput>
    /**
     * Choose, which panne_history to update.
     */
    where: panne_historyWhereUniqueInput
  }

  /**
   * panne_history updateMany
   */
  export type panne_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update panne_histories.
     */
    data: XOR<panne_historyUpdateManyMutationInput, panne_historyUncheckedUpdateManyInput>
    /**
     * Filter which panne_histories to update
     */
    where?: panne_historyWhereInput
    /**
     * Limit how many panne_histories to update.
     */
    limit?: number
  }

  /**
   * panne_history updateManyAndReturn
   */
  export type panne_historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panne_history
     */
    select?: panne_historySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the panne_history
     */
    omit?: panne_historyOmit<ExtArgs> | null
    /**
     * The data used to update panne_histories.
     */
    data: XOR<panne_historyUpdateManyMutationInput, panne_historyUncheckedUpdateManyInput>
    /**
     * Filter which panne_histories to update
     */
    where?: panne_historyWhereInput
    /**
     * Limit how many panne_histories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panne_historyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * panne_history upsert
   */
  export type panne_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panne_history
     */
    select?: panne_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the panne_history
     */
    omit?: panne_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panne_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the panne_history to update in case it exists.
     */
    where: panne_historyWhereUniqueInput
    /**
     * In case the panne_history found by the `where` argument doesn't exist, create a new panne_history with this data.
     */
    create: XOR<panne_historyCreateInput, panne_historyUncheckedCreateInput>
    /**
     * In case the panne_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<panne_historyUpdateInput, panne_historyUncheckedUpdateInput>
  }

  /**
   * panne_history delete
   */
  export type panne_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panne_history
     */
    select?: panne_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the panne_history
     */
    omit?: panne_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panne_historyInclude<ExtArgs> | null
    /**
     * Filter which panne_history to delete.
     */
    where: panne_historyWhereUniqueInput
  }

  /**
   * panne_history deleteMany
   */
  export type panne_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which panne_histories to delete
     */
    where?: panne_historyWhereInput
    /**
     * Limit how many panne_histories to delete.
     */
    limit?: number
  }

  /**
   * panne_history.alert
   */
  export type panne_history$alertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alert
     */
    omit?: alertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    where?: alertWhereInput
  }

  /**
   * panne_history without action
   */
  export type panne_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panne_history
     */
    select?: panne_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the panne_history
     */
    omit?: panne_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panne_historyInclude<ExtArgs> | null
  }


  /**
   * Model poi
   */

  export type AggregatePoi = {
    _count: PoiCountAggregateOutputType | null
    _avg: PoiAvgAggregateOutputType | null
    _sum: PoiSumAggregateOutputType | null
    _min: PoiMinAggregateOutputType | null
    _max: PoiMaxAggregateOutputType | null
  }

  export type PoiAvgAggregateOutputType = {
    id: number | null
    env_id: number | null
    category_id: number | null
    map_id: number | null
  }

  export type PoiSumAggregateOutputType = {
    id: number | null
    env_id: number | null
    category_id: number | null
    map_id: number | null
  }

  export type PoiMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    env_id: number | null
    category_id: number | null
    name: string | null
    description: string | null
    image_url: string | null
    map_id: number | null
  }

  export type PoiMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    env_id: number | null
    category_id: number | null
    name: string | null
    description: string | null
    image_url: string | null
    map_id: number | null
  }

  export type PoiCountAggregateOutputType = {
    id: number
    created_at: number
    env_id: number
    category_id: number
    name: number
    description: number
    coordinates: number
    image_url: number
    map_id: number
    _all: number
  }


  export type PoiAvgAggregateInputType = {
    id?: true
    env_id?: true
    category_id?: true
    map_id?: true
  }

  export type PoiSumAggregateInputType = {
    id?: true
    env_id?: true
    category_id?: true
    map_id?: true
  }

  export type PoiMinAggregateInputType = {
    id?: true
    created_at?: true
    env_id?: true
    category_id?: true
    name?: true
    description?: true
    image_url?: true
    map_id?: true
  }

  export type PoiMaxAggregateInputType = {
    id?: true
    created_at?: true
    env_id?: true
    category_id?: true
    name?: true
    description?: true
    image_url?: true
    map_id?: true
  }

  export type PoiCountAggregateInputType = {
    id?: true
    created_at?: true
    env_id?: true
    category_id?: true
    name?: true
    description?: true
    coordinates?: true
    image_url?: true
    map_id?: true
    _all?: true
  }

  export type PoiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which poi to aggregate.
     */
    where?: poiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pois to fetch.
     */
    orderBy?: poiOrderByWithRelationInput | poiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: poiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pois
    **/
    _count?: true | PoiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PoiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PoiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PoiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PoiMaxAggregateInputType
  }

  export type GetPoiAggregateType<T extends PoiAggregateArgs> = {
        [P in keyof T & keyof AggregatePoi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoi[P]>
      : GetScalarType<T[P], AggregatePoi[P]>
  }




  export type poiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: poiWhereInput
    orderBy?: poiOrderByWithAggregationInput | poiOrderByWithAggregationInput[]
    by: PoiScalarFieldEnum[] | PoiScalarFieldEnum
    having?: poiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PoiCountAggregateInputType | true
    _avg?: PoiAvgAggregateInputType
    _sum?: PoiSumAggregateInputType
    _min?: PoiMinAggregateInputType
    _max?: PoiMaxAggregateInputType
  }

  export type PoiGroupByOutputType = {
    id: number
    created_at: Date
    env_id: number | null
    category_id: number | null
    name: string | null
    description: string | null
    coordinates: JsonValue | null
    image_url: string | null
    map_id: number | null
    _count: PoiCountAggregateOutputType | null
    _avg: PoiAvgAggregateOutputType | null
    _sum: PoiSumAggregateOutputType | null
    _min: PoiMinAggregateOutputType | null
    _max: PoiMaxAggregateOutputType | null
  }

  type GetPoiGroupByPayload<T extends poiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PoiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PoiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PoiGroupByOutputType[P]>
            : GetScalarType<T[P], PoiGroupByOutputType[P]>
        }
      >
    >


  export type poiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    env_id?: boolean
    category_id?: boolean
    name?: boolean
    description?: boolean
    coordinates?: boolean
    image_url?: boolean
    map_id?: boolean
    poi_category?: boolean | poi$poi_categoryArgs<ExtArgs>
    environment?: boolean | poi$environmentArgs<ExtArgs>
    map?: boolean | poi$mapArgs<ExtArgs>
    poi_zone?: boolean | poi$poi_zoneArgs<ExtArgs>
    _count?: boolean | PoiCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["poi"]>

  export type poiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    env_id?: boolean
    category_id?: boolean
    name?: boolean
    description?: boolean
    coordinates?: boolean
    image_url?: boolean
    map_id?: boolean
    poi_category?: boolean | poi$poi_categoryArgs<ExtArgs>
    environment?: boolean | poi$environmentArgs<ExtArgs>
    map?: boolean | poi$mapArgs<ExtArgs>
  }, ExtArgs["result"]["poi"]>

  export type poiSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    env_id?: boolean
    category_id?: boolean
    name?: boolean
    description?: boolean
    coordinates?: boolean
    image_url?: boolean
    map_id?: boolean
    poi_category?: boolean | poi$poi_categoryArgs<ExtArgs>
    environment?: boolean | poi$environmentArgs<ExtArgs>
    map?: boolean | poi$mapArgs<ExtArgs>
  }, ExtArgs["result"]["poi"]>

  export type poiSelectScalar = {
    id?: boolean
    created_at?: boolean
    env_id?: boolean
    category_id?: boolean
    name?: boolean
    description?: boolean
    coordinates?: boolean
    image_url?: boolean
    map_id?: boolean
  }

  export type poiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "env_id" | "category_id" | "name" | "description" | "coordinates" | "image_url" | "map_id", ExtArgs["result"]["poi"]>
  export type poiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poi_category?: boolean | poi$poi_categoryArgs<ExtArgs>
    environment?: boolean | poi$environmentArgs<ExtArgs>
    map?: boolean | poi$mapArgs<ExtArgs>
    poi_zone?: boolean | poi$poi_zoneArgs<ExtArgs>
    _count?: boolean | PoiCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type poiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poi_category?: boolean | poi$poi_categoryArgs<ExtArgs>
    environment?: boolean | poi$environmentArgs<ExtArgs>
    map?: boolean | poi$mapArgs<ExtArgs>
  }
  export type poiIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poi_category?: boolean | poi$poi_categoryArgs<ExtArgs>
    environment?: boolean | poi$environmentArgs<ExtArgs>
    map?: boolean | poi$mapArgs<ExtArgs>
  }

  export type $poiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "poi"
    objects: {
      poi_category: Prisma.$poi_categoryPayload<ExtArgs> | null
      environment: Prisma.$environmentPayload<ExtArgs> | null
      map: Prisma.$mapPayload<ExtArgs> | null
      poi_zone: Prisma.$poi_zonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_at: Date
      env_id: number | null
      category_id: number | null
      name: string | null
      description: string | null
      coordinates: Prisma.JsonValue | null
      image_url: string | null
      map_id: number | null
    }, ExtArgs["result"]["poi"]>
    composites: {}
  }

  type poiGetPayload<S extends boolean | null | undefined | poiDefaultArgs> = $Result.GetResult<Prisma.$poiPayload, S>

  type poiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<poiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PoiCountAggregateInputType | true
    }

  export interface poiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['poi'], meta: { name: 'poi' } }
    /**
     * Find zero or one Poi that matches the filter.
     * @param {poiFindUniqueArgs} args - Arguments to find a Poi
     * @example
     * // Get one Poi
     * const poi = await prisma.poi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends poiFindUniqueArgs>(args: SelectSubset<T, poiFindUniqueArgs<ExtArgs>>): Prisma__poiClient<$Result.GetResult<Prisma.$poiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Poi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {poiFindUniqueOrThrowArgs} args - Arguments to find a Poi
     * @example
     * // Get one Poi
     * const poi = await prisma.poi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends poiFindUniqueOrThrowArgs>(args: SelectSubset<T, poiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__poiClient<$Result.GetResult<Prisma.$poiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Poi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poiFindFirstArgs} args - Arguments to find a Poi
     * @example
     * // Get one Poi
     * const poi = await prisma.poi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends poiFindFirstArgs>(args?: SelectSubset<T, poiFindFirstArgs<ExtArgs>>): Prisma__poiClient<$Result.GetResult<Prisma.$poiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Poi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poiFindFirstOrThrowArgs} args - Arguments to find a Poi
     * @example
     * // Get one Poi
     * const poi = await prisma.poi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends poiFindFirstOrThrowArgs>(args?: SelectSubset<T, poiFindFirstOrThrowArgs<ExtArgs>>): Prisma__poiClient<$Result.GetResult<Prisma.$poiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pois that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pois
     * const pois = await prisma.poi.findMany()
     * 
     * // Get first 10 Pois
     * const pois = await prisma.poi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const poiWithIdOnly = await prisma.poi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends poiFindManyArgs>(args?: SelectSubset<T, poiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Poi.
     * @param {poiCreateArgs} args - Arguments to create a Poi.
     * @example
     * // Create one Poi
     * const Poi = await prisma.poi.create({
     *   data: {
     *     // ... data to create a Poi
     *   }
     * })
     * 
     */
    create<T extends poiCreateArgs>(args: SelectSubset<T, poiCreateArgs<ExtArgs>>): Prisma__poiClient<$Result.GetResult<Prisma.$poiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pois.
     * @param {poiCreateManyArgs} args - Arguments to create many Pois.
     * @example
     * // Create many Pois
     * const poi = await prisma.poi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends poiCreateManyArgs>(args?: SelectSubset<T, poiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pois and returns the data saved in the database.
     * @param {poiCreateManyAndReturnArgs} args - Arguments to create many Pois.
     * @example
     * // Create many Pois
     * const poi = await prisma.poi.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pois and only return the `id`
     * const poiWithIdOnly = await prisma.poi.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends poiCreateManyAndReturnArgs>(args?: SelectSubset<T, poiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poiPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Poi.
     * @param {poiDeleteArgs} args - Arguments to delete one Poi.
     * @example
     * // Delete one Poi
     * const Poi = await prisma.poi.delete({
     *   where: {
     *     // ... filter to delete one Poi
     *   }
     * })
     * 
     */
    delete<T extends poiDeleteArgs>(args: SelectSubset<T, poiDeleteArgs<ExtArgs>>): Prisma__poiClient<$Result.GetResult<Prisma.$poiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Poi.
     * @param {poiUpdateArgs} args - Arguments to update one Poi.
     * @example
     * // Update one Poi
     * const poi = await prisma.poi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends poiUpdateArgs>(args: SelectSubset<T, poiUpdateArgs<ExtArgs>>): Prisma__poiClient<$Result.GetResult<Prisma.$poiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pois.
     * @param {poiDeleteManyArgs} args - Arguments to filter Pois to delete.
     * @example
     * // Delete a few Pois
     * const { count } = await prisma.poi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends poiDeleteManyArgs>(args?: SelectSubset<T, poiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pois
     * const poi = await prisma.poi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends poiUpdateManyArgs>(args: SelectSubset<T, poiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pois and returns the data updated in the database.
     * @param {poiUpdateManyAndReturnArgs} args - Arguments to update many Pois.
     * @example
     * // Update many Pois
     * const poi = await prisma.poi.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pois and only return the `id`
     * const poiWithIdOnly = await prisma.poi.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends poiUpdateManyAndReturnArgs>(args: SelectSubset<T, poiUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poiPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Poi.
     * @param {poiUpsertArgs} args - Arguments to update or create a Poi.
     * @example
     * // Update or create a Poi
     * const poi = await prisma.poi.upsert({
     *   create: {
     *     // ... data to create a Poi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Poi we want to update
     *   }
     * })
     */
    upsert<T extends poiUpsertArgs>(args: SelectSubset<T, poiUpsertArgs<ExtArgs>>): Prisma__poiClient<$Result.GetResult<Prisma.$poiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poiCountArgs} args - Arguments to filter Pois to count.
     * @example
     * // Count the number of Pois
     * const count = await prisma.poi.count({
     *   where: {
     *     // ... the filter for the Pois we want to count
     *   }
     * })
    **/
    count<T extends poiCountArgs>(
      args?: Subset<T, poiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PoiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Poi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PoiAggregateArgs>(args: Subset<T, PoiAggregateArgs>): Prisma.PrismaPromise<GetPoiAggregateType<T>>

    /**
     * Group by Poi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends poiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: poiGroupByArgs['orderBy'] }
        : { orderBy?: poiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, poiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPoiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the poi model
   */
  readonly fields: poiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for poi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__poiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    poi_category<T extends poi$poi_categoryArgs<ExtArgs> = {}>(args?: Subset<T, poi$poi_categoryArgs<ExtArgs>>): Prisma__poi_categoryClient<$Result.GetResult<Prisma.$poi_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    environment<T extends poi$environmentArgs<ExtArgs> = {}>(args?: Subset<T, poi$environmentArgs<ExtArgs>>): Prisma__environmentClient<$Result.GetResult<Prisma.$environmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    map<T extends poi$mapArgs<ExtArgs> = {}>(args?: Subset<T, poi$mapArgs<ExtArgs>>): Prisma__mapClient<$Result.GetResult<Prisma.$mapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    poi_zone<T extends poi$poi_zoneArgs<ExtArgs> = {}>(args?: Subset<T, poi$poi_zoneArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poi_zonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the poi model
   */
  interface poiFieldRefs {
    readonly id: FieldRef<"poi", 'Int'>
    readonly created_at: FieldRef<"poi", 'DateTime'>
    readonly env_id: FieldRef<"poi", 'Int'>
    readonly category_id: FieldRef<"poi", 'Int'>
    readonly name: FieldRef<"poi", 'String'>
    readonly description: FieldRef<"poi", 'String'>
    readonly coordinates: FieldRef<"poi", 'Json'>
    readonly image_url: FieldRef<"poi", 'String'>
    readonly map_id: FieldRef<"poi", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * poi findUnique
   */
  export type poiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi
     */
    select?: poiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi
     */
    omit?: poiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poiInclude<ExtArgs> | null
    /**
     * Filter, which poi to fetch.
     */
    where: poiWhereUniqueInput
  }

  /**
   * poi findUniqueOrThrow
   */
  export type poiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi
     */
    select?: poiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi
     */
    omit?: poiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poiInclude<ExtArgs> | null
    /**
     * Filter, which poi to fetch.
     */
    where: poiWhereUniqueInput
  }

  /**
   * poi findFirst
   */
  export type poiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi
     */
    select?: poiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi
     */
    omit?: poiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poiInclude<ExtArgs> | null
    /**
     * Filter, which poi to fetch.
     */
    where?: poiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pois to fetch.
     */
    orderBy?: poiOrderByWithRelationInput | poiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pois.
     */
    cursor?: poiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pois.
     */
    distinct?: PoiScalarFieldEnum | PoiScalarFieldEnum[]
  }

  /**
   * poi findFirstOrThrow
   */
  export type poiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi
     */
    select?: poiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi
     */
    omit?: poiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poiInclude<ExtArgs> | null
    /**
     * Filter, which poi to fetch.
     */
    where?: poiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pois to fetch.
     */
    orderBy?: poiOrderByWithRelationInput | poiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pois.
     */
    cursor?: poiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pois.
     */
    distinct?: PoiScalarFieldEnum | PoiScalarFieldEnum[]
  }

  /**
   * poi findMany
   */
  export type poiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi
     */
    select?: poiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi
     */
    omit?: poiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poiInclude<ExtArgs> | null
    /**
     * Filter, which pois to fetch.
     */
    where?: poiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pois to fetch.
     */
    orderBy?: poiOrderByWithRelationInput | poiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pois.
     */
    cursor?: poiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pois.
     */
    skip?: number
    distinct?: PoiScalarFieldEnum | PoiScalarFieldEnum[]
  }

  /**
   * poi create
   */
  export type poiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi
     */
    select?: poiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi
     */
    omit?: poiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poiInclude<ExtArgs> | null
    /**
     * The data needed to create a poi.
     */
    data?: XOR<poiCreateInput, poiUncheckedCreateInput>
  }

  /**
   * poi createMany
   */
  export type poiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pois.
     */
    data: poiCreateManyInput | poiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * poi createManyAndReturn
   */
  export type poiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi
     */
    select?: poiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the poi
     */
    omit?: poiOmit<ExtArgs> | null
    /**
     * The data used to create many pois.
     */
    data: poiCreateManyInput | poiCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poiIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * poi update
   */
  export type poiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi
     */
    select?: poiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi
     */
    omit?: poiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poiInclude<ExtArgs> | null
    /**
     * The data needed to update a poi.
     */
    data: XOR<poiUpdateInput, poiUncheckedUpdateInput>
    /**
     * Choose, which poi to update.
     */
    where: poiWhereUniqueInput
  }

  /**
   * poi updateMany
   */
  export type poiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pois.
     */
    data: XOR<poiUpdateManyMutationInput, poiUncheckedUpdateManyInput>
    /**
     * Filter which pois to update
     */
    where?: poiWhereInput
    /**
     * Limit how many pois to update.
     */
    limit?: number
  }

  /**
   * poi updateManyAndReturn
   */
  export type poiUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi
     */
    select?: poiSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the poi
     */
    omit?: poiOmit<ExtArgs> | null
    /**
     * The data used to update pois.
     */
    data: XOR<poiUpdateManyMutationInput, poiUncheckedUpdateManyInput>
    /**
     * Filter which pois to update
     */
    where?: poiWhereInput
    /**
     * Limit how many pois to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poiIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * poi upsert
   */
  export type poiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi
     */
    select?: poiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi
     */
    omit?: poiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poiInclude<ExtArgs> | null
    /**
     * The filter to search for the poi to update in case it exists.
     */
    where: poiWhereUniqueInput
    /**
     * In case the poi found by the `where` argument doesn't exist, create a new poi with this data.
     */
    create: XOR<poiCreateInput, poiUncheckedCreateInput>
    /**
     * In case the poi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<poiUpdateInput, poiUncheckedUpdateInput>
  }

  /**
   * poi delete
   */
  export type poiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi
     */
    select?: poiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi
     */
    omit?: poiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poiInclude<ExtArgs> | null
    /**
     * Filter which poi to delete.
     */
    where: poiWhereUniqueInput
  }

  /**
   * poi deleteMany
   */
  export type poiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pois to delete
     */
    where?: poiWhereInput
    /**
     * Limit how many pois to delete.
     */
    limit?: number
  }

  /**
   * poi.poi_category
   */
  export type poi$poi_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_category
     */
    select?: poi_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_category
     */
    omit?: poi_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_categoryInclude<ExtArgs> | null
    where?: poi_categoryWhereInput
  }

  /**
   * poi.environment
   */
  export type poi$environmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the environment
     */
    select?: environmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the environment
     */
    omit?: environmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: environmentInclude<ExtArgs> | null
    where?: environmentWhereInput
  }

  /**
   * poi.map
   */
  export type poi$mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the map
     */
    select?: mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the map
     */
    omit?: mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mapInclude<ExtArgs> | null
    where?: mapWhereInput
  }

  /**
   * poi.poi_zone
   */
  export type poi$poi_zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_zone
     */
    select?: poi_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_zone
     */
    omit?: poi_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_zoneInclude<ExtArgs> | null
    where?: poi_zoneWhereInput
    orderBy?: poi_zoneOrderByWithRelationInput | poi_zoneOrderByWithRelationInput[]
    cursor?: poi_zoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Poi_zoneScalarFieldEnum | Poi_zoneScalarFieldEnum[]
  }

  /**
   * poi without action
   */
  export type poiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi
     */
    select?: poiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi
     */
    omit?: poiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poiInclude<ExtArgs> | null
  }


  /**
   * Model poi_category
   */

  export type AggregatePoi_category = {
    _count: Poi_categoryCountAggregateOutputType | null
    _avg: Poi_categoryAvgAggregateOutputType | null
    _sum: Poi_categorySumAggregateOutputType | null
    _min: Poi_categoryMinAggregateOutputType | null
    _max: Poi_categoryMaxAggregateOutputType | null
  }

  export type Poi_categoryAvgAggregateOutputType = {
    id: number | null
  }

  export type Poi_categorySumAggregateOutputType = {
    id: number | null
  }

  export type Poi_categoryMinAggregateOutputType = {
    id: number | null
    category: string | null
  }

  export type Poi_categoryMaxAggregateOutputType = {
    id: number | null
    category: string | null
  }

  export type Poi_categoryCountAggregateOutputType = {
    id: number
    category: number
    _all: number
  }


  export type Poi_categoryAvgAggregateInputType = {
    id?: true
  }

  export type Poi_categorySumAggregateInputType = {
    id?: true
  }

  export type Poi_categoryMinAggregateInputType = {
    id?: true
    category?: true
  }

  export type Poi_categoryMaxAggregateInputType = {
    id?: true
    category?: true
  }

  export type Poi_categoryCountAggregateInputType = {
    id?: true
    category?: true
    _all?: true
  }

  export type Poi_categoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which poi_category to aggregate.
     */
    where?: poi_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poi_categories to fetch.
     */
    orderBy?: poi_categoryOrderByWithRelationInput | poi_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: poi_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poi_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poi_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned poi_categories
    **/
    _count?: true | Poi_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Poi_categoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Poi_categorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Poi_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Poi_categoryMaxAggregateInputType
  }

  export type GetPoi_categoryAggregateType<T extends Poi_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePoi_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoi_category[P]>
      : GetScalarType<T[P], AggregatePoi_category[P]>
  }




  export type poi_categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: poi_categoryWhereInput
    orderBy?: poi_categoryOrderByWithAggregationInput | poi_categoryOrderByWithAggregationInput[]
    by: Poi_categoryScalarFieldEnum[] | Poi_categoryScalarFieldEnum
    having?: poi_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Poi_categoryCountAggregateInputType | true
    _avg?: Poi_categoryAvgAggregateInputType
    _sum?: Poi_categorySumAggregateInputType
    _min?: Poi_categoryMinAggregateInputType
    _max?: Poi_categoryMaxAggregateInputType
  }

  export type Poi_categoryGroupByOutputType = {
    id: number
    category: string
    _count: Poi_categoryCountAggregateOutputType | null
    _avg: Poi_categoryAvgAggregateOutputType | null
    _sum: Poi_categorySumAggregateOutputType | null
    _min: Poi_categoryMinAggregateOutputType | null
    _max: Poi_categoryMaxAggregateOutputType | null
  }

  type GetPoi_categoryGroupByPayload<T extends poi_categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Poi_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Poi_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Poi_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Poi_categoryGroupByOutputType[P]>
        }
      >
    >


  export type poi_categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    poi?: boolean | poi_category$poiArgs<ExtArgs>
    _count?: boolean | Poi_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["poi_category"]>

  export type poi_categorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
  }, ExtArgs["result"]["poi_category"]>

  export type poi_categorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
  }, ExtArgs["result"]["poi_category"]>

  export type poi_categorySelectScalar = {
    id?: boolean
    category?: boolean
  }

  export type poi_categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category", ExtArgs["result"]["poi_category"]>
  export type poi_categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poi?: boolean | poi_category$poiArgs<ExtArgs>
    _count?: boolean | Poi_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type poi_categoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type poi_categoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $poi_categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "poi_category"
    objects: {
      poi: Prisma.$poiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category: string
    }, ExtArgs["result"]["poi_category"]>
    composites: {}
  }

  type poi_categoryGetPayload<S extends boolean | null | undefined | poi_categoryDefaultArgs> = $Result.GetResult<Prisma.$poi_categoryPayload, S>

  type poi_categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<poi_categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Poi_categoryCountAggregateInputType | true
    }

  export interface poi_categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['poi_category'], meta: { name: 'poi_category' } }
    /**
     * Find zero or one Poi_category that matches the filter.
     * @param {poi_categoryFindUniqueArgs} args - Arguments to find a Poi_category
     * @example
     * // Get one Poi_category
     * const poi_category = await prisma.poi_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends poi_categoryFindUniqueArgs>(args: SelectSubset<T, poi_categoryFindUniqueArgs<ExtArgs>>): Prisma__poi_categoryClient<$Result.GetResult<Prisma.$poi_categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Poi_category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {poi_categoryFindUniqueOrThrowArgs} args - Arguments to find a Poi_category
     * @example
     * // Get one Poi_category
     * const poi_category = await prisma.poi_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends poi_categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, poi_categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__poi_categoryClient<$Result.GetResult<Prisma.$poi_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Poi_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poi_categoryFindFirstArgs} args - Arguments to find a Poi_category
     * @example
     * // Get one Poi_category
     * const poi_category = await prisma.poi_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends poi_categoryFindFirstArgs>(args?: SelectSubset<T, poi_categoryFindFirstArgs<ExtArgs>>): Prisma__poi_categoryClient<$Result.GetResult<Prisma.$poi_categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Poi_category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poi_categoryFindFirstOrThrowArgs} args - Arguments to find a Poi_category
     * @example
     * // Get one Poi_category
     * const poi_category = await prisma.poi_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends poi_categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, poi_categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__poi_categoryClient<$Result.GetResult<Prisma.$poi_categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Poi_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poi_categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Poi_categories
     * const poi_categories = await prisma.poi_category.findMany()
     * 
     * // Get first 10 Poi_categories
     * const poi_categories = await prisma.poi_category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const poi_categoryWithIdOnly = await prisma.poi_category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends poi_categoryFindManyArgs>(args?: SelectSubset<T, poi_categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poi_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Poi_category.
     * @param {poi_categoryCreateArgs} args - Arguments to create a Poi_category.
     * @example
     * // Create one Poi_category
     * const Poi_category = await prisma.poi_category.create({
     *   data: {
     *     // ... data to create a Poi_category
     *   }
     * })
     * 
     */
    create<T extends poi_categoryCreateArgs>(args: SelectSubset<T, poi_categoryCreateArgs<ExtArgs>>): Prisma__poi_categoryClient<$Result.GetResult<Prisma.$poi_categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Poi_categories.
     * @param {poi_categoryCreateManyArgs} args - Arguments to create many Poi_categories.
     * @example
     * // Create many Poi_categories
     * const poi_category = await prisma.poi_category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends poi_categoryCreateManyArgs>(args?: SelectSubset<T, poi_categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Poi_categories and returns the data saved in the database.
     * @param {poi_categoryCreateManyAndReturnArgs} args - Arguments to create many Poi_categories.
     * @example
     * // Create many Poi_categories
     * const poi_category = await prisma.poi_category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Poi_categories and only return the `id`
     * const poi_categoryWithIdOnly = await prisma.poi_category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends poi_categoryCreateManyAndReturnArgs>(args?: SelectSubset<T, poi_categoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poi_categoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Poi_category.
     * @param {poi_categoryDeleteArgs} args - Arguments to delete one Poi_category.
     * @example
     * // Delete one Poi_category
     * const Poi_category = await prisma.poi_category.delete({
     *   where: {
     *     // ... filter to delete one Poi_category
     *   }
     * })
     * 
     */
    delete<T extends poi_categoryDeleteArgs>(args: SelectSubset<T, poi_categoryDeleteArgs<ExtArgs>>): Prisma__poi_categoryClient<$Result.GetResult<Prisma.$poi_categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Poi_category.
     * @param {poi_categoryUpdateArgs} args - Arguments to update one Poi_category.
     * @example
     * // Update one Poi_category
     * const poi_category = await prisma.poi_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends poi_categoryUpdateArgs>(args: SelectSubset<T, poi_categoryUpdateArgs<ExtArgs>>): Prisma__poi_categoryClient<$Result.GetResult<Prisma.$poi_categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Poi_categories.
     * @param {poi_categoryDeleteManyArgs} args - Arguments to filter Poi_categories to delete.
     * @example
     * // Delete a few Poi_categories
     * const { count } = await prisma.poi_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends poi_categoryDeleteManyArgs>(args?: SelectSubset<T, poi_categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Poi_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poi_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Poi_categories
     * const poi_category = await prisma.poi_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends poi_categoryUpdateManyArgs>(args: SelectSubset<T, poi_categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Poi_categories and returns the data updated in the database.
     * @param {poi_categoryUpdateManyAndReturnArgs} args - Arguments to update many Poi_categories.
     * @example
     * // Update many Poi_categories
     * const poi_category = await prisma.poi_category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Poi_categories and only return the `id`
     * const poi_categoryWithIdOnly = await prisma.poi_category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends poi_categoryUpdateManyAndReturnArgs>(args: SelectSubset<T, poi_categoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poi_categoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Poi_category.
     * @param {poi_categoryUpsertArgs} args - Arguments to update or create a Poi_category.
     * @example
     * // Update or create a Poi_category
     * const poi_category = await prisma.poi_category.upsert({
     *   create: {
     *     // ... data to create a Poi_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Poi_category we want to update
     *   }
     * })
     */
    upsert<T extends poi_categoryUpsertArgs>(args: SelectSubset<T, poi_categoryUpsertArgs<ExtArgs>>): Prisma__poi_categoryClient<$Result.GetResult<Prisma.$poi_categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Poi_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poi_categoryCountArgs} args - Arguments to filter Poi_categories to count.
     * @example
     * // Count the number of Poi_categories
     * const count = await prisma.poi_category.count({
     *   where: {
     *     // ... the filter for the Poi_categories we want to count
     *   }
     * })
    **/
    count<T extends poi_categoryCountArgs>(
      args?: Subset<T, poi_categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Poi_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Poi_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Poi_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Poi_categoryAggregateArgs>(args: Subset<T, Poi_categoryAggregateArgs>): Prisma.PrismaPromise<GetPoi_categoryAggregateType<T>>

    /**
     * Group by Poi_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poi_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends poi_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: poi_categoryGroupByArgs['orderBy'] }
        : { orderBy?: poi_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, poi_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPoi_categoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the poi_category model
   */
  readonly fields: poi_categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for poi_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__poi_categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    poi<T extends poi_category$poiArgs<ExtArgs> = {}>(args?: Subset<T, poi_category$poiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the poi_category model
   */
  interface poi_categoryFieldRefs {
    readonly id: FieldRef<"poi_category", 'Int'>
    readonly category: FieldRef<"poi_category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * poi_category findUnique
   */
  export type poi_categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_category
     */
    select?: poi_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_category
     */
    omit?: poi_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_categoryInclude<ExtArgs> | null
    /**
     * Filter, which poi_category to fetch.
     */
    where: poi_categoryWhereUniqueInput
  }

  /**
   * poi_category findUniqueOrThrow
   */
  export type poi_categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_category
     */
    select?: poi_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_category
     */
    omit?: poi_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_categoryInclude<ExtArgs> | null
    /**
     * Filter, which poi_category to fetch.
     */
    where: poi_categoryWhereUniqueInput
  }

  /**
   * poi_category findFirst
   */
  export type poi_categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_category
     */
    select?: poi_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_category
     */
    omit?: poi_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_categoryInclude<ExtArgs> | null
    /**
     * Filter, which poi_category to fetch.
     */
    where?: poi_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poi_categories to fetch.
     */
    orderBy?: poi_categoryOrderByWithRelationInput | poi_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for poi_categories.
     */
    cursor?: poi_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poi_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poi_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of poi_categories.
     */
    distinct?: Poi_categoryScalarFieldEnum | Poi_categoryScalarFieldEnum[]
  }

  /**
   * poi_category findFirstOrThrow
   */
  export type poi_categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_category
     */
    select?: poi_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_category
     */
    omit?: poi_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_categoryInclude<ExtArgs> | null
    /**
     * Filter, which poi_category to fetch.
     */
    where?: poi_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poi_categories to fetch.
     */
    orderBy?: poi_categoryOrderByWithRelationInput | poi_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for poi_categories.
     */
    cursor?: poi_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poi_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poi_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of poi_categories.
     */
    distinct?: Poi_categoryScalarFieldEnum | Poi_categoryScalarFieldEnum[]
  }

  /**
   * poi_category findMany
   */
  export type poi_categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_category
     */
    select?: poi_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_category
     */
    omit?: poi_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_categoryInclude<ExtArgs> | null
    /**
     * Filter, which poi_categories to fetch.
     */
    where?: poi_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poi_categories to fetch.
     */
    orderBy?: poi_categoryOrderByWithRelationInput | poi_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing poi_categories.
     */
    cursor?: poi_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poi_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poi_categories.
     */
    skip?: number
    distinct?: Poi_categoryScalarFieldEnum | Poi_categoryScalarFieldEnum[]
  }

  /**
   * poi_category create
   */
  export type poi_categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_category
     */
    select?: poi_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_category
     */
    omit?: poi_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a poi_category.
     */
    data: XOR<poi_categoryCreateInput, poi_categoryUncheckedCreateInput>
  }

  /**
   * poi_category createMany
   */
  export type poi_categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many poi_categories.
     */
    data: poi_categoryCreateManyInput | poi_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * poi_category createManyAndReturn
   */
  export type poi_categoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_category
     */
    select?: poi_categorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the poi_category
     */
    omit?: poi_categoryOmit<ExtArgs> | null
    /**
     * The data used to create many poi_categories.
     */
    data: poi_categoryCreateManyInput | poi_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * poi_category update
   */
  export type poi_categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_category
     */
    select?: poi_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_category
     */
    omit?: poi_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a poi_category.
     */
    data: XOR<poi_categoryUpdateInput, poi_categoryUncheckedUpdateInput>
    /**
     * Choose, which poi_category to update.
     */
    where: poi_categoryWhereUniqueInput
  }

  /**
   * poi_category updateMany
   */
  export type poi_categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update poi_categories.
     */
    data: XOR<poi_categoryUpdateManyMutationInput, poi_categoryUncheckedUpdateManyInput>
    /**
     * Filter which poi_categories to update
     */
    where?: poi_categoryWhereInput
    /**
     * Limit how many poi_categories to update.
     */
    limit?: number
  }

  /**
   * poi_category updateManyAndReturn
   */
  export type poi_categoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_category
     */
    select?: poi_categorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the poi_category
     */
    omit?: poi_categoryOmit<ExtArgs> | null
    /**
     * The data used to update poi_categories.
     */
    data: XOR<poi_categoryUpdateManyMutationInput, poi_categoryUncheckedUpdateManyInput>
    /**
     * Filter which poi_categories to update
     */
    where?: poi_categoryWhereInput
    /**
     * Limit how many poi_categories to update.
     */
    limit?: number
  }

  /**
   * poi_category upsert
   */
  export type poi_categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_category
     */
    select?: poi_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_category
     */
    omit?: poi_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the poi_category to update in case it exists.
     */
    where: poi_categoryWhereUniqueInput
    /**
     * In case the poi_category found by the `where` argument doesn't exist, create a new poi_category with this data.
     */
    create: XOR<poi_categoryCreateInput, poi_categoryUncheckedCreateInput>
    /**
     * In case the poi_category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<poi_categoryUpdateInput, poi_categoryUncheckedUpdateInput>
  }

  /**
   * poi_category delete
   */
  export type poi_categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_category
     */
    select?: poi_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_category
     */
    omit?: poi_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_categoryInclude<ExtArgs> | null
    /**
     * Filter which poi_category to delete.
     */
    where: poi_categoryWhereUniqueInput
  }

  /**
   * poi_category deleteMany
   */
  export type poi_categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which poi_categories to delete
     */
    where?: poi_categoryWhereInput
    /**
     * Limit how many poi_categories to delete.
     */
    limit?: number
  }

  /**
   * poi_category.poi
   */
  export type poi_category$poiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi
     */
    select?: poiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi
     */
    omit?: poiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poiInclude<ExtArgs> | null
    where?: poiWhereInput
    orderBy?: poiOrderByWithRelationInput | poiOrderByWithRelationInput[]
    cursor?: poiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PoiScalarFieldEnum | PoiScalarFieldEnum[]
  }

  /**
   * poi_category without action
   */
  export type poi_categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_category
     */
    select?: poi_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_category
     */
    omit?: poi_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_categoryInclude<ExtArgs> | null
  }


  /**
   * Model poi_zone
   */

  export type AggregatePoi_zone = {
    _count: Poi_zoneCountAggregateOutputType | null
    _avg: Poi_zoneAvgAggregateOutputType | null
    _sum: Poi_zoneSumAggregateOutputType | null
    _min: Poi_zoneMinAggregateOutputType | null
    _max: Poi_zoneMaxAggregateOutputType | null
  }

  export type Poi_zoneAvgAggregateOutputType = {
    id: number | null
    poi_id: number | null
    zone_id: number | null
  }

  export type Poi_zoneSumAggregateOutputType = {
    id: number | null
    poi_id: number | null
    zone_id: number | null
  }

  export type Poi_zoneMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    poi_id: number | null
    zone_id: number | null
  }

  export type Poi_zoneMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    poi_id: number | null
    zone_id: number | null
  }

  export type Poi_zoneCountAggregateOutputType = {
    id: number
    created_at: number
    poi_id: number
    zone_id: number
    _all: number
  }


  export type Poi_zoneAvgAggregateInputType = {
    id?: true
    poi_id?: true
    zone_id?: true
  }

  export type Poi_zoneSumAggregateInputType = {
    id?: true
    poi_id?: true
    zone_id?: true
  }

  export type Poi_zoneMinAggregateInputType = {
    id?: true
    created_at?: true
    poi_id?: true
    zone_id?: true
  }

  export type Poi_zoneMaxAggregateInputType = {
    id?: true
    created_at?: true
    poi_id?: true
    zone_id?: true
  }

  export type Poi_zoneCountAggregateInputType = {
    id?: true
    created_at?: true
    poi_id?: true
    zone_id?: true
    _all?: true
  }

  export type Poi_zoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which poi_zone to aggregate.
     */
    where?: poi_zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poi_zones to fetch.
     */
    orderBy?: poi_zoneOrderByWithRelationInput | poi_zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: poi_zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poi_zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poi_zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned poi_zones
    **/
    _count?: true | Poi_zoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Poi_zoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Poi_zoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Poi_zoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Poi_zoneMaxAggregateInputType
  }

  export type GetPoi_zoneAggregateType<T extends Poi_zoneAggregateArgs> = {
        [P in keyof T & keyof AggregatePoi_zone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoi_zone[P]>
      : GetScalarType<T[P], AggregatePoi_zone[P]>
  }




  export type poi_zoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: poi_zoneWhereInput
    orderBy?: poi_zoneOrderByWithAggregationInput | poi_zoneOrderByWithAggregationInput[]
    by: Poi_zoneScalarFieldEnum[] | Poi_zoneScalarFieldEnum
    having?: poi_zoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Poi_zoneCountAggregateInputType | true
    _avg?: Poi_zoneAvgAggregateInputType
    _sum?: Poi_zoneSumAggregateInputType
    _min?: Poi_zoneMinAggregateInputType
    _max?: Poi_zoneMaxAggregateInputType
  }

  export type Poi_zoneGroupByOutputType = {
    id: number
    created_at: Date
    poi_id: number | null
    zone_id: number | null
    _count: Poi_zoneCountAggregateOutputType | null
    _avg: Poi_zoneAvgAggregateOutputType | null
    _sum: Poi_zoneSumAggregateOutputType | null
    _min: Poi_zoneMinAggregateOutputType | null
    _max: Poi_zoneMaxAggregateOutputType | null
  }

  type GetPoi_zoneGroupByPayload<T extends poi_zoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Poi_zoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Poi_zoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Poi_zoneGroupByOutputType[P]>
            : GetScalarType<T[P], Poi_zoneGroupByOutputType[P]>
        }
      >
    >


  export type poi_zoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    poi_id?: boolean
    zone_id?: boolean
    poi?: boolean | poi_zone$poiArgs<ExtArgs>
    zone?: boolean | poi_zone$zoneArgs<ExtArgs>
  }, ExtArgs["result"]["poi_zone"]>

  export type poi_zoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    poi_id?: boolean
    zone_id?: boolean
    poi?: boolean | poi_zone$poiArgs<ExtArgs>
    zone?: boolean | poi_zone$zoneArgs<ExtArgs>
  }, ExtArgs["result"]["poi_zone"]>

  export type poi_zoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    poi_id?: boolean
    zone_id?: boolean
    poi?: boolean | poi_zone$poiArgs<ExtArgs>
    zone?: boolean | poi_zone$zoneArgs<ExtArgs>
  }, ExtArgs["result"]["poi_zone"]>

  export type poi_zoneSelectScalar = {
    id?: boolean
    created_at?: boolean
    poi_id?: boolean
    zone_id?: boolean
  }

  export type poi_zoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "poi_id" | "zone_id", ExtArgs["result"]["poi_zone"]>
  export type poi_zoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poi?: boolean | poi_zone$poiArgs<ExtArgs>
    zone?: boolean | poi_zone$zoneArgs<ExtArgs>
  }
  export type poi_zoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poi?: boolean | poi_zone$poiArgs<ExtArgs>
    zone?: boolean | poi_zone$zoneArgs<ExtArgs>
  }
  export type poi_zoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poi?: boolean | poi_zone$poiArgs<ExtArgs>
    zone?: boolean | poi_zone$zoneArgs<ExtArgs>
  }

  export type $poi_zonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "poi_zone"
    objects: {
      poi: Prisma.$poiPayload<ExtArgs> | null
      zone: Prisma.$zonePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_at: Date
      poi_id: number | null
      zone_id: number | null
    }, ExtArgs["result"]["poi_zone"]>
    composites: {}
  }

  type poi_zoneGetPayload<S extends boolean | null | undefined | poi_zoneDefaultArgs> = $Result.GetResult<Prisma.$poi_zonePayload, S>

  type poi_zoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<poi_zoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Poi_zoneCountAggregateInputType | true
    }

  export interface poi_zoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['poi_zone'], meta: { name: 'poi_zone' } }
    /**
     * Find zero or one Poi_zone that matches the filter.
     * @param {poi_zoneFindUniqueArgs} args - Arguments to find a Poi_zone
     * @example
     * // Get one Poi_zone
     * const poi_zone = await prisma.poi_zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends poi_zoneFindUniqueArgs>(args: SelectSubset<T, poi_zoneFindUniqueArgs<ExtArgs>>): Prisma__poi_zoneClient<$Result.GetResult<Prisma.$poi_zonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Poi_zone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {poi_zoneFindUniqueOrThrowArgs} args - Arguments to find a Poi_zone
     * @example
     * // Get one Poi_zone
     * const poi_zone = await prisma.poi_zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends poi_zoneFindUniqueOrThrowArgs>(args: SelectSubset<T, poi_zoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__poi_zoneClient<$Result.GetResult<Prisma.$poi_zonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Poi_zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poi_zoneFindFirstArgs} args - Arguments to find a Poi_zone
     * @example
     * // Get one Poi_zone
     * const poi_zone = await prisma.poi_zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends poi_zoneFindFirstArgs>(args?: SelectSubset<T, poi_zoneFindFirstArgs<ExtArgs>>): Prisma__poi_zoneClient<$Result.GetResult<Prisma.$poi_zonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Poi_zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poi_zoneFindFirstOrThrowArgs} args - Arguments to find a Poi_zone
     * @example
     * // Get one Poi_zone
     * const poi_zone = await prisma.poi_zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends poi_zoneFindFirstOrThrowArgs>(args?: SelectSubset<T, poi_zoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__poi_zoneClient<$Result.GetResult<Prisma.$poi_zonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Poi_zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poi_zoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Poi_zones
     * const poi_zones = await prisma.poi_zone.findMany()
     * 
     * // Get first 10 Poi_zones
     * const poi_zones = await prisma.poi_zone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const poi_zoneWithIdOnly = await prisma.poi_zone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends poi_zoneFindManyArgs>(args?: SelectSubset<T, poi_zoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poi_zonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Poi_zone.
     * @param {poi_zoneCreateArgs} args - Arguments to create a Poi_zone.
     * @example
     * // Create one Poi_zone
     * const Poi_zone = await prisma.poi_zone.create({
     *   data: {
     *     // ... data to create a Poi_zone
     *   }
     * })
     * 
     */
    create<T extends poi_zoneCreateArgs>(args: SelectSubset<T, poi_zoneCreateArgs<ExtArgs>>): Prisma__poi_zoneClient<$Result.GetResult<Prisma.$poi_zonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Poi_zones.
     * @param {poi_zoneCreateManyArgs} args - Arguments to create many Poi_zones.
     * @example
     * // Create many Poi_zones
     * const poi_zone = await prisma.poi_zone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends poi_zoneCreateManyArgs>(args?: SelectSubset<T, poi_zoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Poi_zones and returns the data saved in the database.
     * @param {poi_zoneCreateManyAndReturnArgs} args - Arguments to create many Poi_zones.
     * @example
     * // Create many Poi_zones
     * const poi_zone = await prisma.poi_zone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Poi_zones and only return the `id`
     * const poi_zoneWithIdOnly = await prisma.poi_zone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends poi_zoneCreateManyAndReturnArgs>(args?: SelectSubset<T, poi_zoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poi_zonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Poi_zone.
     * @param {poi_zoneDeleteArgs} args - Arguments to delete one Poi_zone.
     * @example
     * // Delete one Poi_zone
     * const Poi_zone = await prisma.poi_zone.delete({
     *   where: {
     *     // ... filter to delete one Poi_zone
     *   }
     * })
     * 
     */
    delete<T extends poi_zoneDeleteArgs>(args: SelectSubset<T, poi_zoneDeleteArgs<ExtArgs>>): Prisma__poi_zoneClient<$Result.GetResult<Prisma.$poi_zonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Poi_zone.
     * @param {poi_zoneUpdateArgs} args - Arguments to update one Poi_zone.
     * @example
     * // Update one Poi_zone
     * const poi_zone = await prisma.poi_zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends poi_zoneUpdateArgs>(args: SelectSubset<T, poi_zoneUpdateArgs<ExtArgs>>): Prisma__poi_zoneClient<$Result.GetResult<Prisma.$poi_zonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Poi_zones.
     * @param {poi_zoneDeleteManyArgs} args - Arguments to filter Poi_zones to delete.
     * @example
     * // Delete a few Poi_zones
     * const { count } = await prisma.poi_zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends poi_zoneDeleteManyArgs>(args?: SelectSubset<T, poi_zoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Poi_zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poi_zoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Poi_zones
     * const poi_zone = await prisma.poi_zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends poi_zoneUpdateManyArgs>(args: SelectSubset<T, poi_zoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Poi_zones and returns the data updated in the database.
     * @param {poi_zoneUpdateManyAndReturnArgs} args - Arguments to update many Poi_zones.
     * @example
     * // Update many Poi_zones
     * const poi_zone = await prisma.poi_zone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Poi_zones and only return the `id`
     * const poi_zoneWithIdOnly = await prisma.poi_zone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends poi_zoneUpdateManyAndReturnArgs>(args: SelectSubset<T, poi_zoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poi_zonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Poi_zone.
     * @param {poi_zoneUpsertArgs} args - Arguments to update or create a Poi_zone.
     * @example
     * // Update or create a Poi_zone
     * const poi_zone = await prisma.poi_zone.upsert({
     *   create: {
     *     // ... data to create a Poi_zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Poi_zone we want to update
     *   }
     * })
     */
    upsert<T extends poi_zoneUpsertArgs>(args: SelectSubset<T, poi_zoneUpsertArgs<ExtArgs>>): Prisma__poi_zoneClient<$Result.GetResult<Prisma.$poi_zonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Poi_zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poi_zoneCountArgs} args - Arguments to filter Poi_zones to count.
     * @example
     * // Count the number of Poi_zones
     * const count = await prisma.poi_zone.count({
     *   where: {
     *     // ... the filter for the Poi_zones we want to count
     *   }
     * })
    **/
    count<T extends poi_zoneCountArgs>(
      args?: Subset<T, poi_zoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Poi_zoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Poi_zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Poi_zoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Poi_zoneAggregateArgs>(args: Subset<T, Poi_zoneAggregateArgs>): Prisma.PrismaPromise<GetPoi_zoneAggregateType<T>>

    /**
     * Group by Poi_zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {poi_zoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends poi_zoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: poi_zoneGroupByArgs['orderBy'] }
        : { orderBy?: poi_zoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, poi_zoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPoi_zoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the poi_zone model
   */
  readonly fields: poi_zoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for poi_zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__poi_zoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    poi<T extends poi_zone$poiArgs<ExtArgs> = {}>(args?: Subset<T, poi_zone$poiArgs<ExtArgs>>): Prisma__poiClient<$Result.GetResult<Prisma.$poiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    zone<T extends poi_zone$zoneArgs<ExtArgs> = {}>(args?: Subset<T, poi_zone$zoneArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the poi_zone model
   */
  interface poi_zoneFieldRefs {
    readonly id: FieldRef<"poi_zone", 'Int'>
    readonly created_at: FieldRef<"poi_zone", 'DateTime'>
    readonly poi_id: FieldRef<"poi_zone", 'Int'>
    readonly zone_id: FieldRef<"poi_zone", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * poi_zone findUnique
   */
  export type poi_zoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_zone
     */
    select?: poi_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_zone
     */
    omit?: poi_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_zoneInclude<ExtArgs> | null
    /**
     * Filter, which poi_zone to fetch.
     */
    where: poi_zoneWhereUniqueInput
  }

  /**
   * poi_zone findUniqueOrThrow
   */
  export type poi_zoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_zone
     */
    select?: poi_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_zone
     */
    omit?: poi_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_zoneInclude<ExtArgs> | null
    /**
     * Filter, which poi_zone to fetch.
     */
    where: poi_zoneWhereUniqueInput
  }

  /**
   * poi_zone findFirst
   */
  export type poi_zoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_zone
     */
    select?: poi_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_zone
     */
    omit?: poi_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_zoneInclude<ExtArgs> | null
    /**
     * Filter, which poi_zone to fetch.
     */
    where?: poi_zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poi_zones to fetch.
     */
    orderBy?: poi_zoneOrderByWithRelationInput | poi_zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for poi_zones.
     */
    cursor?: poi_zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poi_zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poi_zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of poi_zones.
     */
    distinct?: Poi_zoneScalarFieldEnum | Poi_zoneScalarFieldEnum[]
  }

  /**
   * poi_zone findFirstOrThrow
   */
  export type poi_zoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_zone
     */
    select?: poi_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_zone
     */
    omit?: poi_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_zoneInclude<ExtArgs> | null
    /**
     * Filter, which poi_zone to fetch.
     */
    where?: poi_zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poi_zones to fetch.
     */
    orderBy?: poi_zoneOrderByWithRelationInput | poi_zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for poi_zones.
     */
    cursor?: poi_zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poi_zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poi_zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of poi_zones.
     */
    distinct?: Poi_zoneScalarFieldEnum | Poi_zoneScalarFieldEnum[]
  }

  /**
   * poi_zone findMany
   */
  export type poi_zoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_zone
     */
    select?: poi_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_zone
     */
    omit?: poi_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_zoneInclude<ExtArgs> | null
    /**
     * Filter, which poi_zones to fetch.
     */
    where?: poi_zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of poi_zones to fetch.
     */
    orderBy?: poi_zoneOrderByWithRelationInput | poi_zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing poi_zones.
     */
    cursor?: poi_zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` poi_zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` poi_zones.
     */
    skip?: number
    distinct?: Poi_zoneScalarFieldEnum | Poi_zoneScalarFieldEnum[]
  }

  /**
   * poi_zone create
   */
  export type poi_zoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_zone
     */
    select?: poi_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_zone
     */
    omit?: poi_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_zoneInclude<ExtArgs> | null
    /**
     * The data needed to create a poi_zone.
     */
    data?: XOR<poi_zoneCreateInput, poi_zoneUncheckedCreateInput>
  }

  /**
   * poi_zone createMany
   */
  export type poi_zoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many poi_zones.
     */
    data: poi_zoneCreateManyInput | poi_zoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * poi_zone createManyAndReturn
   */
  export type poi_zoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_zone
     */
    select?: poi_zoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the poi_zone
     */
    omit?: poi_zoneOmit<ExtArgs> | null
    /**
     * The data used to create many poi_zones.
     */
    data: poi_zoneCreateManyInput | poi_zoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_zoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * poi_zone update
   */
  export type poi_zoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_zone
     */
    select?: poi_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_zone
     */
    omit?: poi_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_zoneInclude<ExtArgs> | null
    /**
     * The data needed to update a poi_zone.
     */
    data: XOR<poi_zoneUpdateInput, poi_zoneUncheckedUpdateInput>
    /**
     * Choose, which poi_zone to update.
     */
    where: poi_zoneWhereUniqueInput
  }

  /**
   * poi_zone updateMany
   */
  export type poi_zoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update poi_zones.
     */
    data: XOR<poi_zoneUpdateManyMutationInput, poi_zoneUncheckedUpdateManyInput>
    /**
     * Filter which poi_zones to update
     */
    where?: poi_zoneWhereInput
    /**
     * Limit how many poi_zones to update.
     */
    limit?: number
  }

  /**
   * poi_zone updateManyAndReturn
   */
  export type poi_zoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_zone
     */
    select?: poi_zoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the poi_zone
     */
    omit?: poi_zoneOmit<ExtArgs> | null
    /**
     * The data used to update poi_zones.
     */
    data: XOR<poi_zoneUpdateManyMutationInput, poi_zoneUncheckedUpdateManyInput>
    /**
     * Filter which poi_zones to update
     */
    where?: poi_zoneWhereInput
    /**
     * Limit how many poi_zones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_zoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * poi_zone upsert
   */
  export type poi_zoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_zone
     */
    select?: poi_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_zone
     */
    omit?: poi_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_zoneInclude<ExtArgs> | null
    /**
     * The filter to search for the poi_zone to update in case it exists.
     */
    where: poi_zoneWhereUniqueInput
    /**
     * In case the poi_zone found by the `where` argument doesn't exist, create a new poi_zone with this data.
     */
    create: XOR<poi_zoneCreateInput, poi_zoneUncheckedCreateInput>
    /**
     * In case the poi_zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<poi_zoneUpdateInput, poi_zoneUncheckedUpdateInput>
  }

  /**
   * poi_zone delete
   */
  export type poi_zoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_zone
     */
    select?: poi_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_zone
     */
    omit?: poi_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_zoneInclude<ExtArgs> | null
    /**
     * Filter which poi_zone to delete.
     */
    where: poi_zoneWhereUniqueInput
  }

  /**
   * poi_zone deleteMany
   */
  export type poi_zoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which poi_zones to delete
     */
    where?: poi_zoneWhereInput
    /**
     * Limit how many poi_zones to delete.
     */
    limit?: number
  }

  /**
   * poi_zone.poi
   */
  export type poi_zone$poiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi
     */
    select?: poiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi
     */
    omit?: poiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poiInclude<ExtArgs> | null
    where?: poiWhereInput
  }

  /**
   * poi_zone.zone
   */
  export type poi_zone$zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    where?: zoneWhereInput
  }

  /**
   * poi_zone without action
   */
  export type poi_zoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_zone
     */
    select?: poi_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_zone
     */
    omit?: poi_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_zoneInclude<ExtArgs> | null
  }


  /**
   * Model pricing
   */

  export type AggregatePricing = {
    _count: PricingCountAggregateOutputType | null
    _avg: PricingAvgAggregateOutputType | null
    _sum: PricingSumAggregateOutputType | null
    _min: PricingMinAggregateOutputType | null
    _max: PricingMaxAggregateOutputType | null
  }

  export type PricingAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type PricingSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type PricingMinAggregateOutputType = {
    id: number | null
    attribute: string | null
    price: number | null
  }

  export type PricingMaxAggregateOutputType = {
    id: number | null
    attribute: string | null
    price: number | null
  }

  export type PricingCountAggregateOutputType = {
    id: number
    attribute: number
    price: number
    _all: number
  }


  export type PricingAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type PricingSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type PricingMinAggregateInputType = {
    id?: true
    attribute?: true
    price?: true
  }

  export type PricingMaxAggregateInputType = {
    id?: true
    attribute?: true
    price?: true
  }

  export type PricingCountAggregateInputType = {
    id?: true
    attribute?: true
    price?: true
    _all?: true
  }

  export type PricingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pricing to aggregate.
     */
    where?: pricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricings to fetch.
     */
    orderBy?: pricingOrderByWithRelationInput | pricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pricings
    **/
    _count?: true | PricingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricingMaxAggregateInputType
  }

  export type GetPricingAggregateType<T extends PricingAggregateArgs> = {
        [P in keyof T & keyof AggregatePricing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricing[P]>
      : GetScalarType<T[P], AggregatePricing[P]>
  }




  export type pricingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pricingWhereInput
    orderBy?: pricingOrderByWithAggregationInput | pricingOrderByWithAggregationInput[]
    by: PricingScalarFieldEnum[] | PricingScalarFieldEnum
    having?: pricingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricingCountAggregateInputType | true
    _avg?: PricingAvgAggregateInputType
    _sum?: PricingSumAggregateInputType
    _min?: PricingMinAggregateInputType
    _max?: PricingMaxAggregateInputType
  }

  export type PricingGroupByOutputType = {
    id: number
    attribute: string | null
    price: number | null
    _count: PricingCountAggregateOutputType | null
    _avg: PricingAvgAggregateOutputType | null
    _sum: PricingSumAggregateOutputType | null
    _min: PricingMinAggregateOutputType | null
    _max: PricingMaxAggregateOutputType | null
  }

  type GetPricingGroupByPayload<T extends pricingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PricingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricingGroupByOutputType[P]>
            : GetScalarType<T[P], PricingGroupByOutputType[P]>
        }
      >
    >


  export type pricingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attribute?: boolean
    price?: boolean
  }, ExtArgs["result"]["pricing"]>

  export type pricingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attribute?: boolean
    price?: boolean
  }, ExtArgs["result"]["pricing"]>

  export type pricingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attribute?: boolean
    price?: boolean
  }, ExtArgs["result"]["pricing"]>

  export type pricingSelectScalar = {
    id?: boolean
    attribute?: boolean
    price?: boolean
  }

  export type pricingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "attribute" | "price", ExtArgs["result"]["pricing"]>

  export type $pricingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pricing"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      attribute: string | null
      price: number | null
    }, ExtArgs["result"]["pricing"]>
    composites: {}
  }

  type pricingGetPayload<S extends boolean | null | undefined | pricingDefaultArgs> = $Result.GetResult<Prisma.$pricingPayload, S>

  type pricingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pricingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PricingCountAggregateInputType | true
    }

  export interface pricingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pricing'], meta: { name: 'pricing' } }
    /**
     * Find zero or one Pricing that matches the filter.
     * @param {pricingFindUniqueArgs} args - Arguments to find a Pricing
     * @example
     * // Get one Pricing
     * const pricing = await prisma.pricing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pricingFindUniqueArgs>(args: SelectSubset<T, pricingFindUniqueArgs<ExtArgs>>): Prisma__pricingClient<$Result.GetResult<Prisma.$pricingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pricing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pricingFindUniqueOrThrowArgs} args - Arguments to find a Pricing
     * @example
     * // Get one Pricing
     * const pricing = await prisma.pricing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pricingFindUniqueOrThrowArgs>(args: SelectSubset<T, pricingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pricingClient<$Result.GetResult<Prisma.$pricingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pricing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingFindFirstArgs} args - Arguments to find a Pricing
     * @example
     * // Get one Pricing
     * const pricing = await prisma.pricing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pricingFindFirstArgs>(args?: SelectSubset<T, pricingFindFirstArgs<ExtArgs>>): Prisma__pricingClient<$Result.GetResult<Prisma.$pricingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pricing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingFindFirstOrThrowArgs} args - Arguments to find a Pricing
     * @example
     * // Get one Pricing
     * const pricing = await prisma.pricing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pricingFindFirstOrThrowArgs>(args?: SelectSubset<T, pricingFindFirstOrThrowArgs<ExtArgs>>): Prisma__pricingClient<$Result.GetResult<Prisma.$pricingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pricings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pricings
     * const pricings = await prisma.pricing.findMany()
     * 
     * // Get first 10 Pricings
     * const pricings = await prisma.pricing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pricingWithIdOnly = await prisma.pricing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pricingFindManyArgs>(args?: SelectSubset<T, pricingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pricingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pricing.
     * @param {pricingCreateArgs} args - Arguments to create a Pricing.
     * @example
     * // Create one Pricing
     * const Pricing = await prisma.pricing.create({
     *   data: {
     *     // ... data to create a Pricing
     *   }
     * })
     * 
     */
    create<T extends pricingCreateArgs>(args: SelectSubset<T, pricingCreateArgs<ExtArgs>>): Prisma__pricingClient<$Result.GetResult<Prisma.$pricingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pricings.
     * @param {pricingCreateManyArgs} args - Arguments to create many Pricings.
     * @example
     * // Create many Pricings
     * const pricing = await prisma.pricing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pricingCreateManyArgs>(args?: SelectSubset<T, pricingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pricings and returns the data saved in the database.
     * @param {pricingCreateManyAndReturnArgs} args - Arguments to create many Pricings.
     * @example
     * // Create many Pricings
     * const pricing = await prisma.pricing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pricings and only return the `id`
     * const pricingWithIdOnly = await prisma.pricing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pricingCreateManyAndReturnArgs>(args?: SelectSubset<T, pricingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pricingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pricing.
     * @param {pricingDeleteArgs} args - Arguments to delete one Pricing.
     * @example
     * // Delete one Pricing
     * const Pricing = await prisma.pricing.delete({
     *   where: {
     *     // ... filter to delete one Pricing
     *   }
     * })
     * 
     */
    delete<T extends pricingDeleteArgs>(args: SelectSubset<T, pricingDeleteArgs<ExtArgs>>): Prisma__pricingClient<$Result.GetResult<Prisma.$pricingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pricing.
     * @param {pricingUpdateArgs} args - Arguments to update one Pricing.
     * @example
     * // Update one Pricing
     * const pricing = await prisma.pricing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pricingUpdateArgs>(args: SelectSubset<T, pricingUpdateArgs<ExtArgs>>): Prisma__pricingClient<$Result.GetResult<Prisma.$pricingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pricings.
     * @param {pricingDeleteManyArgs} args - Arguments to filter Pricings to delete.
     * @example
     * // Delete a few Pricings
     * const { count } = await prisma.pricing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pricingDeleteManyArgs>(args?: SelectSubset<T, pricingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pricings
     * const pricing = await prisma.pricing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pricingUpdateManyArgs>(args: SelectSubset<T, pricingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pricings and returns the data updated in the database.
     * @param {pricingUpdateManyAndReturnArgs} args - Arguments to update many Pricings.
     * @example
     * // Update many Pricings
     * const pricing = await prisma.pricing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pricings and only return the `id`
     * const pricingWithIdOnly = await prisma.pricing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pricingUpdateManyAndReturnArgs>(args: SelectSubset<T, pricingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pricingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pricing.
     * @param {pricingUpsertArgs} args - Arguments to update or create a Pricing.
     * @example
     * // Update or create a Pricing
     * const pricing = await prisma.pricing.upsert({
     *   create: {
     *     // ... data to create a Pricing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pricing we want to update
     *   }
     * })
     */
    upsert<T extends pricingUpsertArgs>(args: SelectSubset<T, pricingUpsertArgs<ExtArgs>>): Prisma__pricingClient<$Result.GetResult<Prisma.$pricingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingCountArgs} args - Arguments to filter Pricings to count.
     * @example
     * // Count the number of Pricings
     * const count = await prisma.pricing.count({
     *   where: {
     *     // ... the filter for the Pricings we want to count
     *   }
     * })
    **/
    count<T extends pricingCountArgs>(
      args?: Subset<T, pricingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricingAggregateArgs>(args: Subset<T, PricingAggregateArgs>): Prisma.PrismaPromise<GetPricingAggregateType<T>>

    /**
     * Group by Pricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pricingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pricingGroupByArgs['orderBy'] }
        : { orderBy?: pricingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pricingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pricing model
   */
  readonly fields: pricingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pricing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pricingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pricing model
   */
  interface pricingFieldRefs {
    readonly id: FieldRef<"pricing", 'Int'>
    readonly attribute: FieldRef<"pricing", 'String'>
    readonly price: FieldRef<"pricing", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * pricing findUnique
   */
  export type pricingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing
     */
    select?: pricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pricing
     */
    omit?: pricingOmit<ExtArgs> | null
    /**
     * Filter, which pricing to fetch.
     */
    where: pricingWhereUniqueInput
  }

  /**
   * pricing findUniqueOrThrow
   */
  export type pricingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing
     */
    select?: pricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pricing
     */
    omit?: pricingOmit<ExtArgs> | null
    /**
     * Filter, which pricing to fetch.
     */
    where: pricingWhereUniqueInput
  }

  /**
   * pricing findFirst
   */
  export type pricingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing
     */
    select?: pricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pricing
     */
    omit?: pricingOmit<ExtArgs> | null
    /**
     * Filter, which pricing to fetch.
     */
    where?: pricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricings to fetch.
     */
    orderBy?: pricingOrderByWithRelationInput | pricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricings.
     */
    cursor?: pricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricings.
     */
    distinct?: PricingScalarFieldEnum | PricingScalarFieldEnum[]
  }

  /**
   * pricing findFirstOrThrow
   */
  export type pricingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing
     */
    select?: pricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pricing
     */
    omit?: pricingOmit<ExtArgs> | null
    /**
     * Filter, which pricing to fetch.
     */
    where?: pricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricings to fetch.
     */
    orderBy?: pricingOrderByWithRelationInput | pricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricings.
     */
    cursor?: pricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricings.
     */
    distinct?: PricingScalarFieldEnum | PricingScalarFieldEnum[]
  }

  /**
   * pricing findMany
   */
  export type pricingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing
     */
    select?: pricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pricing
     */
    omit?: pricingOmit<ExtArgs> | null
    /**
     * Filter, which pricings to fetch.
     */
    where?: pricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricings to fetch.
     */
    orderBy?: pricingOrderByWithRelationInput | pricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pricings.
     */
    cursor?: pricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricings.
     */
    skip?: number
    distinct?: PricingScalarFieldEnum | PricingScalarFieldEnum[]
  }

  /**
   * pricing create
   */
  export type pricingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing
     */
    select?: pricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pricing
     */
    omit?: pricingOmit<ExtArgs> | null
    /**
     * The data needed to create a pricing.
     */
    data?: XOR<pricingCreateInput, pricingUncheckedCreateInput>
  }

  /**
   * pricing createMany
   */
  export type pricingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pricings.
     */
    data: pricingCreateManyInput | pricingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pricing createManyAndReturn
   */
  export type pricingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing
     */
    select?: pricingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pricing
     */
    omit?: pricingOmit<ExtArgs> | null
    /**
     * The data used to create many pricings.
     */
    data: pricingCreateManyInput | pricingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pricing update
   */
  export type pricingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing
     */
    select?: pricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pricing
     */
    omit?: pricingOmit<ExtArgs> | null
    /**
     * The data needed to update a pricing.
     */
    data: XOR<pricingUpdateInput, pricingUncheckedUpdateInput>
    /**
     * Choose, which pricing to update.
     */
    where: pricingWhereUniqueInput
  }

  /**
   * pricing updateMany
   */
  export type pricingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pricings.
     */
    data: XOR<pricingUpdateManyMutationInput, pricingUncheckedUpdateManyInput>
    /**
     * Filter which pricings to update
     */
    where?: pricingWhereInput
    /**
     * Limit how many pricings to update.
     */
    limit?: number
  }

  /**
   * pricing updateManyAndReturn
   */
  export type pricingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing
     */
    select?: pricingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pricing
     */
    omit?: pricingOmit<ExtArgs> | null
    /**
     * The data used to update pricings.
     */
    data: XOR<pricingUpdateManyMutationInput, pricingUncheckedUpdateManyInput>
    /**
     * Filter which pricings to update
     */
    where?: pricingWhereInput
    /**
     * Limit how many pricings to update.
     */
    limit?: number
  }

  /**
   * pricing upsert
   */
  export type pricingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing
     */
    select?: pricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pricing
     */
    omit?: pricingOmit<ExtArgs> | null
    /**
     * The filter to search for the pricing to update in case it exists.
     */
    where: pricingWhereUniqueInput
    /**
     * In case the pricing found by the `where` argument doesn't exist, create a new pricing with this data.
     */
    create: XOR<pricingCreateInput, pricingUncheckedCreateInput>
    /**
     * In case the pricing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pricingUpdateInput, pricingUncheckedUpdateInput>
  }

  /**
   * pricing delete
   */
  export type pricingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing
     */
    select?: pricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pricing
     */
    omit?: pricingOmit<ExtArgs> | null
    /**
     * Filter which pricing to delete.
     */
    where: pricingWhereUniqueInput
  }

  /**
   * pricing deleteMany
   */
  export type pricingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pricings to delete
     */
    where?: pricingWhereInput
    /**
     * Limit how many pricings to delete.
     */
    limit?: number
  }

  /**
   * pricing without action
   */
  export type pricingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricing
     */
    select?: pricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pricing
     */
    omit?: pricingOmit<ExtArgs> | null
  }


  /**
   * Model purchase_history
   */

  export type AggregatePurchase_history = {
    _count: Purchase_historyCountAggregateOutputType | null
    _avg: Purchase_historyAvgAggregateOutputType | null
    _sum: Purchase_historySumAggregateOutputType | null
    _min: Purchase_historyMinAggregateOutputType | null
    _max: Purchase_historyMaxAggregateOutputType | null
  }

  export type Purchase_historyAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    device_id: number | null
  }

  export type Purchase_historySumAggregateOutputType = {
    id: number | null
    user_id: number | null
    device_id: number | null
  }

  export type Purchase_historyMinAggregateOutputType = {
    id: number | null
    date: Date | null
    user_id: number | null
    device_id: number | null
    public: boolean | null
  }

  export type Purchase_historyMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    user_id: number | null
    device_id: number | null
    public: boolean | null
  }

  export type Purchase_historyCountAggregateOutputType = {
    id: number
    date: number
    user_id: number
    device_id: number
    public: number
    _all: number
  }


  export type Purchase_historyAvgAggregateInputType = {
    id?: true
    user_id?: true
    device_id?: true
  }

  export type Purchase_historySumAggregateInputType = {
    id?: true
    user_id?: true
    device_id?: true
  }

  export type Purchase_historyMinAggregateInputType = {
    id?: true
    date?: true
    user_id?: true
    device_id?: true
    public?: true
  }

  export type Purchase_historyMaxAggregateInputType = {
    id?: true
    date?: true
    user_id?: true
    device_id?: true
    public?: true
  }

  export type Purchase_historyCountAggregateInputType = {
    id?: true
    date?: true
    user_id?: true
    device_id?: true
    public?: true
    _all?: true
  }

  export type Purchase_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which purchase_history to aggregate.
     */
    where?: purchase_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchase_histories to fetch.
     */
    orderBy?: purchase_historyOrderByWithRelationInput | purchase_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: purchase_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchase_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchase_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned purchase_histories
    **/
    _count?: true | Purchase_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Purchase_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Purchase_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Purchase_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Purchase_historyMaxAggregateInputType
  }

  export type GetPurchase_historyAggregateType<T extends Purchase_historyAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase_history[P]>
      : GetScalarType<T[P], AggregatePurchase_history[P]>
  }




  export type purchase_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: purchase_historyWhereInput
    orderBy?: purchase_historyOrderByWithAggregationInput | purchase_historyOrderByWithAggregationInput[]
    by: Purchase_historyScalarFieldEnum[] | Purchase_historyScalarFieldEnum
    having?: purchase_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Purchase_historyCountAggregateInputType | true
    _avg?: Purchase_historyAvgAggregateInputType
    _sum?: Purchase_historySumAggregateInputType
    _min?: Purchase_historyMinAggregateInputType
    _max?: Purchase_historyMaxAggregateInputType
  }

  export type Purchase_historyGroupByOutputType = {
    id: number
    date: Date
    user_id: number | null
    device_id: number | null
    public: boolean | null
    _count: Purchase_historyCountAggregateOutputType | null
    _avg: Purchase_historyAvgAggregateOutputType | null
    _sum: Purchase_historySumAggregateOutputType | null
    _min: Purchase_historyMinAggregateOutputType | null
    _max: Purchase_historyMaxAggregateOutputType | null
  }

  type GetPurchase_historyGroupByPayload<T extends purchase_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Purchase_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Purchase_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Purchase_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Purchase_historyGroupByOutputType[P]>
        }
      >
    >


  export type purchase_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    user_id?: boolean
    device_id?: boolean
    public?: boolean
    device?: boolean | purchase_history$deviceArgs<ExtArgs>
    user?: boolean | purchase_history$userArgs<ExtArgs>
  }, ExtArgs["result"]["purchase_history"]>

  export type purchase_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    user_id?: boolean
    device_id?: boolean
    public?: boolean
    device?: boolean | purchase_history$deviceArgs<ExtArgs>
    user?: boolean | purchase_history$userArgs<ExtArgs>
  }, ExtArgs["result"]["purchase_history"]>

  export type purchase_historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    user_id?: boolean
    device_id?: boolean
    public?: boolean
    device?: boolean | purchase_history$deviceArgs<ExtArgs>
    user?: boolean | purchase_history$userArgs<ExtArgs>
  }, ExtArgs["result"]["purchase_history"]>

  export type purchase_historySelectScalar = {
    id?: boolean
    date?: boolean
    user_id?: boolean
    device_id?: boolean
    public?: boolean
  }

  export type purchase_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "user_id" | "device_id" | "public", ExtArgs["result"]["purchase_history"]>
  export type purchase_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | purchase_history$deviceArgs<ExtArgs>
    user?: boolean | purchase_history$userArgs<ExtArgs>
  }
  export type purchase_historyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | purchase_history$deviceArgs<ExtArgs>
    user?: boolean | purchase_history$userArgs<ExtArgs>
  }
  export type purchase_historyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | purchase_history$deviceArgs<ExtArgs>
    user?: boolean | purchase_history$userArgs<ExtArgs>
  }

  export type $purchase_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "purchase_history"
    objects: {
      device: Prisma.$devicePayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      user_id: number | null
      device_id: number | null
      public: boolean | null
    }, ExtArgs["result"]["purchase_history"]>
    composites: {}
  }

  type purchase_historyGetPayload<S extends boolean | null | undefined | purchase_historyDefaultArgs> = $Result.GetResult<Prisma.$purchase_historyPayload, S>

  type purchase_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<purchase_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Purchase_historyCountAggregateInputType | true
    }

  export interface purchase_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['purchase_history'], meta: { name: 'purchase_history' } }
    /**
     * Find zero or one Purchase_history that matches the filter.
     * @param {purchase_historyFindUniqueArgs} args - Arguments to find a Purchase_history
     * @example
     * // Get one Purchase_history
     * const purchase_history = await prisma.purchase_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends purchase_historyFindUniqueArgs>(args: SelectSubset<T, purchase_historyFindUniqueArgs<ExtArgs>>): Prisma__purchase_historyClient<$Result.GetResult<Prisma.$purchase_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Purchase_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {purchase_historyFindUniqueOrThrowArgs} args - Arguments to find a Purchase_history
     * @example
     * // Get one Purchase_history
     * const purchase_history = await prisma.purchase_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends purchase_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, purchase_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__purchase_historyClient<$Result.GetResult<Prisma.$purchase_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchase_historyFindFirstArgs} args - Arguments to find a Purchase_history
     * @example
     * // Get one Purchase_history
     * const purchase_history = await prisma.purchase_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends purchase_historyFindFirstArgs>(args?: SelectSubset<T, purchase_historyFindFirstArgs<ExtArgs>>): Prisma__purchase_historyClient<$Result.GetResult<Prisma.$purchase_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Purchase_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchase_historyFindFirstOrThrowArgs} args - Arguments to find a Purchase_history
     * @example
     * // Get one Purchase_history
     * const purchase_history = await prisma.purchase_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends purchase_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, purchase_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__purchase_historyClient<$Result.GetResult<Prisma.$purchase_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Purchase_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchase_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchase_histories
     * const purchase_histories = await prisma.purchase_history.findMany()
     * 
     * // Get first 10 Purchase_histories
     * const purchase_histories = await prisma.purchase_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchase_historyWithIdOnly = await prisma.purchase_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends purchase_historyFindManyArgs>(args?: SelectSubset<T, purchase_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$purchase_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Purchase_history.
     * @param {purchase_historyCreateArgs} args - Arguments to create a Purchase_history.
     * @example
     * // Create one Purchase_history
     * const Purchase_history = await prisma.purchase_history.create({
     *   data: {
     *     // ... data to create a Purchase_history
     *   }
     * })
     * 
     */
    create<T extends purchase_historyCreateArgs>(args: SelectSubset<T, purchase_historyCreateArgs<ExtArgs>>): Prisma__purchase_historyClient<$Result.GetResult<Prisma.$purchase_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Purchase_histories.
     * @param {purchase_historyCreateManyArgs} args - Arguments to create many Purchase_histories.
     * @example
     * // Create many Purchase_histories
     * const purchase_history = await prisma.purchase_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends purchase_historyCreateManyArgs>(args?: SelectSubset<T, purchase_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Purchase_histories and returns the data saved in the database.
     * @param {purchase_historyCreateManyAndReturnArgs} args - Arguments to create many Purchase_histories.
     * @example
     * // Create many Purchase_histories
     * const purchase_history = await prisma.purchase_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Purchase_histories and only return the `id`
     * const purchase_historyWithIdOnly = await prisma.purchase_history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends purchase_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, purchase_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$purchase_historyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Purchase_history.
     * @param {purchase_historyDeleteArgs} args - Arguments to delete one Purchase_history.
     * @example
     * // Delete one Purchase_history
     * const Purchase_history = await prisma.purchase_history.delete({
     *   where: {
     *     // ... filter to delete one Purchase_history
     *   }
     * })
     * 
     */
    delete<T extends purchase_historyDeleteArgs>(args: SelectSubset<T, purchase_historyDeleteArgs<ExtArgs>>): Prisma__purchase_historyClient<$Result.GetResult<Prisma.$purchase_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Purchase_history.
     * @param {purchase_historyUpdateArgs} args - Arguments to update one Purchase_history.
     * @example
     * // Update one Purchase_history
     * const purchase_history = await prisma.purchase_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends purchase_historyUpdateArgs>(args: SelectSubset<T, purchase_historyUpdateArgs<ExtArgs>>): Prisma__purchase_historyClient<$Result.GetResult<Prisma.$purchase_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Purchase_histories.
     * @param {purchase_historyDeleteManyArgs} args - Arguments to filter Purchase_histories to delete.
     * @example
     * // Delete a few Purchase_histories
     * const { count } = await prisma.purchase_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends purchase_historyDeleteManyArgs>(args?: SelectSubset<T, purchase_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchase_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchase_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchase_histories
     * const purchase_history = await prisma.purchase_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends purchase_historyUpdateManyArgs>(args: SelectSubset<T, purchase_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchase_histories and returns the data updated in the database.
     * @param {purchase_historyUpdateManyAndReturnArgs} args - Arguments to update many Purchase_histories.
     * @example
     * // Update many Purchase_histories
     * const purchase_history = await prisma.purchase_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Purchase_histories and only return the `id`
     * const purchase_historyWithIdOnly = await prisma.purchase_history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends purchase_historyUpdateManyAndReturnArgs>(args: SelectSubset<T, purchase_historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$purchase_historyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Purchase_history.
     * @param {purchase_historyUpsertArgs} args - Arguments to update or create a Purchase_history.
     * @example
     * // Update or create a Purchase_history
     * const purchase_history = await prisma.purchase_history.upsert({
     *   create: {
     *     // ... data to create a Purchase_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase_history we want to update
     *   }
     * })
     */
    upsert<T extends purchase_historyUpsertArgs>(args: SelectSubset<T, purchase_historyUpsertArgs<ExtArgs>>): Prisma__purchase_historyClient<$Result.GetResult<Prisma.$purchase_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Purchase_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchase_historyCountArgs} args - Arguments to filter Purchase_histories to count.
     * @example
     * // Count the number of Purchase_histories
     * const count = await prisma.purchase_history.count({
     *   where: {
     *     // ... the filter for the Purchase_histories we want to count
     *   }
     * })
    **/
    count<T extends purchase_historyCountArgs>(
      args?: Subset<T, purchase_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Purchase_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Purchase_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Purchase_historyAggregateArgs>(args: Subset<T, Purchase_historyAggregateArgs>): Prisma.PrismaPromise<GetPurchase_historyAggregateType<T>>

    /**
     * Group by Purchase_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchase_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends purchase_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: purchase_historyGroupByArgs['orderBy'] }
        : { orderBy?: purchase_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, purchase_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchase_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the purchase_history model
   */
  readonly fields: purchase_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for purchase_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__purchase_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends purchase_history$deviceArgs<ExtArgs> = {}>(args?: Subset<T, purchase_history$deviceArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends purchase_history$userArgs<ExtArgs> = {}>(args?: Subset<T, purchase_history$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the purchase_history model
   */
  interface purchase_historyFieldRefs {
    readonly id: FieldRef<"purchase_history", 'Int'>
    readonly date: FieldRef<"purchase_history", 'DateTime'>
    readonly user_id: FieldRef<"purchase_history", 'Int'>
    readonly device_id: FieldRef<"purchase_history", 'Int'>
    readonly public: FieldRef<"purchase_history", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * purchase_history findUnique
   */
  export type purchase_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase_history
     */
    select?: purchase_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the purchase_history
     */
    omit?: purchase_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchase_historyInclude<ExtArgs> | null
    /**
     * Filter, which purchase_history to fetch.
     */
    where: purchase_historyWhereUniqueInput
  }

  /**
   * purchase_history findUniqueOrThrow
   */
  export type purchase_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase_history
     */
    select?: purchase_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the purchase_history
     */
    omit?: purchase_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchase_historyInclude<ExtArgs> | null
    /**
     * Filter, which purchase_history to fetch.
     */
    where: purchase_historyWhereUniqueInput
  }

  /**
   * purchase_history findFirst
   */
  export type purchase_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase_history
     */
    select?: purchase_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the purchase_history
     */
    omit?: purchase_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchase_historyInclude<ExtArgs> | null
    /**
     * Filter, which purchase_history to fetch.
     */
    where?: purchase_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchase_histories to fetch.
     */
    orderBy?: purchase_historyOrderByWithRelationInput | purchase_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for purchase_histories.
     */
    cursor?: purchase_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchase_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchase_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of purchase_histories.
     */
    distinct?: Purchase_historyScalarFieldEnum | Purchase_historyScalarFieldEnum[]
  }

  /**
   * purchase_history findFirstOrThrow
   */
  export type purchase_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase_history
     */
    select?: purchase_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the purchase_history
     */
    omit?: purchase_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchase_historyInclude<ExtArgs> | null
    /**
     * Filter, which purchase_history to fetch.
     */
    where?: purchase_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchase_histories to fetch.
     */
    orderBy?: purchase_historyOrderByWithRelationInput | purchase_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for purchase_histories.
     */
    cursor?: purchase_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchase_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchase_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of purchase_histories.
     */
    distinct?: Purchase_historyScalarFieldEnum | Purchase_historyScalarFieldEnum[]
  }

  /**
   * purchase_history findMany
   */
  export type purchase_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase_history
     */
    select?: purchase_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the purchase_history
     */
    omit?: purchase_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchase_historyInclude<ExtArgs> | null
    /**
     * Filter, which purchase_histories to fetch.
     */
    where?: purchase_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchase_histories to fetch.
     */
    orderBy?: purchase_historyOrderByWithRelationInput | purchase_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing purchase_histories.
     */
    cursor?: purchase_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchase_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchase_histories.
     */
    skip?: number
    distinct?: Purchase_historyScalarFieldEnum | Purchase_historyScalarFieldEnum[]
  }

  /**
   * purchase_history create
   */
  export type purchase_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase_history
     */
    select?: purchase_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the purchase_history
     */
    omit?: purchase_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchase_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a purchase_history.
     */
    data?: XOR<purchase_historyCreateInput, purchase_historyUncheckedCreateInput>
  }

  /**
   * purchase_history createMany
   */
  export type purchase_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many purchase_histories.
     */
    data: purchase_historyCreateManyInput | purchase_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * purchase_history createManyAndReturn
   */
  export type purchase_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase_history
     */
    select?: purchase_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the purchase_history
     */
    omit?: purchase_historyOmit<ExtArgs> | null
    /**
     * The data used to create many purchase_histories.
     */
    data: purchase_historyCreateManyInput | purchase_historyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchase_historyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * purchase_history update
   */
  export type purchase_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase_history
     */
    select?: purchase_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the purchase_history
     */
    omit?: purchase_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchase_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a purchase_history.
     */
    data: XOR<purchase_historyUpdateInput, purchase_historyUncheckedUpdateInput>
    /**
     * Choose, which purchase_history to update.
     */
    where: purchase_historyWhereUniqueInput
  }

  /**
   * purchase_history updateMany
   */
  export type purchase_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update purchase_histories.
     */
    data: XOR<purchase_historyUpdateManyMutationInput, purchase_historyUncheckedUpdateManyInput>
    /**
     * Filter which purchase_histories to update
     */
    where?: purchase_historyWhereInput
    /**
     * Limit how many purchase_histories to update.
     */
    limit?: number
  }

  /**
   * purchase_history updateManyAndReturn
   */
  export type purchase_historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase_history
     */
    select?: purchase_historySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the purchase_history
     */
    omit?: purchase_historyOmit<ExtArgs> | null
    /**
     * The data used to update purchase_histories.
     */
    data: XOR<purchase_historyUpdateManyMutationInput, purchase_historyUncheckedUpdateManyInput>
    /**
     * Filter which purchase_histories to update
     */
    where?: purchase_historyWhereInput
    /**
     * Limit how many purchase_histories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchase_historyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * purchase_history upsert
   */
  export type purchase_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase_history
     */
    select?: purchase_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the purchase_history
     */
    omit?: purchase_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchase_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the purchase_history to update in case it exists.
     */
    where: purchase_historyWhereUniqueInput
    /**
     * In case the purchase_history found by the `where` argument doesn't exist, create a new purchase_history with this data.
     */
    create: XOR<purchase_historyCreateInput, purchase_historyUncheckedCreateInput>
    /**
     * In case the purchase_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<purchase_historyUpdateInput, purchase_historyUncheckedUpdateInput>
  }

  /**
   * purchase_history delete
   */
  export type purchase_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase_history
     */
    select?: purchase_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the purchase_history
     */
    omit?: purchase_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchase_historyInclude<ExtArgs> | null
    /**
     * Filter which purchase_history to delete.
     */
    where: purchase_historyWhereUniqueInput
  }

  /**
   * purchase_history deleteMany
   */
  export type purchase_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which purchase_histories to delete
     */
    where?: purchase_historyWhereInput
    /**
     * Limit how many purchase_histories to delete.
     */
    limit?: number
  }

  /**
   * purchase_history.device
   */
  export type purchase_history$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    where?: deviceWhereInput
  }

  /**
   * purchase_history.user
   */
  export type purchase_history$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * purchase_history without action
   */
  export type purchase_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase_history
     */
    select?: purchase_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the purchase_history
     */
    omit?: purchase_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchase_historyInclude<ExtArgs> | null
  }


  /**
   * Model state_type
   */

  export type AggregateState_type = {
    _count: State_typeCountAggregateOutputType | null
    _avg: State_typeAvgAggregateOutputType | null
    _sum: State_typeSumAggregateOutputType | null
    _min: State_typeMinAggregateOutputType | null
    _max: State_typeMaxAggregateOutputType | null
  }

  export type State_typeAvgAggregateOutputType = {
    id: number | null
  }

  export type State_typeSumAggregateOutputType = {
    id: number | null
  }

  export type State_typeMinAggregateOutputType = {
    id: number | null
    state: string | null
  }

  export type State_typeMaxAggregateOutputType = {
    id: number | null
    state: string | null
  }

  export type State_typeCountAggregateOutputType = {
    id: number
    state: number
    _all: number
  }


  export type State_typeAvgAggregateInputType = {
    id?: true
  }

  export type State_typeSumAggregateInputType = {
    id?: true
  }

  export type State_typeMinAggregateInputType = {
    id?: true
    state?: true
  }

  export type State_typeMaxAggregateInputType = {
    id?: true
    state?: true
  }

  export type State_typeCountAggregateInputType = {
    id?: true
    state?: true
    _all?: true
  }

  export type State_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which state_type to aggregate.
     */
    where?: state_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of state_types to fetch.
     */
    orderBy?: state_typeOrderByWithRelationInput | state_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: state_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` state_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` state_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned state_types
    **/
    _count?: true | State_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: State_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: State_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: State_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: State_typeMaxAggregateInputType
  }

  export type GetState_typeAggregateType<T extends State_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateState_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateState_type[P]>
      : GetScalarType<T[P], AggregateState_type[P]>
  }




  export type state_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: state_typeWhereInput
    orderBy?: state_typeOrderByWithAggregationInput | state_typeOrderByWithAggregationInput[]
    by: State_typeScalarFieldEnum[] | State_typeScalarFieldEnum
    having?: state_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: State_typeCountAggregateInputType | true
    _avg?: State_typeAvgAggregateInputType
    _sum?: State_typeSumAggregateInputType
    _min?: State_typeMinAggregateInputType
    _max?: State_typeMaxAggregateInputType
  }

  export type State_typeGroupByOutputType = {
    id: number
    state: string
    _count: State_typeCountAggregateOutputType | null
    _avg: State_typeAvgAggregateOutputType | null
    _sum: State_typeSumAggregateOutputType | null
    _min: State_typeMinAggregateOutputType | null
    _max: State_typeMaxAggregateOutputType | null
  }

  type GetState_typeGroupByPayload<T extends state_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<State_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof State_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], State_typeGroupByOutputType[P]>
            : GetScalarType<T[P], State_typeGroupByOutputType[P]>
        }
      >
    >


  export type state_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    state?: boolean
    device?: boolean | state_type$deviceArgs<ExtArgs>
    _count?: boolean | State_typeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["state_type"]>

  export type state_typeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    state?: boolean
  }, ExtArgs["result"]["state_type"]>

  export type state_typeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    state?: boolean
  }, ExtArgs["result"]["state_type"]>

  export type state_typeSelectScalar = {
    id?: boolean
    state?: boolean
  }

  export type state_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "state", ExtArgs["result"]["state_type"]>
  export type state_typeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | state_type$deviceArgs<ExtArgs>
    _count?: boolean | State_typeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type state_typeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type state_typeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $state_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "state_type"
    objects: {
      device: Prisma.$devicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      state: string
    }, ExtArgs["result"]["state_type"]>
    composites: {}
  }

  type state_typeGetPayload<S extends boolean | null | undefined | state_typeDefaultArgs> = $Result.GetResult<Prisma.$state_typePayload, S>

  type state_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<state_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: State_typeCountAggregateInputType | true
    }

  export interface state_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['state_type'], meta: { name: 'state_type' } }
    /**
     * Find zero or one State_type that matches the filter.
     * @param {state_typeFindUniqueArgs} args - Arguments to find a State_type
     * @example
     * // Get one State_type
     * const state_type = await prisma.state_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends state_typeFindUniqueArgs>(args: SelectSubset<T, state_typeFindUniqueArgs<ExtArgs>>): Prisma__state_typeClient<$Result.GetResult<Prisma.$state_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one State_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {state_typeFindUniqueOrThrowArgs} args - Arguments to find a State_type
     * @example
     * // Get one State_type
     * const state_type = await prisma.state_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends state_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, state_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__state_typeClient<$Result.GetResult<Prisma.$state_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first State_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {state_typeFindFirstArgs} args - Arguments to find a State_type
     * @example
     * // Get one State_type
     * const state_type = await prisma.state_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends state_typeFindFirstArgs>(args?: SelectSubset<T, state_typeFindFirstArgs<ExtArgs>>): Prisma__state_typeClient<$Result.GetResult<Prisma.$state_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first State_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {state_typeFindFirstOrThrowArgs} args - Arguments to find a State_type
     * @example
     * // Get one State_type
     * const state_type = await prisma.state_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends state_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, state_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__state_typeClient<$Result.GetResult<Prisma.$state_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more State_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {state_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all State_types
     * const state_types = await prisma.state_type.findMany()
     * 
     * // Get first 10 State_types
     * const state_types = await prisma.state_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const state_typeWithIdOnly = await prisma.state_type.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends state_typeFindManyArgs>(args?: SelectSubset<T, state_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$state_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a State_type.
     * @param {state_typeCreateArgs} args - Arguments to create a State_type.
     * @example
     * // Create one State_type
     * const State_type = await prisma.state_type.create({
     *   data: {
     *     // ... data to create a State_type
     *   }
     * })
     * 
     */
    create<T extends state_typeCreateArgs>(args: SelectSubset<T, state_typeCreateArgs<ExtArgs>>): Prisma__state_typeClient<$Result.GetResult<Prisma.$state_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many State_types.
     * @param {state_typeCreateManyArgs} args - Arguments to create many State_types.
     * @example
     * // Create many State_types
     * const state_type = await prisma.state_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends state_typeCreateManyArgs>(args?: SelectSubset<T, state_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many State_types and returns the data saved in the database.
     * @param {state_typeCreateManyAndReturnArgs} args - Arguments to create many State_types.
     * @example
     * // Create many State_types
     * const state_type = await prisma.state_type.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many State_types and only return the `id`
     * const state_typeWithIdOnly = await prisma.state_type.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends state_typeCreateManyAndReturnArgs>(args?: SelectSubset<T, state_typeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$state_typePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a State_type.
     * @param {state_typeDeleteArgs} args - Arguments to delete one State_type.
     * @example
     * // Delete one State_type
     * const State_type = await prisma.state_type.delete({
     *   where: {
     *     // ... filter to delete one State_type
     *   }
     * })
     * 
     */
    delete<T extends state_typeDeleteArgs>(args: SelectSubset<T, state_typeDeleteArgs<ExtArgs>>): Prisma__state_typeClient<$Result.GetResult<Prisma.$state_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one State_type.
     * @param {state_typeUpdateArgs} args - Arguments to update one State_type.
     * @example
     * // Update one State_type
     * const state_type = await prisma.state_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends state_typeUpdateArgs>(args: SelectSubset<T, state_typeUpdateArgs<ExtArgs>>): Prisma__state_typeClient<$Result.GetResult<Prisma.$state_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more State_types.
     * @param {state_typeDeleteManyArgs} args - Arguments to filter State_types to delete.
     * @example
     * // Delete a few State_types
     * const { count } = await prisma.state_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends state_typeDeleteManyArgs>(args?: SelectSubset<T, state_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more State_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {state_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many State_types
     * const state_type = await prisma.state_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends state_typeUpdateManyArgs>(args: SelectSubset<T, state_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more State_types and returns the data updated in the database.
     * @param {state_typeUpdateManyAndReturnArgs} args - Arguments to update many State_types.
     * @example
     * // Update many State_types
     * const state_type = await prisma.state_type.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more State_types and only return the `id`
     * const state_typeWithIdOnly = await prisma.state_type.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends state_typeUpdateManyAndReturnArgs>(args: SelectSubset<T, state_typeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$state_typePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one State_type.
     * @param {state_typeUpsertArgs} args - Arguments to update or create a State_type.
     * @example
     * // Update or create a State_type
     * const state_type = await prisma.state_type.upsert({
     *   create: {
     *     // ... data to create a State_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the State_type we want to update
     *   }
     * })
     */
    upsert<T extends state_typeUpsertArgs>(args: SelectSubset<T, state_typeUpsertArgs<ExtArgs>>): Prisma__state_typeClient<$Result.GetResult<Prisma.$state_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of State_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {state_typeCountArgs} args - Arguments to filter State_types to count.
     * @example
     * // Count the number of State_types
     * const count = await prisma.state_type.count({
     *   where: {
     *     // ... the filter for the State_types we want to count
     *   }
     * })
    **/
    count<T extends state_typeCountArgs>(
      args?: Subset<T, state_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], State_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a State_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {State_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends State_typeAggregateArgs>(args: Subset<T, State_typeAggregateArgs>): Prisma.PrismaPromise<GetState_typeAggregateType<T>>

    /**
     * Group by State_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {state_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends state_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: state_typeGroupByArgs['orderBy'] }
        : { orderBy?: state_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, state_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetState_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the state_type model
   */
  readonly fields: state_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for state_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__state_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends state_type$deviceArgs<ExtArgs> = {}>(args?: Subset<T, state_type$deviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the state_type model
   */
  interface state_typeFieldRefs {
    readonly id: FieldRef<"state_type", 'Int'>
    readonly state: FieldRef<"state_type", 'String'>
  }
    

  // Custom InputTypes
  /**
   * state_type findUnique
   */
  export type state_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state_type
     */
    select?: state_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state_type
     */
    omit?: state_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: state_typeInclude<ExtArgs> | null
    /**
     * Filter, which state_type to fetch.
     */
    where: state_typeWhereUniqueInput
  }

  /**
   * state_type findUniqueOrThrow
   */
  export type state_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state_type
     */
    select?: state_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state_type
     */
    omit?: state_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: state_typeInclude<ExtArgs> | null
    /**
     * Filter, which state_type to fetch.
     */
    where: state_typeWhereUniqueInput
  }

  /**
   * state_type findFirst
   */
  export type state_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state_type
     */
    select?: state_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state_type
     */
    omit?: state_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: state_typeInclude<ExtArgs> | null
    /**
     * Filter, which state_type to fetch.
     */
    where?: state_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of state_types to fetch.
     */
    orderBy?: state_typeOrderByWithRelationInput | state_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for state_types.
     */
    cursor?: state_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` state_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` state_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of state_types.
     */
    distinct?: State_typeScalarFieldEnum | State_typeScalarFieldEnum[]
  }

  /**
   * state_type findFirstOrThrow
   */
  export type state_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state_type
     */
    select?: state_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state_type
     */
    omit?: state_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: state_typeInclude<ExtArgs> | null
    /**
     * Filter, which state_type to fetch.
     */
    where?: state_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of state_types to fetch.
     */
    orderBy?: state_typeOrderByWithRelationInput | state_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for state_types.
     */
    cursor?: state_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` state_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` state_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of state_types.
     */
    distinct?: State_typeScalarFieldEnum | State_typeScalarFieldEnum[]
  }

  /**
   * state_type findMany
   */
  export type state_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state_type
     */
    select?: state_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state_type
     */
    omit?: state_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: state_typeInclude<ExtArgs> | null
    /**
     * Filter, which state_types to fetch.
     */
    where?: state_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of state_types to fetch.
     */
    orderBy?: state_typeOrderByWithRelationInput | state_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing state_types.
     */
    cursor?: state_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` state_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` state_types.
     */
    skip?: number
    distinct?: State_typeScalarFieldEnum | State_typeScalarFieldEnum[]
  }

  /**
   * state_type create
   */
  export type state_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state_type
     */
    select?: state_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state_type
     */
    omit?: state_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: state_typeInclude<ExtArgs> | null
    /**
     * The data needed to create a state_type.
     */
    data: XOR<state_typeCreateInput, state_typeUncheckedCreateInput>
  }

  /**
   * state_type createMany
   */
  export type state_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many state_types.
     */
    data: state_typeCreateManyInput | state_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * state_type createManyAndReturn
   */
  export type state_typeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state_type
     */
    select?: state_typeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the state_type
     */
    omit?: state_typeOmit<ExtArgs> | null
    /**
     * The data used to create many state_types.
     */
    data: state_typeCreateManyInput | state_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * state_type update
   */
  export type state_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state_type
     */
    select?: state_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state_type
     */
    omit?: state_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: state_typeInclude<ExtArgs> | null
    /**
     * The data needed to update a state_type.
     */
    data: XOR<state_typeUpdateInput, state_typeUncheckedUpdateInput>
    /**
     * Choose, which state_type to update.
     */
    where: state_typeWhereUniqueInput
  }

  /**
   * state_type updateMany
   */
  export type state_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update state_types.
     */
    data: XOR<state_typeUpdateManyMutationInput, state_typeUncheckedUpdateManyInput>
    /**
     * Filter which state_types to update
     */
    where?: state_typeWhereInput
    /**
     * Limit how many state_types to update.
     */
    limit?: number
  }

  /**
   * state_type updateManyAndReturn
   */
  export type state_typeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state_type
     */
    select?: state_typeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the state_type
     */
    omit?: state_typeOmit<ExtArgs> | null
    /**
     * The data used to update state_types.
     */
    data: XOR<state_typeUpdateManyMutationInput, state_typeUncheckedUpdateManyInput>
    /**
     * Filter which state_types to update
     */
    where?: state_typeWhereInput
    /**
     * Limit how many state_types to update.
     */
    limit?: number
  }

  /**
   * state_type upsert
   */
  export type state_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state_type
     */
    select?: state_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state_type
     */
    omit?: state_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: state_typeInclude<ExtArgs> | null
    /**
     * The filter to search for the state_type to update in case it exists.
     */
    where: state_typeWhereUniqueInput
    /**
     * In case the state_type found by the `where` argument doesn't exist, create a new state_type with this data.
     */
    create: XOR<state_typeCreateInput, state_typeUncheckedCreateInput>
    /**
     * In case the state_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<state_typeUpdateInput, state_typeUncheckedUpdateInput>
  }

  /**
   * state_type delete
   */
  export type state_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state_type
     */
    select?: state_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state_type
     */
    omit?: state_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: state_typeInclude<ExtArgs> | null
    /**
     * Filter which state_type to delete.
     */
    where: state_typeWhereUniqueInput
  }

  /**
   * state_type deleteMany
   */
  export type state_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which state_types to delete
     */
    where?: state_typeWhereInput
    /**
     * Limit how many state_types to delete.
     */
    limit?: number
  }

  /**
   * state_type.device
   */
  export type state_type$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    where?: deviceWhereInput
    orderBy?: deviceOrderByWithRelationInput | deviceOrderByWithRelationInput[]
    cursor?: deviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * state_type without action
   */
  export type state_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state_type
     */
    select?: state_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state_type
     */
    omit?: state_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: state_typeInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    userTypeId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    userTypeId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    family_name: string | null
    first_name: string | null
    phone_number: string | null
    password: string | null
    userTypeId: number | null
    email: string | null
    sex: string | null
    street: string | null
    city: string | null
    birth_date: Date | null
    Identifier: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    family_name: string | null
    first_name: string | null
    phone_number: string | null
    password: string | null
    userTypeId: number | null
    email: string | null
    sex: string | null
    street: string | null
    city: string | null
    birth_date: Date | null
    Identifier: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    created_at: number
    family_name: number
    first_name: number
    phone_number: number
    password: number
    userTypeId: number
    email: number
    sex: number
    street: number
    city: number
    birth_date: number
    Identifier: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    userTypeId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    userTypeId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    created_at?: true
    family_name?: true
    first_name?: true
    phone_number?: true
    password?: true
    userTypeId?: true
    email?: true
    sex?: true
    street?: true
    city?: true
    birth_date?: true
    Identifier?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    created_at?: true
    family_name?: true
    first_name?: true
    phone_number?: true
    password?: true
    userTypeId?: true
    email?: true
    sex?: true
    street?: true
    city?: true
    birth_date?: true
    Identifier?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    created_at?: true
    family_name?: true
    first_name?: true
    phone_number?: true
    password?: true
    userTypeId?: true
    email?: true
    sex?: true
    street?: true
    city?: true
    birth_date?: true
    Identifier?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    created_at: Date
    family_name: string | null
    first_name: string | null
    phone_number: string | null
    password: string | null
    userTypeId: number | null
    email: string | null
    sex: string | null
    street: string | null
    city: string | null
    birth_date: Date | null
    Identifier: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    family_name?: boolean
    first_name?: boolean
    phone_number?: boolean
    password?: boolean
    userTypeId?: boolean
    email?: boolean
    sex?: boolean
    street?: boolean
    city?: boolean
    birth_date?: boolean
    Identifier?: boolean
    device?: boolean | user$deviceArgs<ExtArgs>
    env_user?: boolean | user$env_userArgs<ExtArgs>
    helper_user_helper_user_helper_idTouser?: boolean | user$helper_user_helper_user_helper_idTouserArgs<ExtArgs>
    helper_user_helper_user_user_idTouser?: boolean | user$helper_user_helper_user_user_idTouserArgs<ExtArgs>
    intervention_history?: boolean | user$intervention_historyArgs<ExtArgs>
    localisation?: boolean | user$localisationArgs<ExtArgs>
    purchase_history?: boolean | user$purchase_historyArgs<ExtArgs>
    user_type?: boolean | user$user_typeArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    family_name?: boolean
    first_name?: boolean
    phone_number?: boolean
    password?: boolean
    userTypeId?: boolean
    email?: boolean
    sex?: boolean
    street?: boolean
    city?: boolean
    birth_date?: boolean
    Identifier?: boolean
    user_type?: boolean | user$user_typeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    family_name?: boolean
    first_name?: boolean
    phone_number?: boolean
    password?: boolean
    userTypeId?: boolean
    email?: boolean
    sex?: boolean
    street?: boolean
    city?: boolean
    birth_date?: boolean
    Identifier?: boolean
    user_type?: boolean | user$user_typeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    created_at?: boolean
    family_name?: boolean
    first_name?: boolean
    phone_number?: boolean
    password?: boolean
    userTypeId?: boolean
    email?: boolean
    sex?: boolean
    street?: boolean
    city?: boolean
    birth_date?: boolean
    Identifier?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "family_name" | "first_name" | "phone_number" | "password" | "userTypeId" | "email" | "sex" | "street" | "city" | "birth_date" | "Identifier", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | user$deviceArgs<ExtArgs>
    env_user?: boolean | user$env_userArgs<ExtArgs>
    helper_user_helper_user_helper_idTouser?: boolean | user$helper_user_helper_user_helper_idTouserArgs<ExtArgs>
    helper_user_helper_user_user_idTouser?: boolean | user$helper_user_helper_user_user_idTouserArgs<ExtArgs>
    intervention_history?: boolean | user$intervention_historyArgs<ExtArgs>
    localisation?: boolean | user$localisationArgs<ExtArgs>
    purchase_history?: boolean | user$purchase_historyArgs<ExtArgs>
    user_type?: boolean | user$user_typeArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_type?: boolean | user$user_typeArgs<ExtArgs>
  }
  export type userIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_type?: boolean | user$user_typeArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      device: Prisma.$devicePayload<ExtArgs>[]
      env_user: Prisma.$env_userPayload<ExtArgs>[]
      helper_user_helper_user_helper_idTouser: Prisma.$helper_userPayload<ExtArgs>[]
      helper_user_helper_user_user_idTouser: Prisma.$helper_userPayload<ExtArgs>[]
      intervention_history: Prisma.$intervention_historyPayload<ExtArgs>[]
      localisation: Prisma.$localisationPayload<ExtArgs> | null
      purchase_history: Prisma.$purchase_historyPayload<ExtArgs>[]
      user_type: Prisma.$user_typePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_at: Date
      family_name: string | null
      first_name: string | null
      phone_number: string | null
      password: string | null
      userTypeId: number | null
      email: string | null
      sex: string | null
      street: string | null
      city: string | null
      birth_date: Date | null
      Identifier: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {userCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userCreateManyAndReturnArgs>(args?: SelectSubset<T, userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {userUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userUpdateManyAndReturnArgs>(args: SelectSubset<T, userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends user$deviceArgs<ExtArgs> = {}>(args?: Subset<T, user$deviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    env_user<T extends user$env_userArgs<ExtArgs> = {}>(args?: Subset<T, user$env_userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$env_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    helper_user_helper_user_helper_idTouser<T extends user$helper_user_helper_user_helper_idTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$helper_user_helper_user_helper_idTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helper_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    helper_user_helper_user_user_idTouser<T extends user$helper_user_helper_user_user_idTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$helper_user_helper_user_user_idTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$helper_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    intervention_history<T extends user$intervention_historyArgs<ExtArgs> = {}>(args?: Subset<T, user$intervention_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$intervention_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    localisation<T extends user$localisationArgs<ExtArgs> = {}>(args?: Subset<T, user$localisationArgs<ExtArgs>>): Prisma__localisationClient<$Result.GetResult<Prisma.$localisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    purchase_history<T extends user$purchase_historyArgs<ExtArgs> = {}>(args?: Subset<T, user$purchase_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$purchase_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_type<T extends user$user_typeArgs<ExtArgs> = {}>(args?: Subset<T, user$user_typeArgs<ExtArgs>>): Prisma__user_typeClient<$Result.GetResult<Prisma.$user_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly created_at: FieldRef<"user", 'DateTime'>
    readonly family_name: FieldRef<"user", 'String'>
    readonly first_name: FieldRef<"user", 'String'>
    readonly phone_number: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly userTypeId: FieldRef<"user", 'Int'>
    readonly email: FieldRef<"user", 'String'>
    readonly sex: FieldRef<"user", 'String'>
    readonly street: FieldRef<"user", 'String'>
    readonly city: FieldRef<"user", 'String'>
    readonly birth_date: FieldRef<"user", 'DateTime'>
    readonly Identifier: FieldRef<"user", 'String'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data?: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user createManyAndReturn
   */
  export type userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user updateManyAndReturn
   */
  export type userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.device
   */
  export type user$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    where?: deviceWhereInput
    orderBy?: deviceOrderByWithRelationInput | deviceOrderByWithRelationInput[]
    cursor?: deviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * user.env_user
   */
  export type user$env_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the env_user
     */
    select?: env_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the env_user
     */
    omit?: env_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: env_userInclude<ExtArgs> | null
    where?: env_userWhereInput
    orderBy?: env_userOrderByWithRelationInput | env_userOrderByWithRelationInput[]
    cursor?: env_userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Env_userScalarFieldEnum | Env_userScalarFieldEnum[]
  }

  /**
   * user.helper_user_helper_user_helper_idTouser
   */
  export type user$helper_user_helper_user_helper_idTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helper_user
     */
    select?: helper_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helper_user
     */
    omit?: helper_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helper_userInclude<ExtArgs> | null
    where?: helper_userWhereInput
    orderBy?: helper_userOrderByWithRelationInput | helper_userOrderByWithRelationInput[]
    cursor?: helper_userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Helper_userScalarFieldEnum | Helper_userScalarFieldEnum[]
  }

  /**
   * user.helper_user_helper_user_user_idTouser
   */
  export type user$helper_user_helper_user_user_idTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the helper_user
     */
    select?: helper_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the helper_user
     */
    omit?: helper_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: helper_userInclude<ExtArgs> | null
    where?: helper_userWhereInput
    orderBy?: helper_userOrderByWithRelationInput | helper_userOrderByWithRelationInput[]
    cursor?: helper_userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Helper_userScalarFieldEnum | Helper_userScalarFieldEnum[]
  }

  /**
   * user.intervention_history
   */
  export type user$intervention_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intervention_history
     */
    select?: intervention_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the intervention_history
     */
    omit?: intervention_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intervention_historyInclude<ExtArgs> | null
    where?: intervention_historyWhereInput
    orderBy?: intervention_historyOrderByWithRelationInput | intervention_historyOrderByWithRelationInput[]
    cursor?: intervention_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Intervention_historyScalarFieldEnum | Intervention_historyScalarFieldEnum[]
  }

  /**
   * user.localisation
   */
  export type user$localisationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localisation
     */
    select?: localisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localisation
     */
    omit?: localisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localisationInclude<ExtArgs> | null
    where?: localisationWhereInput
  }

  /**
   * user.purchase_history
   */
  export type user$purchase_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase_history
     */
    select?: purchase_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the purchase_history
     */
    omit?: purchase_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: purchase_historyInclude<ExtArgs> | null
    where?: purchase_historyWhereInput
    orderBy?: purchase_historyOrderByWithRelationInput | purchase_historyOrderByWithRelationInput[]
    cursor?: purchase_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Purchase_historyScalarFieldEnum | Purchase_historyScalarFieldEnum[]
  }

  /**
   * user.user_type
   */
  export type user$user_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_type
     */
    select?: user_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_type
     */
    omit?: user_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typeInclude<ExtArgs> | null
    where?: user_typeWhereInput
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model user_type
   */

  export type AggregateUser_type = {
    _count: User_typeCountAggregateOutputType | null
    _avg: User_typeAvgAggregateOutputType | null
    _sum: User_typeSumAggregateOutputType | null
    _min: User_typeMinAggregateOutputType | null
    _max: User_typeMaxAggregateOutputType | null
  }

  export type User_typeAvgAggregateOutputType = {
    id: number | null
  }

  export type User_typeSumAggregateOutputType = {
    id: number | null
  }

  export type User_typeMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    type: string | null
  }

  export type User_typeMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    type: string | null
  }

  export type User_typeCountAggregateOutputType = {
    id: number
    created_at: number
    type: number
    _all: number
  }


  export type User_typeAvgAggregateInputType = {
    id?: true
  }

  export type User_typeSumAggregateInputType = {
    id?: true
  }

  export type User_typeMinAggregateInputType = {
    id?: true
    created_at?: true
    type?: true
  }

  export type User_typeMaxAggregateInputType = {
    id?: true
    created_at?: true
    type?: true
  }

  export type User_typeCountAggregateInputType = {
    id?: true
    created_at?: true
    type?: true
    _all?: true
  }

  export type User_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_type to aggregate.
     */
    where?: user_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_types to fetch.
     */
    orderBy?: user_typeOrderByWithRelationInput | user_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_types
    **/
    _count?: true | User_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_typeMaxAggregateInputType
  }

  export type GetUser_typeAggregateType<T extends User_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_type[P]>
      : GetScalarType<T[P], AggregateUser_type[P]>
  }




  export type user_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_typeWhereInput
    orderBy?: user_typeOrderByWithAggregationInput | user_typeOrderByWithAggregationInput[]
    by: User_typeScalarFieldEnum[] | User_typeScalarFieldEnum
    having?: user_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_typeCountAggregateInputType | true
    _avg?: User_typeAvgAggregateInputType
    _sum?: User_typeSumAggregateInputType
    _min?: User_typeMinAggregateInputType
    _max?: User_typeMaxAggregateInputType
  }

  export type User_typeGroupByOutputType = {
    id: number
    created_at: Date
    type: string | null
    _count: User_typeCountAggregateOutputType | null
    _avg: User_typeAvgAggregateOutputType | null
    _sum: User_typeSumAggregateOutputType | null
    _min: User_typeMinAggregateOutputType | null
    _max: User_typeMaxAggregateOutputType | null
  }

  type GetUser_typeGroupByPayload<T extends user_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_typeGroupByOutputType[P]>
            : GetScalarType<T[P], User_typeGroupByOutputType[P]>
        }
      >
    >


  export type user_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    type?: boolean
    user?: boolean | user_type$userArgs<ExtArgs>
    _count?: boolean | User_typeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_type"]>

  export type user_typeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    type?: boolean
  }, ExtArgs["result"]["user_type"]>

  export type user_typeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    type?: boolean
  }, ExtArgs["result"]["user_type"]>

  export type user_typeSelectScalar = {
    id?: boolean
    created_at?: boolean
    type?: boolean
  }

  export type user_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "type", ExtArgs["result"]["user_type"]>
  export type user_typeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | user_type$userArgs<ExtArgs>
    _count?: boolean | User_typeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type user_typeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type user_typeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $user_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_type"
    objects: {
      user: Prisma.$userPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_at: Date
      type: string | null
    }, ExtArgs["result"]["user_type"]>
    composites: {}
  }

  type user_typeGetPayload<S extends boolean | null | undefined | user_typeDefaultArgs> = $Result.GetResult<Prisma.$user_typePayload, S>

  type user_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_typeCountAggregateInputType | true
    }

  export interface user_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_type'], meta: { name: 'user_type' } }
    /**
     * Find zero or one User_type that matches the filter.
     * @param {user_typeFindUniqueArgs} args - Arguments to find a User_type
     * @example
     * // Get one User_type
     * const user_type = await prisma.user_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_typeFindUniqueArgs>(args: SelectSubset<T, user_typeFindUniqueArgs<ExtArgs>>): Prisma__user_typeClient<$Result.GetResult<Prisma.$user_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_typeFindUniqueOrThrowArgs} args - Arguments to find a User_type
     * @example
     * // Get one User_type
     * const user_type = await prisma.user_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, user_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_typeClient<$Result.GetResult<Prisma.$user_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_typeFindFirstArgs} args - Arguments to find a User_type
     * @example
     * // Get one User_type
     * const user_type = await prisma.user_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_typeFindFirstArgs>(args?: SelectSubset<T, user_typeFindFirstArgs<ExtArgs>>): Prisma__user_typeClient<$Result.GetResult<Prisma.$user_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_typeFindFirstOrThrowArgs} args - Arguments to find a User_type
     * @example
     * // Get one User_type
     * const user_type = await prisma.user_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, user_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_typeClient<$Result.GetResult<Prisma.$user_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_types
     * const user_types = await prisma.user_type.findMany()
     * 
     * // Get first 10 User_types
     * const user_types = await prisma.user_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_typeWithIdOnly = await prisma.user_type.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_typeFindManyArgs>(args?: SelectSubset<T, user_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_type.
     * @param {user_typeCreateArgs} args - Arguments to create a User_type.
     * @example
     * // Create one User_type
     * const User_type = await prisma.user_type.create({
     *   data: {
     *     // ... data to create a User_type
     *   }
     * })
     * 
     */
    create<T extends user_typeCreateArgs>(args: SelectSubset<T, user_typeCreateArgs<ExtArgs>>): Prisma__user_typeClient<$Result.GetResult<Prisma.$user_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_types.
     * @param {user_typeCreateManyArgs} args - Arguments to create many User_types.
     * @example
     * // Create many User_types
     * const user_type = await prisma.user_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_typeCreateManyArgs>(args?: SelectSubset<T, user_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_types and returns the data saved in the database.
     * @param {user_typeCreateManyAndReturnArgs} args - Arguments to create many User_types.
     * @example
     * // Create many User_types
     * const user_type = await prisma.user_type.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_types and only return the `id`
     * const user_typeWithIdOnly = await prisma.user_type.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_typeCreateManyAndReturnArgs>(args?: SelectSubset<T, user_typeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_typePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_type.
     * @param {user_typeDeleteArgs} args - Arguments to delete one User_type.
     * @example
     * // Delete one User_type
     * const User_type = await prisma.user_type.delete({
     *   where: {
     *     // ... filter to delete one User_type
     *   }
     * })
     * 
     */
    delete<T extends user_typeDeleteArgs>(args: SelectSubset<T, user_typeDeleteArgs<ExtArgs>>): Prisma__user_typeClient<$Result.GetResult<Prisma.$user_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_type.
     * @param {user_typeUpdateArgs} args - Arguments to update one User_type.
     * @example
     * // Update one User_type
     * const user_type = await prisma.user_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_typeUpdateArgs>(args: SelectSubset<T, user_typeUpdateArgs<ExtArgs>>): Prisma__user_typeClient<$Result.GetResult<Prisma.$user_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_types.
     * @param {user_typeDeleteManyArgs} args - Arguments to filter User_types to delete.
     * @example
     * // Delete a few User_types
     * const { count } = await prisma.user_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_typeDeleteManyArgs>(args?: SelectSubset<T, user_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_types
     * const user_type = await prisma.user_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_typeUpdateManyArgs>(args: SelectSubset<T, user_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_types and returns the data updated in the database.
     * @param {user_typeUpdateManyAndReturnArgs} args - Arguments to update many User_types.
     * @example
     * // Update many User_types
     * const user_type = await prisma.user_type.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_types and only return the `id`
     * const user_typeWithIdOnly = await prisma.user_type.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_typeUpdateManyAndReturnArgs>(args: SelectSubset<T, user_typeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_typePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_type.
     * @param {user_typeUpsertArgs} args - Arguments to update or create a User_type.
     * @example
     * // Update or create a User_type
     * const user_type = await prisma.user_type.upsert({
     *   create: {
     *     // ... data to create a User_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_type we want to update
     *   }
     * })
     */
    upsert<T extends user_typeUpsertArgs>(args: SelectSubset<T, user_typeUpsertArgs<ExtArgs>>): Prisma__user_typeClient<$Result.GetResult<Prisma.$user_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_typeCountArgs} args - Arguments to filter User_types to count.
     * @example
     * // Count the number of User_types
     * const count = await prisma.user_type.count({
     *   where: {
     *     // ... the filter for the User_types we want to count
     *   }
     * })
    **/
    count<T extends user_typeCountArgs>(
      args?: Subset<T, user_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_typeAggregateArgs>(args: Subset<T, User_typeAggregateArgs>): Prisma.PrismaPromise<GetUser_typeAggregateType<T>>

    /**
     * Group by User_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_typeGroupByArgs['orderBy'] }
        : { orderBy?: user_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_type model
   */
  readonly fields: user_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends user_type$userArgs<ExtArgs> = {}>(args?: Subset<T, user_type$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_type model
   */
  interface user_typeFieldRefs {
    readonly id: FieldRef<"user_type", 'Int'>
    readonly created_at: FieldRef<"user_type", 'DateTime'>
    readonly type: FieldRef<"user_type", 'String'>
  }
    

  // Custom InputTypes
  /**
   * user_type findUnique
   */
  export type user_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_type
     */
    select?: user_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_type
     */
    omit?: user_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typeInclude<ExtArgs> | null
    /**
     * Filter, which user_type to fetch.
     */
    where: user_typeWhereUniqueInput
  }

  /**
   * user_type findUniqueOrThrow
   */
  export type user_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_type
     */
    select?: user_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_type
     */
    omit?: user_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typeInclude<ExtArgs> | null
    /**
     * Filter, which user_type to fetch.
     */
    where: user_typeWhereUniqueInput
  }

  /**
   * user_type findFirst
   */
  export type user_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_type
     */
    select?: user_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_type
     */
    omit?: user_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typeInclude<ExtArgs> | null
    /**
     * Filter, which user_type to fetch.
     */
    where?: user_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_types to fetch.
     */
    orderBy?: user_typeOrderByWithRelationInput | user_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_types.
     */
    cursor?: user_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_types.
     */
    distinct?: User_typeScalarFieldEnum | User_typeScalarFieldEnum[]
  }

  /**
   * user_type findFirstOrThrow
   */
  export type user_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_type
     */
    select?: user_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_type
     */
    omit?: user_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typeInclude<ExtArgs> | null
    /**
     * Filter, which user_type to fetch.
     */
    where?: user_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_types to fetch.
     */
    orderBy?: user_typeOrderByWithRelationInput | user_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_types.
     */
    cursor?: user_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_types.
     */
    distinct?: User_typeScalarFieldEnum | User_typeScalarFieldEnum[]
  }

  /**
   * user_type findMany
   */
  export type user_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_type
     */
    select?: user_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_type
     */
    omit?: user_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typeInclude<ExtArgs> | null
    /**
     * Filter, which user_types to fetch.
     */
    where?: user_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_types to fetch.
     */
    orderBy?: user_typeOrderByWithRelationInput | user_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_types.
     */
    cursor?: user_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_types.
     */
    skip?: number
    distinct?: User_typeScalarFieldEnum | User_typeScalarFieldEnum[]
  }

  /**
   * user_type create
   */
  export type user_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_type
     */
    select?: user_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_type
     */
    omit?: user_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typeInclude<ExtArgs> | null
    /**
     * The data needed to create a user_type.
     */
    data?: XOR<user_typeCreateInput, user_typeUncheckedCreateInput>
  }

  /**
   * user_type createMany
   */
  export type user_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_types.
     */
    data: user_typeCreateManyInput | user_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_type createManyAndReturn
   */
  export type user_typeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_type
     */
    select?: user_typeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_type
     */
    omit?: user_typeOmit<ExtArgs> | null
    /**
     * The data used to create many user_types.
     */
    data: user_typeCreateManyInput | user_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_type update
   */
  export type user_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_type
     */
    select?: user_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_type
     */
    omit?: user_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typeInclude<ExtArgs> | null
    /**
     * The data needed to update a user_type.
     */
    data: XOR<user_typeUpdateInput, user_typeUncheckedUpdateInput>
    /**
     * Choose, which user_type to update.
     */
    where: user_typeWhereUniqueInput
  }

  /**
   * user_type updateMany
   */
  export type user_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_types.
     */
    data: XOR<user_typeUpdateManyMutationInput, user_typeUncheckedUpdateManyInput>
    /**
     * Filter which user_types to update
     */
    where?: user_typeWhereInput
    /**
     * Limit how many user_types to update.
     */
    limit?: number
  }

  /**
   * user_type updateManyAndReturn
   */
  export type user_typeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_type
     */
    select?: user_typeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_type
     */
    omit?: user_typeOmit<ExtArgs> | null
    /**
     * The data used to update user_types.
     */
    data: XOR<user_typeUpdateManyMutationInput, user_typeUncheckedUpdateManyInput>
    /**
     * Filter which user_types to update
     */
    where?: user_typeWhereInput
    /**
     * Limit how many user_types to update.
     */
    limit?: number
  }

  /**
   * user_type upsert
   */
  export type user_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_type
     */
    select?: user_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_type
     */
    omit?: user_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typeInclude<ExtArgs> | null
    /**
     * The filter to search for the user_type to update in case it exists.
     */
    where: user_typeWhereUniqueInput
    /**
     * In case the user_type found by the `where` argument doesn't exist, create a new user_type with this data.
     */
    create: XOR<user_typeCreateInput, user_typeUncheckedCreateInput>
    /**
     * In case the user_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_typeUpdateInput, user_typeUncheckedUpdateInput>
  }

  /**
   * user_type delete
   */
  export type user_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_type
     */
    select?: user_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_type
     */
    omit?: user_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typeInclude<ExtArgs> | null
    /**
     * Filter which user_type to delete.
     */
    where: user_typeWhereUniqueInput
  }

  /**
   * user_type deleteMany
   */
  export type user_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_types to delete
     */
    where?: user_typeWhereInput
    /**
     * Limit how many user_types to delete.
     */
    limit?: number
  }

  /**
   * user_type.user
   */
  export type user_type$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user_type without action
   */
  export type user_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_type
     */
    select?: user_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_type
     */
    omit?: user_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typeInclude<ExtArgs> | null
  }


  /**
   * Model zone
   */

  export type AggregateZone = {
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  export type ZoneAvgAggregateOutputType = {
    id: number | null
    env_id: number | null
    type_id: number | null
    map_id: number | null
    zone_type: number | null
  }

  export type ZoneSumAggregateOutputType = {
    id: number | null
    env_id: number | null
    type_id: number | null
    map_id: number | null
    zone_type: number | null
  }

  export type ZoneMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    env_id: number | null
    name: string | null
    description: string | null
    type_id: number | null
    updated_at: Date | null
    map_id: number | null
    zone_type: number | null
  }

  export type ZoneMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    env_id: number | null
    name: string | null
    description: string | null
    type_id: number | null
    updated_at: Date | null
    map_id: number | null
    zone_type: number | null
  }

  export type ZoneCountAggregateOutputType = {
    id: number
    created_at: number
    env_id: number
    name: number
    description: number
    type_id: number
    coordinates: number
    updated_at: number
    map_id: number
    zone_type: number
    _all: number
  }


  export type ZoneAvgAggregateInputType = {
    id?: true
    env_id?: true
    type_id?: true
    map_id?: true
    zone_type?: true
  }

  export type ZoneSumAggregateInputType = {
    id?: true
    env_id?: true
    type_id?: true
    map_id?: true
    zone_type?: true
  }

  export type ZoneMinAggregateInputType = {
    id?: true
    created_at?: true
    env_id?: true
    name?: true
    description?: true
    type_id?: true
    updated_at?: true
    map_id?: true
    zone_type?: true
  }

  export type ZoneMaxAggregateInputType = {
    id?: true
    created_at?: true
    env_id?: true
    name?: true
    description?: true
    type_id?: true
    updated_at?: true
    map_id?: true
    zone_type?: true
  }

  export type ZoneCountAggregateInputType = {
    id?: true
    created_at?: true
    env_id?: true
    name?: true
    description?: true
    type_id?: true
    coordinates?: true
    updated_at?: true
    map_id?: true
    zone_type?: true
    _all?: true
  }

  export type ZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zone to aggregate.
     */
    where?: zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zoneOrderByWithRelationInput | zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned zones
    **/
    _count?: true | ZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneMaxAggregateInputType
  }

  export type GetZoneAggregateType<T extends ZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZone[P]>
      : GetScalarType<T[P], AggregateZone[P]>
  }




  export type zoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zoneWhereInput
    orderBy?: zoneOrderByWithAggregationInput | zoneOrderByWithAggregationInput[]
    by: ZoneScalarFieldEnum[] | ZoneScalarFieldEnum
    having?: zoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneCountAggregateInputType | true
    _avg?: ZoneAvgAggregateInputType
    _sum?: ZoneSumAggregateInputType
    _min?: ZoneMinAggregateInputType
    _max?: ZoneMaxAggregateInputType
  }

  export type ZoneGroupByOutputType = {
    id: number
    created_at: Date
    env_id: number | null
    name: string | null
    description: string | null
    type_id: number | null
    coordinates: JsonValue | null
    updated_at: Date | null
    map_id: number | null
    zone_type: number | null
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  type GetZoneGroupByPayload<T extends zoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneGroupByOutputType[P]>
        }
      >
    >


  export type zoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    env_id?: boolean
    name?: boolean
    description?: boolean
    type_id?: boolean
    coordinates?: boolean
    updated_at?: boolean
    map_id?: boolean
    zone_type?: boolean
    poi_zone?: boolean | zone$poi_zoneArgs<ExtArgs>
    environment?: boolean | zone$environmentArgs<ExtArgs>
    map?: boolean | zone$mapArgs<ExtArgs>
    zone_type_zone_type_idTozone_type?: boolean | zone$zone_type_zone_type_idTozone_typeArgs<ExtArgs>
    zone_type_zone_zone_typeTozone_type?: boolean | zone$zone_type_zone_zone_typeTozone_typeArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type zoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    env_id?: boolean
    name?: boolean
    description?: boolean
    type_id?: boolean
    coordinates?: boolean
    updated_at?: boolean
    map_id?: boolean
    zone_type?: boolean
    environment?: boolean | zone$environmentArgs<ExtArgs>
    map?: boolean | zone$mapArgs<ExtArgs>
    zone_type_zone_type_idTozone_type?: boolean | zone$zone_type_zone_type_idTozone_typeArgs<ExtArgs>
    zone_type_zone_zone_typeTozone_type?: boolean | zone$zone_type_zone_zone_typeTozone_typeArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type zoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    env_id?: boolean
    name?: boolean
    description?: boolean
    type_id?: boolean
    coordinates?: boolean
    updated_at?: boolean
    map_id?: boolean
    zone_type?: boolean
    environment?: boolean | zone$environmentArgs<ExtArgs>
    map?: boolean | zone$mapArgs<ExtArgs>
    zone_type_zone_type_idTozone_type?: boolean | zone$zone_type_zone_type_idTozone_typeArgs<ExtArgs>
    zone_type_zone_zone_typeTozone_type?: boolean | zone$zone_type_zone_zone_typeTozone_typeArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type zoneSelectScalar = {
    id?: boolean
    created_at?: boolean
    env_id?: boolean
    name?: boolean
    description?: boolean
    type_id?: boolean
    coordinates?: boolean
    updated_at?: boolean
    map_id?: boolean
    zone_type?: boolean
  }

  export type zoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "env_id" | "name" | "description" | "type_id" | "coordinates" | "updated_at" | "map_id" | "zone_type", ExtArgs["result"]["zone"]>
  export type zoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poi_zone?: boolean | zone$poi_zoneArgs<ExtArgs>
    environment?: boolean | zone$environmentArgs<ExtArgs>
    map?: boolean | zone$mapArgs<ExtArgs>
    zone_type_zone_type_idTozone_type?: boolean | zone$zone_type_zone_type_idTozone_typeArgs<ExtArgs>
    zone_type_zone_zone_typeTozone_type?: boolean | zone$zone_type_zone_zone_typeTozone_typeArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type zoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | zone$environmentArgs<ExtArgs>
    map?: boolean | zone$mapArgs<ExtArgs>
    zone_type_zone_type_idTozone_type?: boolean | zone$zone_type_zone_type_idTozone_typeArgs<ExtArgs>
    zone_type_zone_zone_typeTozone_type?: boolean | zone$zone_type_zone_zone_typeTozone_typeArgs<ExtArgs>
  }
  export type zoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    environment?: boolean | zone$environmentArgs<ExtArgs>
    map?: boolean | zone$mapArgs<ExtArgs>
    zone_type_zone_type_idTozone_type?: boolean | zone$zone_type_zone_type_idTozone_typeArgs<ExtArgs>
    zone_type_zone_zone_typeTozone_type?: boolean | zone$zone_type_zone_zone_typeTozone_typeArgs<ExtArgs>
  }

  export type $zonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "zone"
    objects: {
      poi_zone: Prisma.$poi_zonePayload<ExtArgs>[]
      environment: Prisma.$environmentPayload<ExtArgs> | null
      map: Prisma.$mapPayload<ExtArgs> | null
      zone_type_zone_type_idTozone_type: Prisma.$zone_typePayload<ExtArgs> | null
      zone_type_zone_zone_typeTozone_type: Prisma.$zone_typePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_at: Date
      env_id: number | null
      name: string | null
      description: string | null
      type_id: number | null
      coordinates: Prisma.JsonValue | null
      updated_at: Date | null
      map_id: number | null
      zone_type: number | null
    }, ExtArgs["result"]["zone"]>
    composites: {}
  }

  type zoneGetPayload<S extends boolean | null | undefined | zoneDefaultArgs> = $Result.GetResult<Prisma.$zonePayload, S>

  type zoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<zoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZoneCountAggregateInputType | true
    }

  export interface zoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['zone'], meta: { name: 'zone' } }
    /**
     * Find zero or one Zone that matches the filter.
     * @param {zoneFindUniqueArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends zoneFindUniqueArgs>(args: SelectSubset<T, zoneFindUniqueArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Zone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {zoneFindUniqueOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends zoneFindUniqueOrThrowArgs>(args: SelectSubset<T, zoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneFindFirstArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends zoneFindFirstArgs>(args?: SelectSubset<T, zoneFindFirstArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneFindFirstOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends zoneFindFirstOrThrowArgs>(args?: SelectSubset<T, zoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zone.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zoneWithIdOnly = await prisma.zone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends zoneFindManyArgs>(args?: SelectSubset<T, zoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Zone.
     * @param {zoneCreateArgs} args - Arguments to create a Zone.
     * @example
     * // Create one Zone
     * const Zone = await prisma.zone.create({
     *   data: {
     *     // ... data to create a Zone
     *   }
     * })
     * 
     */
    create<T extends zoneCreateArgs>(args: SelectSubset<T, zoneCreateArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Zones.
     * @param {zoneCreateManyArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends zoneCreateManyArgs>(args?: SelectSubset<T, zoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zones and returns the data saved in the database.
     * @param {zoneCreateManyAndReturnArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends zoneCreateManyAndReturnArgs>(args?: SelectSubset<T, zoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Zone.
     * @param {zoneDeleteArgs} args - Arguments to delete one Zone.
     * @example
     * // Delete one Zone
     * const Zone = await prisma.zone.delete({
     *   where: {
     *     // ... filter to delete one Zone
     *   }
     * })
     * 
     */
    delete<T extends zoneDeleteArgs>(args: SelectSubset<T, zoneDeleteArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Zone.
     * @param {zoneUpdateArgs} args - Arguments to update one Zone.
     * @example
     * // Update one Zone
     * const zone = await prisma.zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends zoneUpdateArgs>(args: SelectSubset<T, zoneUpdateArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Zones.
     * @param {zoneDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends zoneDeleteManyArgs>(args?: SelectSubset<T, zoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends zoneUpdateManyArgs>(args: SelectSubset<T, zoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones and returns the data updated in the database.
     * @param {zoneUpdateManyAndReturnArgs} args - Arguments to update many Zones.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends zoneUpdateManyAndReturnArgs>(args: SelectSubset<T, zoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Zone.
     * @param {zoneUpsertArgs} args - Arguments to update or create a Zone.
     * @example
     * // Update or create a Zone
     * const zone = await prisma.zone.upsert({
     *   create: {
     *     // ... data to create a Zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zone we want to update
     *   }
     * })
     */
    upsert<T extends zoneUpsertArgs>(args: SelectSubset<T, zoneUpsertArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zone.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends zoneCountArgs>(
      args?: Subset<T, zoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneAggregateArgs>(args: Subset<T, ZoneAggregateArgs>): Prisma.PrismaPromise<GetZoneAggregateType<T>>

    /**
     * Group by Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends zoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: zoneGroupByArgs['orderBy'] }
        : { orderBy?: zoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, zoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the zone model
   */
  readonly fields: zoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__zoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    poi_zone<T extends zone$poi_zoneArgs<ExtArgs> = {}>(args?: Subset<T, zone$poi_zoneArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$poi_zonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    environment<T extends zone$environmentArgs<ExtArgs> = {}>(args?: Subset<T, zone$environmentArgs<ExtArgs>>): Prisma__environmentClient<$Result.GetResult<Prisma.$environmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    map<T extends zone$mapArgs<ExtArgs> = {}>(args?: Subset<T, zone$mapArgs<ExtArgs>>): Prisma__mapClient<$Result.GetResult<Prisma.$mapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    zone_type_zone_type_idTozone_type<T extends zone$zone_type_zone_type_idTozone_typeArgs<ExtArgs> = {}>(args?: Subset<T, zone$zone_type_zone_type_idTozone_typeArgs<ExtArgs>>): Prisma__zone_typeClient<$Result.GetResult<Prisma.$zone_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    zone_type_zone_zone_typeTozone_type<T extends zone$zone_type_zone_zone_typeTozone_typeArgs<ExtArgs> = {}>(args?: Subset<T, zone$zone_type_zone_zone_typeTozone_typeArgs<ExtArgs>>): Prisma__zone_typeClient<$Result.GetResult<Prisma.$zone_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the zone model
   */
  interface zoneFieldRefs {
    readonly id: FieldRef<"zone", 'Int'>
    readonly created_at: FieldRef<"zone", 'DateTime'>
    readonly env_id: FieldRef<"zone", 'Int'>
    readonly name: FieldRef<"zone", 'String'>
    readonly description: FieldRef<"zone", 'String'>
    readonly type_id: FieldRef<"zone", 'Int'>
    readonly coordinates: FieldRef<"zone", 'Json'>
    readonly updated_at: FieldRef<"zone", 'DateTime'>
    readonly map_id: FieldRef<"zone", 'Int'>
    readonly zone_type: FieldRef<"zone", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * zone findUnique
   */
  export type zoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter, which zone to fetch.
     */
    where: zoneWhereUniqueInput
  }

  /**
   * zone findUniqueOrThrow
   */
  export type zoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter, which zone to fetch.
     */
    where: zoneWhereUniqueInput
  }

  /**
   * zone findFirst
   */
  export type zoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter, which zone to fetch.
     */
    where?: zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zoneOrderByWithRelationInput | zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zones.
     */
    cursor?: zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * zone findFirstOrThrow
   */
  export type zoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter, which zone to fetch.
     */
    where?: zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zoneOrderByWithRelationInput | zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zones.
     */
    cursor?: zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * zone findMany
   */
  export type zoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter, which zones to fetch.
     */
    where?: zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zoneOrderByWithRelationInput | zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing zones.
     */
    cursor?: zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * zone create
   */
  export type zoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * The data needed to create a zone.
     */
    data?: XOR<zoneCreateInput, zoneUncheckedCreateInput>
  }

  /**
   * zone createMany
   */
  export type zoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many zones.
     */
    data: zoneCreateManyInput | zoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * zone createManyAndReturn
   */
  export type zoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * The data used to create many zones.
     */
    data: zoneCreateManyInput | zoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * zone update
   */
  export type zoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * The data needed to update a zone.
     */
    data: XOR<zoneUpdateInput, zoneUncheckedUpdateInput>
    /**
     * Choose, which zone to update.
     */
    where: zoneWhereUniqueInput
  }

  /**
   * zone updateMany
   */
  export type zoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update zones.
     */
    data: XOR<zoneUpdateManyMutationInput, zoneUncheckedUpdateManyInput>
    /**
     * Filter which zones to update
     */
    where?: zoneWhereInput
    /**
     * Limit how many zones to update.
     */
    limit?: number
  }

  /**
   * zone updateManyAndReturn
   */
  export type zoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * The data used to update zones.
     */
    data: XOR<zoneUpdateManyMutationInput, zoneUncheckedUpdateManyInput>
    /**
     * Filter which zones to update
     */
    where?: zoneWhereInput
    /**
     * Limit how many zones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * zone upsert
   */
  export type zoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * The filter to search for the zone to update in case it exists.
     */
    where: zoneWhereUniqueInput
    /**
     * In case the zone found by the `where` argument doesn't exist, create a new zone with this data.
     */
    create: XOR<zoneCreateInput, zoneUncheckedCreateInput>
    /**
     * In case the zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<zoneUpdateInput, zoneUncheckedUpdateInput>
  }

  /**
   * zone delete
   */
  export type zoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter which zone to delete.
     */
    where: zoneWhereUniqueInput
  }

  /**
   * zone deleteMany
   */
  export type zoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zones to delete
     */
    where?: zoneWhereInput
    /**
     * Limit how many zones to delete.
     */
    limit?: number
  }

  /**
   * zone.poi_zone
   */
  export type zone$poi_zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the poi_zone
     */
    select?: poi_zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the poi_zone
     */
    omit?: poi_zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: poi_zoneInclude<ExtArgs> | null
    where?: poi_zoneWhereInput
    orderBy?: poi_zoneOrderByWithRelationInput | poi_zoneOrderByWithRelationInput[]
    cursor?: poi_zoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Poi_zoneScalarFieldEnum | Poi_zoneScalarFieldEnum[]
  }

  /**
   * zone.environment
   */
  export type zone$environmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the environment
     */
    select?: environmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the environment
     */
    omit?: environmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: environmentInclude<ExtArgs> | null
    where?: environmentWhereInput
  }

  /**
   * zone.map
   */
  export type zone$mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the map
     */
    select?: mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the map
     */
    omit?: mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mapInclude<ExtArgs> | null
    where?: mapWhereInput
  }

  /**
   * zone.zone_type_zone_type_idTozone_type
   */
  export type zone$zone_type_zone_type_idTozone_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone_type
     */
    select?: zone_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone_type
     */
    omit?: zone_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zone_typeInclude<ExtArgs> | null
    where?: zone_typeWhereInput
  }

  /**
   * zone.zone_type_zone_zone_typeTozone_type
   */
  export type zone$zone_type_zone_zone_typeTozone_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone_type
     */
    select?: zone_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone_type
     */
    omit?: zone_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zone_typeInclude<ExtArgs> | null
    where?: zone_typeWhereInput
  }

  /**
   * zone without action
   */
  export type zoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
  }


  /**
   * Model zone_type
   */

  export type AggregateZone_type = {
    _count: Zone_typeCountAggregateOutputType | null
    _avg: Zone_typeAvgAggregateOutputType | null
    _sum: Zone_typeSumAggregateOutputType | null
    _min: Zone_typeMinAggregateOutputType | null
    _max: Zone_typeMaxAggregateOutputType | null
  }

  export type Zone_typeAvgAggregateOutputType = {
    id: number | null
  }

  export type Zone_typeSumAggregateOutputType = {
    id: number | null
  }

  export type Zone_typeMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    type: string | null
    color: string | null
    icon: string | null
    name: string | null
    description: string | null
    priority: string | null
    accessible: boolean | null
  }

  export type Zone_typeMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    type: string | null
    color: string | null
    icon: string | null
    name: string | null
    description: string | null
    priority: string | null
    accessible: boolean | null
  }

  export type Zone_typeCountAggregateOutputType = {
    id: number
    created_at: number
    type: number
    color: number
    icon: number
    name: number
    description: number
    priority: number
    accessible: number
    _all: number
  }


  export type Zone_typeAvgAggregateInputType = {
    id?: true
  }

  export type Zone_typeSumAggregateInputType = {
    id?: true
  }

  export type Zone_typeMinAggregateInputType = {
    id?: true
    created_at?: true
    type?: true
    color?: true
    icon?: true
    name?: true
    description?: true
    priority?: true
    accessible?: true
  }

  export type Zone_typeMaxAggregateInputType = {
    id?: true
    created_at?: true
    type?: true
    color?: true
    icon?: true
    name?: true
    description?: true
    priority?: true
    accessible?: true
  }

  export type Zone_typeCountAggregateInputType = {
    id?: true
    created_at?: true
    type?: true
    color?: true
    icon?: true
    name?: true
    description?: true
    priority?: true
    accessible?: true
    _all?: true
  }

  export type Zone_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zone_type to aggregate.
     */
    where?: zone_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zone_types to fetch.
     */
    orderBy?: zone_typeOrderByWithRelationInput | zone_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: zone_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zone_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zone_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned zone_types
    **/
    _count?: true | Zone_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Zone_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Zone_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Zone_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Zone_typeMaxAggregateInputType
  }

  export type GetZone_typeAggregateType<T extends Zone_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateZone_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZone_type[P]>
      : GetScalarType<T[P], AggregateZone_type[P]>
  }




  export type zone_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zone_typeWhereInput
    orderBy?: zone_typeOrderByWithAggregationInput | zone_typeOrderByWithAggregationInput[]
    by: Zone_typeScalarFieldEnum[] | Zone_typeScalarFieldEnum
    having?: zone_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Zone_typeCountAggregateInputType | true
    _avg?: Zone_typeAvgAggregateInputType
    _sum?: Zone_typeSumAggregateInputType
    _min?: Zone_typeMinAggregateInputType
    _max?: Zone_typeMaxAggregateInputType
  }

  export type Zone_typeGroupByOutputType = {
    id: number
    created_at: Date
    type: string | null
    color: string | null
    icon: string | null
    name: string | null
    description: string | null
    priority: string | null
    accessible: boolean | null
    _count: Zone_typeCountAggregateOutputType | null
    _avg: Zone_typeAvgAggregateOutputType | null
    _sum: Zone_typeSumAggregateOutputType | null
    _min: Zone_typeMinAggregateOutputType | null
    _max: Zone_typeMaxAggregateOutputType | null
  }

  type GetZone_typeGroupByPayload<T extends zone_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Zone_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Zone_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Zone_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Zone_typeGroupByOutputType[P]>
        }
      >
    >


  export type zone_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    type?: boolean
    color?: boolean
    icon?: boolean
    name?: boolean
    description?: boolean
    priority?: boolean
    accessible?: boolean
    zone_zone_type_idTozone_type?: boolean | zone_type$zone_zone_type_idTozone_typeArgs<ExtArgs>
    zone_zone_zone_typeTozone_type?: boolean | zone_type$zone_zone_zone_typeTozone_typeArgs<ExtArgs>
    _count?: boolean | Zone_typeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone_type"]>

  export type zone_typeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    type?: boolean
    color?: boolean
    icon?: boolean
    name?: boolean
    description?: boolean
    priority?: boolean
    accessible?: boolean
  }, ExtArgs["result"]["zone_type"]>

  export type zone_typeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    type?: boolean
    color?: boolean
    icon?: boolean
    name?: boolean
    description?: boolean
    priority?: boolean
    accessible?: boolean
  }, ExtArgs["result"]["zone_type"]>

  export type zone_typeSelectScalar = {
    id?: boolean
    created_at?: boolean
    type?: boolean
    color?: boolean
    icon?: boolean
    name?: boolean
    description?: boolean
    priority?: boolean
    accessible?: boolean
  }

  export type zone_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "type" | "color" | "icon" | "name" | "description" | "priority" | "accessible", ExtArgs["result"]["zone_type"]>
  export type zone_typeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone_zone_type_idTozone_type?: boolean | zone_type$zone_zone_type_idTozone_typeArgs<ExtArgs>
    zone_zone_zone_typeTozone_type?: boolean | zone_type$zone_zone_zone_typeTozone_typeArgs<ExtArgs>
    _count?: boolean | Zone_typeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type zone_typeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type zone_typeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $zone_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "zone_type"
    objects: {
      zone_zone_type_idTozone_type: Prisma.$zonePayload<ExtArgs>[]
      zone_zone_zone_typeTozone_type: Prisma.$zonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_at: Date
      type: string | null
      color: string | null
      icon: string | null
      name: string | null
      description: string | null
      priority: string | null
      accessible: boolean | null
    }, ExtArgs["result"]["zone_type"]>
    composites: {}
  }

  type zone_typeGetPayload<S extends boolean | null | undefined | zone_typeDefaultArgs> = $Result.GetResult<Prisma.$zone_typePayload, S>

  type zone_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<zone_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Zone_typeCountAggregateInputType | true
    }

  export interface zone_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['zone_type'], meta: { name: 'zone_type' } }
    /**
     * Find zero or one Zone_type that matches the filter.
     * @param {zone_typeFindUniqueArgs} args - Arguments to find a Zone_type
     * @example
     * // Get one Zone_type
     * const zone_type = await prisma.zone_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends zone_typeFindUniqueArgs>(args: SelectSubset<T, zone_typeFindUniqueArgs<ExtArgs>>): Prisma__zone_typeClient<$Result.GetResult<Prisma.$zone_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Zone_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {zone_typeFindUniqueOrThrowArgs} args - Arguments to find a Zone_type
     * @example
     * // Get one Zone_type
     * const zone_type = await prisma.zone_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends zone_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, zone_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__zone_typeClient<$Result.GetResult<Prisma.$zone_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zone_typeFindFirstArgs} args - Arguments to find a Zone_type
     * @example
     * // Get one Zone_type
     * const zone_type = await prisma.zone_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends zone_typeFindFirstArgs>(args?: SelectSubset<T, zone_typeFindFirstArgs<ExtArgs>>): Prisma__zone_typeClient<$Result.GetResult<Prisma.$zone_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zone_typeFindFirstOrThrowArgs} args - Arguments to find a Zone_type
     * @example
     * // Get one Zone_type
     * const zone_type = await prisma.zone_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends zone_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, zone_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__zone_typeClient<$Result.GetResult<Prisma.$zone_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Zone_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zone_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zone_types
     * const zone_types = await prisma.zone_type.findMany()
     * 
     * // Get first 10 Zone_types
     * const zone_types = await prisma.zone_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zone_typeWithIdOnly = await prisma.zone_type.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends zone_typeFindManyArgs>(args?: SelectSubset<T, zone_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zone_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Zone_type.
     * @param {zone_typeCreateArgs} args - Arguments to create a Zone_type.
     * @example
     * // Create one Zone_type
     * const Zone_type = await prisma.zone_type.create({
     *   data: {
     *     // ... data to create a Zone_type
     *   }
     * })
     * 
     */
    create<T extends zone_typeCreateArgs>(args: SelectSubset<T, zone_typeCreateArgs<ExtArgs>>): Prisma__zone_typeClient<$Result.GetResult<Prisma.$zone_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Zone_types.
     * @param {zone_typeCreateManyArgs} args - Arguments to create many Zone_types.
     * @example
     * // Create many Zone_types
     * const zone_type = await prisma.zone_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends zone_typeCreateManyArgs>(args?: SelectSubset<T, zone_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zone_types and returns the data saved in the database.
     * @param {zone_typeCreateManyAndReturnArgs} args - Arguments to create many Zone_types.
     * @example
     * // Create many Zone_types
     * const zone_type = await prisma.zone_type.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zone_types and only return the `id`
     * const zone_typeWithIdOnly = await prisma.zone_type.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends zone_typeCreateManyAndReturnArgs>(args?: SelectSubset<T, zone_typeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zone_typePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Zone_type.
     * @param {zone_typeDeleteArgs} args - Arguments to delete one Zone_type.
     * @example
     * // Delete one Zone_type
     * const Zone_type = await prisma.zone_type.delete({
     *   where: {
     *     // ... filter to delete one Zone_type
     *   }
     * })
     * 
     */
    delete<T extends zone_typeDeleteArgs>(args: SelectSubset<T, zone_typeDeleteArgs<ExtArgs>>): Prisma__zone_typeClient<$Result.GetResult<Prisma.$zone_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Zone_type.
     * @param {zone_typeUpdateArgs} args - Arguments to update one Zone_type.
     * @example
     * // Update one Zone_type
     * const zone_type = await prisma.zone_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends zone_typeUpdateArgs>(args: SelectSubset<T, zone_typeUpdateArgs<ExtArgs>>): Prisma__zone_typeClient<$Result.GetResult<Prisma.$zone_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Zone_types.
     * @param {zone_typeDeleteManyArgs} args - Arguments to filter Zone_types to delete.
     * @example
     * // Delete a few Zone_types
     * const { count } = await prisma.zone_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends zone_typeDeleteManyArgs>(args?: SelectSubset<T, zone_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zone_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zone_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zone_types
     * const zone_type = await prisma.zone_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends zone_typeUpdateManyArgs>(args: SelectSubset<T, zone_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zone_types and returns the data updated in the database.
     * @param {zone_typeUpdateManyAndReturnArgs} args - Arguments to update many Zone_types.
     * @example
     * // Update many Zone_types
     * const zone_type = await prisma.zone_type.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Zone_types and only return the `id`
     * const zone_typeWithIdOnly = await prisma.zone_type.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends zone_typeUpdateManyAndReturnArgs>(args: SelectSubset<T, zone_typeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zone_typePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Zone_type.
     * @param {zone_typeUpsertArgs} args - Arguments to update or create a Zone_type.
     * @example
     * // Update or create a Zone_type
     * const zone_type = await prisma.zone_type.upsert({
     *   create: {
     *     // ... data to create a Zone_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zone_type we want to update
     *   }
     * })
     */
    upsert<T extends zone_typeUpsertArgs>(args: SelectSubset<T, zone_typeUpsertArgs<ExtArgs>>): Prisma__zone_typeClient<$Result.GetResult<Prisma.$zone_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Zone_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zone_typeCountArgs} args - Arguments to filter Zone_types to count.
     * @example
     * // Count the number of Zone_types
     * const count = await prisma.zone_type.count({
     *   where: {
     *     // ... the filter for the Zone_types we want to count
     *   }
     * })
    **/
    count<T extends zone_typeCountArgs>(
      args?: Subset<T, zone_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Zone_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zone_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Zone_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Zone_typeAggregateArgs>(args: Subset<T, Zone_typeAggregateArgs>): Prisma.PrismaPromise<GetZone_typeAggregateType<T>>

    /**
     * Group by Zone_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zone_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends zone_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: zone_typeGroupByArgs['orderBy'] }
        : { orderBy?: zone_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, zone_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZone_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the zone_type model
   */
  readonly fields: zone_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for zone_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__zone_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zone_zone_type_idTozone_type<T extends zone_type$zone_zone_type_idTozone_typeArgs<ExtArgs> = {}>(args?: Subset<T, zone_type$zone_zone_type_idTozone_typeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zone_zone_zone_typeTozone_type<T extends zone_type$zone_zone_zone_typeTozone_typeArgs<ExtArgs> = {}>(args?: Subset<T, zone_type$zone_zone_zone_typeTozone_typeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the zone_type model
   */
  interface zone_typeFieldRefs {
    readonly id: FieldRef<"zone_type", 'Int'>
    readonly created_at: FieldRef<"zone_type", 'DateTime'>
    readonly type: FieldRef<"zone_type", 'String'>
    readonly color: FieldRef<"zone_type", 'String'>
    readonly icon: FieldRef<"zone_type", 'String'>
    readonly name: FieldRef<"zone_type", 'String'>
    readonly description: FieldRef<"zone_type", 'String'>
    readonly priority: FieldRef<"zone_type", 'String'>
    readonly accessible: FieldRef<"zone_type", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * zone_type findUnique
   */
  export type zone_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone_type
     */
    select?: zone_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone_type
     */
    omit?: zone_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zone_typeInclude<ExtArgs> | null
    /**
     * Filter, which zone_type to fetch.
     */
    where: zone_typeWhereUniqueInput
  }

  /**
   * zone_type findUniqueOrThrow
   */
  export type zone_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone_type
     */
    select?: zone_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone_type
     */
    omit?: zone_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zone_typeInclude<ExtArgs> | null
    /**
     * Filter, which zone_type to fetch.
     */
    where: zone_typeWhereUniqueInput
  }

  /**
   * zone_type findFirst
   */
  export type zone_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone_type
     */
    select?: zone_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone_type
     */
    omit?: zone_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zone_typeInclude<ExtArgs> | null
    /**
     * Filter, which zone_type to fetch.
     */
    where?: zone_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zone_types to fetch.
     */
    orderBy?: zone_typeOrderByWithRelationInput | zone_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zone_types.
     */
    cursor?: zone_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zone_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zone_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zone_types.
     */
    distinct?: Zone_typeScalarFieldEnum | Zone_typeScalarFieldEnum[]
  }

  /**
   * zone_type findFirstOrThrow
   */
  export type zone_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone_type
     */
    select?: zone_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone_type
     */
    omit?: zone_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zone_typeInclude<ExtArgs> | null
    /**
     * Filter, which zone_type to fetch.
     */
    where?: zone_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zone_types to fetch.
     */
    orderBy?: zone_typeOrderByWithRelationInput | zone_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zone_types.
     */
    cursor?: zone_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zone_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zone_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zone_types.
     */
    distinct?: Zone_typeScalarFieldEnum | Zone_typeScalarFieldEnum[]
  }

  /**
   * zone_type findMany
   */
  export type zone_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone_type
     */
    select?: zone_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone_type
     */
    omit?: zone_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zone_typeInclude<ExtArgs> | null
    /**
     * Filter, which zone_types to fetch.
     */
    where?: zone_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zone_types to fetch.
     */
    orderBy?: zone_typeOrderByWithRelationInput | zone_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing zone_types.
     */
    cursor?: zone_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zone_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zone_types.
     */
    skip?: number
    distinct?: Zone_typeScalarFieldEnum | Zone_typeScalarFieldEnum[]
  }

  /**
   * zone_type create
   */
  export type zone_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone_type
     */
    select?: zone_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone_type
     */
    omit?: zone_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zone_typeInclude<ExtArgs> | null
    /**
     * The data needed to create a zone_type.
     */
    data?: XOR<zone_typeCreateInput, zone_typeUncheckedCreateInput>
  }

  /**
   * zone_type createMany
   */
  export type zone_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many zone_types.
     */
    data: zone_typeCreateManyInput | zone_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * zone_type createManyAndReturn
   */
  export type zone_typeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone_type
     */
    select?: zone_typeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the zone_type
     */
    omit?: zone_typeOmit<ExtArgs> | null
    /**
     * The data used to create many zone_types.
     */
    data: zone_typeCreateManyInput | zone_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * zone_type update
   */
  export type zone_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone_type
     */
    select?: zone_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone_type
     */
    omit?: zone_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zone_typeInclude<ExtArgs> | null
    /**
     * The data needed to update a zone_type.
     */
    data: XOR<zone_typeUpdateInput, zone_typeUncheckedUpdateInput>
    /**
     * Choose, which zone_type to update.
     */
    where: zone_typeWhereUniqueInput
  }

  /**
   * zone_type updateMany
   */
  export type zone_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update zone_types.
     */
    data: XOR<zone_typeUpdateManyMutationInput, zone_typeUncheckedUpdateManyInput>
    /**
     * Filter which zone_types to update
     */
    where?: zone_typeWhereInput
    /**
     * Limit how many zone_types to update.
     */
    limit?: number
  }

  /**
   * zone_type updateManyAndReturn
   */
  export type zone_typeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone_type
     */
    select?: zone_typeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the zone_type
     */
    omit?: zone_typeOmit<ExtArgs> | null
    /**
     * The data used to update zone_types.
     */
    data: XOR<zone_typeUpdateManyMutationInput, zone_typeUncheckedUpdateManyInput>
    /**
     * Filter which zone_types to update
     */
    where?: zone_typeWhereInput
    /**
     * Limit how many zone_types to update.
     */
    limit?: number
  }

  /**
   * zone_type upsert
   */
  export type zone_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone_type
     */
    select?: zone_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone_type
     */
    omit?: zone_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zone_typeInclude<ExtArgs> | null
    /**
     * The filter to search for the zone_type to update in case it exists.
     */
    where: zone_typeWhereUniqueInput
    /**
     * In case the zone_type found by the `where` argument doesn't exist, create a new zone_type with this data.
     */
    create: XOR<zone_typeCreateInput, zone_typeUncheckedCreateInput>
    /**
     * In case the zone_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<zone_typeUpdateInput, zone_typeUncheckedUpdateInput>
  }

  /**
   * zone_type delete
   */
  export type zone_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone_type
     */
    select?: zone_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone_type
     */
    omit?: zone_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zone_typeInclude<ExtArgs> | null
    /**
     * Filter which zone_type to delete.
     */
    where: zone_typeWhereUniqueInput
  }

  /**
   * zone_type deleteMany
   */
  export type zone_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zone_types to delete
     */
    where?: zone_typeWhereInput
    /**
     * Limit how many zone_types to delete.
     */
    limit?: number
  }

  /**
   * zone_type.zone_zone_type_idTozone_type
   */
  export type zone_type$zone_zone_type_idTozone_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    where?: zoneWhereInput
    orderBy?: zoneOrderByWithRelationInput | zoneOrderByWithRelationInput[]
    cursor?: zoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * zone_type.zone_zone_zone_typeTozone_type
   */
  export type zone_type$zone_zone_zone_typeTozone_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    where?: zoneWhereInput
    orderBy?: zoneOrderByWithRelationInput | zoneOrderByWithRelationInput[]
    cursor?: zoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * zone_type without action
   */
  export type zone_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone_type
     */
    select?: zone_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone_type
     */
    omit?: zone_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zone_typeInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AlertScalarFieldEnum: {
    id: 'id',
    type: 'type',
    time: 'time',
    date: 'date',
    zone: 'zone',
    status: 'status',
    level: 'level',
    device_id: 'device_id'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    type_id: 'type_id',
    state_type_id: 'state_type_id',
    user_id: 'user_id',
    mac_address: 'mac_address',
    software_version: 'software_version',
    date_of_service: 'date_of_service',
    comm_state: 'comm_state',
    connection_state: 'connection_state',
    battery_capacity: 'battery_capacity',
    price: 'price'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const Device_typeScalarFieldEnum: {
    id: 'id',
    type: 'type'
  };

  export type Device_typeScalarFieldEnum = (typeof Device_typeScalarFieldEnum)[keyof typeof Device_typeScalarFieldEnum]


  export const Emergency_contactScalarFieldEnum: {
    id: 'id',
    label: 'label',
    number: 'number'
  };

  export type Emergency_contactScalarFieldEnum = (typeof Emergency_contactScalarFieldEnum)[keyof typeof Emergency_contactScalarFieldEnum]


  export const Env_delimiterScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    env_id: 'env_id',
    coordinates: 'coordinates',
    type: 'type'
  };

  export type Env_delimiterScalarFieldEnum = (typeof Env_delimiterScalarFieldEnum)[keyof typeof Env_delimiterScalarFieldEnum]


  export const Env_userScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    env_id: 'env_id'
  };

  export type Env_userScalarFieldEnum = (typeof Env_userScalarFieldEnum)[keyof typeof Env_userScalarFieldEnum]


  export const EnvironmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    address: 'address',
    created_at: 'created_at',
    updated_at: 'updated_at',
    map_id: 'map_id',
    is_public: 'is_public',
    surface: 'surface'
  };

  export type EnvironmentScalarFieldEnum = (typeof EnvironmentScalarFieldEnum)[keyof typeof EnvironmentScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    label: 'label',
    amount: 'amount',
    category: 'category',
    description: 'description',
    date: 'date'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const FormatScalarFieldEnum: {
    id: 'id',
    format: 'format'
  };

  export type FormatScalarFieldEnum = (typeof FormatScalarFieldEnum)[keyof typeof FormatScalarFieldEnum]


  export const Helper_userScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    helper_id: 'helper_id',
    state: 'state'
  };

  export type Helper_userScalarFieldEnum = (typeof Helper_userScalarFieldEnum)[keyof typeof Helper_userScalarFieldEnum]


  export const Intervention_historyScalarFieldEnum: {
    id: 'id',
    device_id: 'device_id',
    maintenancier_id: 'maintenancier_id',
    scheduled_date: 'scheduled_date',
    completion_date: 'completion_date',
    description: 'description',
    status: 'status',
    type: 'type',
    title: 'title',
    location: 'location'
  };

  export type Intervention_historyScalarFieldEnum = (typeof Intervention_historyScalarFieldEnum)[keyof typeof Intervention_historyScalarFieldEnum]


  export const LocalisationScalarFieldEnum: {
    id: 'id',
    longitude: 'longitude',
    latitude: 'latitude',
    userId: 'userId',
    updated_at: 'updated_at'
  };

  export type LocalisationScalarFieldEnum = (typeof LocalisationScalarFieldEnum)[keyof typeof LocalisationScalarFieldEnum]


  export const MapScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    format_id: 'format_id'
  };

  export type MapScalarFieldEnum = (typeof MapScalarFieldEnum)[keyof typeof MapScalarFieldEnum]


  export const Market_potentielScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    city: 'city',
    potential_value: 'potential_value'
  };

  export type Market_potentielScalarFieldEnum = (typeof Market_potentielScalarFieldEnum)[keyof typeof Market_potentielScalarFieldEnum]


  export const Panne_historyScalarFieldEnum: {
    id: 'id',
    alert_id: 'alert_id'
  };

  export type Panne_historyScalarFieldEnum = (typeof Panne_historyScalarFieldEnum)[keyof typeof Panne_historyScalarFieldEnum]


  export const PoiScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    env_id: 'env_id',
    category_id: 'category_id',
    name: 'name',
    description: 'description',
    coordinates: 'coordinates',
    image_url: 'image_url',
    map_id: 'map_id'
  };

  export type PoiScalarFieldEnum = (typeof PoiScalarFieldEnum)[keyof typeof PoiScalarFieldEnum]


  export const Poi_categoryScalarFieldEnum: {
    id: 'id',
    category: 'category'
  };

  export type Poi_categoryScalarFieldEnum = (typeof Poi_categoryScalarFieldEnum)[keyof typeof Poi_categoryScalarFieldEnum]


  export const Poi_zoneScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    poi_id: 'poi_id',
    zone_id: 'zone_id'
  };

  export type Poi_zoneScalarFieldEnum = (typeof Poi_zoneScalarFieldEnum)[keyof typeof Poi_zoneScalarFieldEnum]


  export const PricingScalarFieldEnum: {
    id: 'id',
    attribute: 'attribute',
    price: 'price'
  };

  export type PricingScalarFieldEnum = (typeof PricingScalarFieldEnum)[keyof typeof PricingScalarFieldEnum]


  export const Purchase_historyScalarFieldEnum: {
    id: 'id',
    date: 'date',
    user_id: 'user_id',
    device_id: 'device_id',
    public: 'public'
  };

  export type Purchase_historyScalarFieldEnum = (typeof Purchase_historyScalarFieldEnum)[keyof typeof Purchase_historyScalarFieldEnum]


  export const State_typeScalarFieldEnum: {
    id: 'id',
    state: 'state'
  };

  export type State_typeScalarFieldEnum = (typeof State_typeScalarFieldEnum)[keyof typeof State_typeScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    family_name: 'family_name',
    first_name: 'first_name',
    phone_number: 'phone_number',
    password: 'password',
    userTypeId: 'userTypeId',
    email: 'email',
    sex: 'sex',
    street: 'street',
    city: 'city',
    birth_date: 'birth_date',
    Identifier: 'Identifier'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const User_typeScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    type: 'type'
  };

  export type User_typeScalarFieldEnum = (typeof User_typeScalarFieldEnum)[keyof typeof User_typeScalarFieldEnum]


  export const ZoneScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    env_id: 'env_id',
    name: 'name',
    description: 'description',
    type_id: 'type_id',
    coordinates: 'coordinates',
    updated_at: 'updated_at',
    map_id: 'map_id',
    zone_type: 'zone_type'
  };

  export type ZoneScalarFieldEnum = (typeof ZoneScalarFieldEnum)[keyof typeof ZoneScalarFieldEnum]


  export const Zone_typeScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    type: 'type',
    color: 'color',
    icon: 'icon',
    name: 'name',
    description: 'description',
    priority: 'priority',
    accessible: 'accessible'
  };

  export type Zone_typeScalarFieldEnum = (typeof Zone_typeScalarFieldEnum)[keyof typeof Zone_typeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'level_new'
   */
  export type Enumlevel_newFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'level_new'>
    


  /**
   * Reference to a field of type 'level_new[]'
   */
  export type ListEnumlevel_newFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'level_new[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ExpenseCategory'
   */
  export type EnumExpenseCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseCategory'>
    


  /**
   * Reference to a field of type 'ExpenseCategory[]'
   */
  export type ListEnumExpenseCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseCategory[]'>
    


  /**
   * Reference to a field of type 'intervention_type'
   */
  export type Enumintervention_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'intervention_type'>
    


  /**
   * Reference to a field of type 'intervention_type[]'
   */
  export type ListEnumintervention_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'intervention_type[]'>
    
  /**
   * Deep Input Types
   */


  export type alertWhereInput = {
    AND?: alertWhereInput | alertWhereInput[]
    OR?: alertWhereInput[]
    NOT?: alertWhereInput | alertWhereInput[]
    id?: IntFilter<"alert"> | number
    type?: StringFilter<"alert"> | string
    time?: DateTimeFilter<"alert"> | Date | string
    date?: DateTimeFilter<"alert"> | Date | string
    zone?: StringFilter<"alert"> | string
    status?: StringFilter<"alert"> | string
    level?: Enumlevel_newFilter<"alert"> | $Enums.level_new
    device_id?: IntNullableFilter<"alert"> | number | null
    device?: XOR<DeviceNullableScalarRelationFilter, deviceWhereInput> | null
    panne_history?: Panne_historyListRelationFilter
  }

  export type alertOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    time?: SortOrder
    date?: SortOrder
    zone?: SortOrder
    status?: SortOrder
    level?: SortOrder
    device_id?: SortOrderInput | SortOrder
    device?: deviceOrderByWithRelationInput
    panne_history?: panne_historyOrderByRelationAggregateInput
  }

  export type alertWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: alertWhereInput | alertWhereInput[]
    OR?: alertWhereInput[]
    NOT?: alertWhereInput | alertWhereInput[]
    type?: StringFilter<"alert"> | string
    time?: DateTimeFilter<"alert"> | Date | string
    date?: DateTimeFilter<"alert"> | Date | string
    zone?: StringFilter<"alert"> | string
    status?: StringFilter<"alert"> | string
    level?: Enumlevel_newFilter<"alert"> | $Enums.level_new
    device_id?: IntNullableFilter<"alert"> | number | null
    device?: XOR<DeviceNullableScalarRelationFilter, deviceWhereInput> | null
    panne_history?: Panne_historyListRelationFilter
  }, "id">

  export type alertOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    time?: SortOrder
    date?: SortOrder
    zone?: SortOrder
    status?: SortOrder
    level?: SortOrder
    device_id?: SortOrderInput | SortOrder
    _count?: alertCountOrderByAggregateInput
    _avg?: alertAvgOrderByAggregateInput
    _max?: alertMaxOrderByAggregateInput
    _min?: alertMinOrderByAggregateInput
    _sum?: alertSumOrderByAggregateInput
  }

  export type alertScalarWhereWithAggregatesInput = {
    AND?: alertScalarWhereWithAggregatesInput | alertScalarWhereWithAggregatesInput[]
    OR?: alertScalarWhereWithAggregatesInput[]
    NOT?: alertScalarWhereWithAggregatesInput | alertScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"alert"> | number
    type?: StringWithAggregatesFilter<"alert"> | string
    time?: DateTimeWithAggregatesFilter<"alert"> | Date | string
    date?: DateTimeWithAggregatesFilter<"alert"> | Date | string
    zone?: StringWithAggregatesFilter<"alert"> | string
    status?: StringWithAggregatesFilter<"alert"> | string
    level?: Enumlevel_newWithAggregatesFilter<"alert"> | $Enums.level_new
    device_id?: IntNullableWithAggregatesFilter<"alert"> | number | null
  }

  export type deviceWhereInput = {
    AND?: deviceWhereInput | deviceWhereInput[]
    OR?: deviceWhereInput[]
    NOT?: deviceWhereInput | deviceWhereInput[]
    id?: IntFilter<"device"> | number
    type_id?: IntFilter<"device"> | number
    state_type_id?: IntFilter<"device"> | number
    user_id?: IntNullableFilter<"device"> | number | null
    mac_address?: StringFilter<"device"> | string
    software_version?: StringFilter<"device"> | string
    date_of_service?: DateTimeFilter<"device"> | Date | string
    comm_state?: BoolFilter<"device"> | boolean
    connection_state?: BoolNullableFilter<"device"> | boolean | null
    battery_capacity?: IntFilter<"device"> | number
    price?: FloatNullableFilter<"device"> | number | null
    alert?: AlertListRelationFilter
    state_type?: XOR<State_typeScalarRelationFilter, state_typeWhereInput>
    device_type?: XOR<Device_typeScalarRelationFilter, device_typeWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    purchase_history?: Purchase_historyListRelationFilter
  }

  export type deviceOrderByWithRelationInput = {
    id?: SortOrder
    type_id?: SortOrder
    state_type_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    mac_address?: SortOrder
    software_version?: SortOrder
    date_of_service?: SortOrder
    comm_state?: SortOrder
    connection_state?: SortOrderInput | SortOrder
    battery_capacity?: SortOrder
    price?: SortOrderInput | SortOrder
    alert?: alertOrderByRelationAggregateInput
    state_type?: state_typeOrderByWithRelationInput
    device_type?: device_typeOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    purchase_history?: purchase_historyOrderByRelationAggregateInput
  }

  export type deviceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: deviceWhereInput | deviceWhereInput[]
    OR?: deviceWhereInput[]
    NOT?: deviceWhereInput | deviceWhereInput[]
    type_id?: IntFilter<"device"> | number
    state_type_id?: IntFilter<"device"> | number
    user_id?: IntNullableFilter<"device"> | number | null
    mac_address?: StringFilter<"device"> | string
    software_version?: StringFilter<"device"> | string
    date_of_service?: DateTimeFilter<"device"> | Date | string
    comm_state?: BoolFilter<"device"> | boolean
    connection_state?: BoolNullableFilter<"device"> | boolean | null
    battery_capacity?: IntFilter<"device"> | number
    price?: FloatNullableFilter<"device"> | number | null
    alert?: AlertListRelationFilter
    state_type?: XOR<State_typeScalarRelationFilter, state_typeWhereInput>
    device_type?: XOR<Device_typeScalarRelationFilter, device_typeWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    purchase_history?: Purchase_historyListRelationFilter
  }, "id">

  export type deviceOrderByWithAggregationInput = {
    id?: SortOrder
    type_id?: SortOrder
    state_type_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    mac_address?: SortOrder
    software_version?: SortOrder
    date_of_service?: SortOrder
    comm_state?: SortOrder
    connection_state?: SortOrderInput | SortOrder
    battery_capacity?: SortOrder
    price?: SortOrderInput | SortOrder
    _count?: deviceCountOrderByAggregateInput
    _avg?: deviceAvgOrderByAggregateInput
    _max?: deviceMaxOrderByAggregateInput
    _min?: deviceMinOrderByAggregateInput
    _sum?: deviceSumOrderByAggregateInput
  }

  export type deviceScalarWhereWithAggregatesInput = {
    AND?: deviceScalarWhereWithAggregatesInput | deviceScalarWhereWithAggregatesInput[]
    OR?: deviceScalarWhereWithAggregatesInput[]
    NOT?: deviceScalarWhereWithAggregatesInput | deviceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"device"> | number
    type_id?: IntWithAggregatesFilter<"device"> | number
    state_type_id?: IntWithAggregatesFilter<"device"> | number
    user_id?: IntNullableWithAggregatesFilter<"device"> | number | null
    mac_address?: StringWithAggregatesFilter<"device"> | string
    software_version?: StringWithAggregatesFilter<"device"> | string
    date_of_service?: DateTimeWithAggregatesFilter<"device"> | Date | string
    comm_state?: BoolWithAggregatesFilter<"device"> | boolean
    connection_state?: BoolNullableWithAggregatesFilter<"device"> | boolean | null
    battery_capacity?: IntWithAggregatesFilter<"device"> | number
    price?: FloatNullableWithAggregatesFilter<"device"> | number | null
  }

  export type device_typeWhereInput = {
    AND?: device_typeWhereInput | device_typeWhereInput[]
    OR?: device_typeWhereInput[]
    NOT?: device_typeWhereInput | device_typeWhereInput[]
    id?: IntFilter<"device_type"> | number
    type?: StringFilter<"device_type"> | string
    device?: DeviceListRelationFilter
  }

  export type device_typeOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    device?: deviceOrderByRelationAggregateInput
  }

  export type device_typeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    type?: string
    AND?: device_typeWhereInput | device_typeWhereInput[]
    OR?: device_typeWhereInput[]
    NOT?: device_typeWhereInput | device_typeWhereInput[]
    device?: DeviceListRelationFilter
  }, "id" | "type">

  export type device_typeOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    _count?: device_typeCountOrderByAggregateInput
    _avg?: device_typeAvgOrderByAggregateInput
    _max?: device_typeMaxOrderByAggregateInput
    _min?: device_typeMinOrderByAggregateInput
    _sum?: device_typeSumOrderByAggregateInput
  }

  export type device_typeScalarWhereWithAggregatesInput = {
    AND?: device_typeScalarWhereWithAggregatesInput | device_typeScalarWhereWithAggregatesInput[]
    OR?: device_typeScalarWhereWithAggregatesInput[]
    NOT?: device_typeScalarWhereWithAggregatesInput | device_typeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"device_type"> | number
    type?: StringWithAggregatesFilter<"device_type"> | string
  }

  export type emergency_contactWhereInput = {
    AND?: emergency_contactWhereInput | emergency_contactWhereInput[]
    OR?: emergency_contactWhereInput[]
    NOT?: emergency_contactWhereInput | emergency_contactWhereInput[]
    id?: BigIntFilter<"emergency_contact"> | bigint | number
    label?: StringNullableFilter<"emergency_contact"> | string | null
    number?: StringNullableFilter<"emergency_contact"> | string | null
  }

  export type emergency_contactOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
  }

  export type emergency_contactWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: emergency_contactWhereInput | emergency_contactWhereInput[]
    OR?: emergency_contactWhereInput[]
    NOT?: emergency_contactWhereInput | emergency_contactWhereInput[]
    label?: StringNullableFilter<"emergency_contact"> | string | null
    number?: StringNullableFilter<"emergency_contact"> | string | null
  }, "id">

  export type emergency_contactOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    _count?: emergency_contactCountOrderByAggregateInput
    _avg?: emergency_contactAvgOrderByAggregateInput
    _max?: emergency_contactMaxOrderByAggregateInput
    _min?: emergency_contactMinOrderByAggregateInput
    _sum?: emergency_contactSumOrderByAggregateInput
  }

  export type emergency_contactScalarWhereWithAggregatesInput = {
    AND?: emergency_contactScalarWhereWithAggregatesInput | emergency_contactScalarWhereWithAggregatesInput[]
    OR?: emergency_contactScalarWhereWithAggregatesInput[]
    NOT?: emergency_contactScalarWhereWithAggregatesInput | emergency_contactScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"emergency_contact"> | bigint | number
    label?: StringNullableWithAggregatesFilter<"emergency_contact"> | string | null
    number?: StringNullableWithAggregatesFilter<"emergency_contact"> | string | null
  }

  export type env_delimiterWhereInput = {
    AND?: env_delimiterWhereInput | env_delimiterWhereInput[]
    OR?: env_delimiterWhereInput[]
    NOT?: env_delimiterWhereInput | env_delimiterWhereInput[]
    id?: IntFilter<"env_delimiter"> | number
    created_at?: DateTimeFilter<"env_delimiter"> | Date | string
    updated_at?: DateTimeNullableFilter<"env_delimiter"> | Date | string | null
    env_id?: IntNullableFilter<"env_delimiter"> | number | null
    coordinates?: JsonNullableFilter<"env_delimiter">
    type?: StringNullableFilter<"env_delimiter"> | string | null
    environment?: XOR<EnvironmentNullableScalarRelationFilter, environmentWhereInput> | null
  }

  export type env_delimiterOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    env_id?: SortOrderInput | SortOrder
    coordinates?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    environment?: environmentOrderByWithRelationInput
  }

  export type env_delimiterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: env_delimiterWhereInput | env_delimiterWhereInput[]
    OR?: env_delimiterWhereInput[]
    NOT?: env_delimiterWhereInput | env_delimiterWhereInput[]
    created_at?: DateTimeFilter<"env_delimiter"> | Date | string
    updated_at?: DateTimeNullableFilter<"env_delimiter"> | Date | string | null
    env_id?: IntNullableFilter<"env_delimiter"> | number | null
    coordinates?: JsonNullableFilter<"env_delimiter">
    type?: StringNullableFilter<"env_delimiter"> | string | null
    environment?: XOR<EnvironmentNullableScalarRelationFilter, environmentWhereInput> | null
  }, "id">

  export type env_delimiterOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    env_id?: SortOrderInput | SortOrder
    coordinates?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    _count?: env_delimiterCountOrderByAggregateInput
    _avg?: env_delimiterAvgOrderByAggregateInput
    _max?: env_delimiterMaxOrderByAggregateInput
    _min?: env_delimiterMinOrderByAggregateInput
    _sum?: env_delimiterSumOrderByAggregateInput
  }

  export type env_delimiterScalarWhereWithAggregatesInput = {
    AND?: env_delimiterScalarWhereWithAggregatesInput | env_delimiterScalarWhereWithAggregatesInput[]
    OR?: env_delimiterScalarWhereWithAggregatesInput[]
    NOT?: env_delimiterScalarWhereWithAggregatesInput | env_delimiterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"env_delimiter"> | number
    created_at?: DateTimeWithAggregatesFilter<"env_delimiter"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"env_delimiter"> | Date | string | null
    env_id?: IntNullableWithAggregatesFilter<"env_delimiter"> | number | null
    coordinates?: JsonNullableWithAggregatesFilter<"env_delimiter">
    type?: StringNullableWithAggregatesFilter<"env_delimiter"> | string | null
  }

  export type env_userWhereInput = {
    AND?: env_userWhereInput | env_userWhereInput[]
    OR?: env_userWhereInput[]
    NOT?: env_userWhereInput | env_userWhereInput[]
    id?: IntFilter<"env_user"> | number
    user_id?: IntFilter<"env_user"> | number
    env_id?: IntNullableFilter<"env_user"> | number | null
    environment?: XOR<EnvironmentNullableScalarRelationFilter, environmentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type env_userOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    env_id?: SortOrderInput | SortOrder
    environment?: environmentOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type env_userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: env_userWhereInput | env_userWhereInput[]
    OR?: env_userWhereInput[]
    NOT?: env_userWhereInput | env_userWhereInput[]
    user_id?: IntFilter<"env_user"> | number
    env_id?: IntNullableFilter<"env_user"> | number | null
    environment?: XOR<EnvironmentNullableScalarRelationFilter, environmentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type env_userOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    env_id?: SortOrderInput | SortOrder
    _count?: env_userCountOrderByAggregateInput
    _avg?: env_userAvgOrderByAggregateInput
    _max?: env_userMaxOrderByAggregateInput
    _min?: env_userMinOrderByAggregateInput
    _sum?: env_userSumOrderByAggregateInput
  }

  export type env_userScalarWhereWithAggregatesInput = {
    AND?: env_userScalarWhereWithAggregatesInput | env_userScalarWhereWithAggregatesInput[]
    OR?: env_userScalarWhereWithAggregatesInput[]
    NOT?: env_userScalarWhereWithAggregatesInput | env_userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"env_user"> | number
    user_id?: IntWithAggregatesFilter<"env_user"> | number
    env_id?: IntNullableWithAggregatesFilter<"env_user"> | number | null
  }

  export type environmentWhereInput = {
    AND?: environmentWhereInput | environmentWhereInput[]
    OR?: environmentWhereInput[]
    NOT?: environmentWhereInput | environmentWhereInput[]
    id?: IntFilter<"environment"> | number
    name?: StringFilter<"environment"> | string
    description?: StringNullableFilter<"environment"> | string | null
    address?: StringNullableFilter<"environment"> | string | null
    created_at?: DateTimeNullableFilter<"environment"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"environment"> | Date | string | null
    map_id?: IntNullableFilter<"environment"> | number | null
    is_public?: BoolNullableFilter<"environment"> | boolean | null
    surface?: FloatNullableFilter<"environment"> | number | null
    env_delimiter?: Env_delimiterListRelationFilter
    env_user?: Env_userListRelationFilter
    map?: XOR<MapNullableScalarRelationFilter, mapWhereInput> | null
    poi?: PoiListRelationFilter
    zone?: ZoneListRelationFilter
  }

  export type environmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    map_id?: SortOrderInput | SortOrder
    is_public?: SortOrderInput | SortOrder
    surface?: SortOrderInput | SortOrder
    env_delimiter?: env_delimiterOrderByRelationAggregateInput
    env_user?: env_userOrderByRelationAggregateInput
    map?: mapOrderByWithRelationInput
    poi?: poiOrderByRelationAggregateInput
    zone?: zoneOrderByRelationAggregateInput
  }

  export type environmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: environmentWhereInput | environmentWhereInput[]
    OR?: environmentWhereInput[]
    NOT?: environmentWhereInput | environmentWhereInput[]
    name?: StringFilter<"environment"> | string
    description?: StringNullableFilter<"environment"> | string | null
    address?: StringNullableFilter<"environment"> | string | null
    created_at?: DateTimeNullableFilter<"environment"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"environment"> | Date | string | null
    map_id?: IntNullableFilter<"environment"> | number | null
    is_public?: BoolNullableFilter<"environment"> | boolean | null
    surface?: FloatNullableFilter<"environment"> | number | null
    env_delimiter?: Env_delimiterListRelationFilter
    env_user?: Env_userListRelationFilter
    map?: XOR<MapNullableScalarRelationFilter, mapWhereInput> | null
    poi?: PoiListRelationFilter
    zone?: ZoneListRelationFilter
  }, "id">

  export type environmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    map_id?: SortOrderInput | SortOrder
    is_public?: SortOrderInput | SortOrder
    surface?: SortOrderInput | SortOrder
    _count?: environmentCountOrderByAggregateInput
    _avg?: environmentAvgOrderByAggregateInput
    _max?: environmentMaxOrderByAggregateInput
    _min?: environmentMinOrderByAggregateInput
    _sum?: environmentSumOrderByAggregateInput
  }

  export type environmentScalarWhereWithAggregatesInput = {
    AND?: environmentScalarWhereWithAggregatesInput | environmentScalarWhereWithAggregatesInput[]
    OR?: environmentScalarWhereWithAggregatesInput[]
    NOT?: environmentScalarWhereWithAggregatesInput | environmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"environment"> | number
    name?: StringWithAggregatesFilter<"environment"> | string
    description?: StringNullableWithAggregatesFilter<"environment"> | string | null
    address?: StringNullableWithAggregatesFilter<"environment"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"environment"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"environment"> | Date | string | null
    map_id?: IntNullableWithAggregatesFilter<"environment"> | number | null
    is_public?: BoolNullableWithAggregatesFilter<"environment"> | boolean | null
    surface?: FloatNullableWithAggregatesFilter<"environment"> | number | null
  }

  export type expenseWhereInput = {
    AND?: expenseWhereInput | expenseWhereInput[]
    OR?: expenseWhereInput[]
    NOT?: expenseWhereInput | expenseWhereInput[]
    id?: BigIntFilter<"expense"> | bigint | number
    created_at?: DateTimeFilter<"expense"> | Date | string
    label?: StringNullableFilter<"expense"> | string | null
    amount?: FloatFilter<"expense"> | number
    category?: EnumExpenseCategoryNullableFilter<"expense"> | $Enums.ExpenseCategory | null
    description?: StringNullableFilter<"expense"> | string | null
    date?: DateTimeNullableFilter<"expense"> | Date | string | null
  }

  export type expenseOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    label?: SortOrderInput | SortOrder
    amount?: SortOrder
    category?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
  }

  export type expenseWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: expenseWhereInput | expenseWhereInput[]
    OR?: expenseWhereInput[]
    NOT?: expenseWhereInput | expenseWhereInput[]
    created_at?: DateTimeFilter<"expense"> | Date | string
    label?: StringNullableFilter<"expense"> | string | null
    amount?: FloatFilter<"expense"> | number
    category?: EnumExpenseCategoryNullableFilter<"expense"> | $Enums.ExpenseCategory | null
    description?: StringNullableFilter<"expense"> | string | null
    date?: DateTimeNullableFilter<"expense"> | Date | string | null
  }, "id">

  export type expenseOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    label?: SortOrderInput | SortOrder
    amount?: SortOrder
    category?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    _count?: expenseCountOrderByAggregateInput
    _avg?: expenseAvgOrderByAggregateInput
    _max?: expenseMaxOrderByAggregateInput
    _min?: expenseMinOrderByAggregateInput
    _sum?: expenseSumOrderByAggregateInput
  }

  export type expenseScalarWhereWithAggregatesInput = {
    AND?: expenseScalarWhereWithAggregatesInput | expenseScalarWhereWithAggregatesInput[]
    OR?: expenseScalarWhereWithAggregatesInput[]
    NOT?: expenseScalarWhereWithAggregatesInput | expenseScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"expense"> | bigint | number
    created_at?: DateTimeWithAggregatesFilter<"expense"> | Date | string
    label?: StringNullableWithAggregatesFilter<"expense"> | string | null
    amount?: FloatWithAggregatesFilter<"expense"> | number
    category?: EnumExpenseCategoryNullableWithAggregatesFilter<"expense"> | $Enums.ExpenseCategory | null
    description?: StringNullableWithAggregatesFilter<"expense"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"expense"> | Date | string | null
  }

  export type formatWhereInput = {
    AND?: formatWhereInput | formatWhereInput[]
    OR?: formatWhereInput[]
    NOT?: formatWhereInput | formatWhereInput[]
    id?: IntFilter<"format"> | number
    format?: StringFilter<"format"> | string
    map?: MapListRelationFilter
  }

  export type formatOrderByWithRelationInput = {
    id?: SortOrder
    format?: SortOrder
    map?: mapOrderByRelationAggregateInput
  }

  export type formatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: formatWhereInput | formatWhereInput[]
    OR?: formatWhereInput[]
    NOT?: formatWhereInput | formatWhereInput[]
    format?: StringFilter<"format"> | string
    map?: MapListRelationFilter
  }, "id">

  export type formatOrderByWithAggregationInput = {
    id?: SortOrder
    format?: SortOrder
    _count?: formatCountOrderByAggregateInput
    _avg?: formatAvgOrderByAggregateInput
    _max?: formatMaxOrderByAggregateInput
    _min?: formatMinOrderByAggregateInput
    _sum?: formatSumOrderByAggregateInput
  }

  export type formatScalarWhereWithAggregatesInput = {
    AND?: formatScalarWhereWithAggregatesInput | formatScalarWhereWithAggregatesInput[]
    OR?: formatScalarWhereWithAggregatesInput[]
    NOT?: formatScalarWhereWithAggregatesInput | formatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"format"> | number
    format?: StringWithAggregatesFilter<"format"> | string
  }

  export type helper_userWhereInput = {
    AND?: helper_userWhereInput | helper_userWhereInput[]
    OR?: helper_userWhereInput[]
    NOT?: helper_userWhereInput | helper_userWhereInput[]
    id?: IntFilter<"helper_user"> | number
    user_id?: IntNullableFilter<"helper_user"> | number | null
    helper_id?: IntNullableFilter<"helper_user"> | number | null
    state?: StringNullableFilter<"helper_user"> | string | null
    user_helper_user_helper_idTouser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    user_helper_user_user_idTouser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type helper_userOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    helper_id?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    user_helper_user_helper_idTouser?: userOrderByWithRelationInput
    user_helper_user_user_idTouser?: userOrderByWithRelationInput
  }

  export type helper_userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: helper_userWhereInput | helper_userWhereInput[]
    OR?: helper_userWhereInput[]
    NOT?: helper_userWhereInput | helper_userWhereInput[]
    user_id?: IntNullableFilter<"helper_user"> | number | null
    helper_id?: IntNullableFilter<"helper_user"> | number | null
    state?: StringNullableFilter<"helper_user"> | string | null
    user_helper_user_helper_idTouser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    user_helper_user_user_idTouser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type helper_userOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    helper_id?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    _count?: helper_userCountOrderByAggregateInput
    _avg?: helper_userAvgOrderByAggregateInput
    _max?: helper_userMaxOrderByAggregateInput
    _min?: helper_userMinOrderByAggregateInput
    _sum?: helper_userSumOrderByAggregateInput
  }

  export type helper_userScalarWhereWithAggregatesInput = {
    AND?: helper_userScalarWhereWithAggregatesInput | helper_userScalarWhereWithAggregatesInput[]
    OR?: helper_userScalarWhereWithAggregatesInput[]
    NOT?: helper_userScalarWhereWithAggregatesInput | helper_userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"helper_user"> | number
    user_id?: IntNullableWithAggregatesFilter<"helper_user"> | number | null
    helper_id?: IntNullableWithAggregatesFilter<"helper_user"> | number | null
    state?: StringNullableWithAggregatesFilter<"helper_user"> | string | null
  }

  export type intervention_historyWhereInput = {
    AND?: intervention_historyWhereInput | intervention_historyWhereInput[]
    OR?: intervention_historyWhereInput[]
    NOT?: intervention_historyWhereInput | intervention_historyWhereInput[]
    id?: IntFilter<"intervention_history"> | number
    device_id?: IntNullableFilter<"intervention_history"> | number | null
    maintenancier_id?: IntNullableFilter<"intervention_history"> | number | null
    scheduled_date?: DateTimeFilter<"intervention_history"> | Date | string
    completion_date?: DateTimeNullableFilter<"intervention_history"> | Date | string | null
    description?: StringNullableFilter<"intervention_history"> | string | null
    status?: StringNullableFilter<"intervention_history"> | string | null
    type?: Enumintervention_typeNullableFilter<"intervention_history"> | $Enums.intervention_type | null
    title?: StringNullableFilter<"intervention_history"> | string | null
    location?: StringNullableFilter<"intervention_history"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type intervention_historyOrderByWithRelationInput = {
    id?: SortOrder
    device_id?: SortOrderInput | SortOrder
    maintenancier_id?: SortOrderInput | SortOrder
    scheduled_date?: SortOrder
    completion_date?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type intervention_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: intervention_historyWhereInput | intervention_historyWhereInput[]
    OR?: intervention_historyWhereInput[]
    NOT?: intervention_historyWhereInput | intervention_historyWhereInput[]
    device_id?: IntNullableFilter<"intervention_history"> | number | null
    maintenancier_id?: IntNullableFilter<"intervention_history"> | number | null
    scheduled_date?: DateTimeFilter<"intervention_history"> | Date | string
    completion_date?: DateTimeNullableFilter<"intervention_history"> | Date | string | null
    description?: StringNullableFilter<"intervention_history"> | string | null
    status?: StringNullableFilter<"intervention_history"> | string | null
    type?: Enumintervention_typeNullableFilter<"intervention_history"> | $Enums.intervention_type | null
    title?: StringNullableFilter<"intervention_history"> | string | null
    location?: StringNullableFilter<"intervention_history"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type intervention_historyOrderByWithAggregationInput = {
    id?: SortOrder
    device_id?: SortOrderInput | SortOrder
    maintenancier_id?: SortOrderInput | SortOrder
    scheduled_date?: SortOrder
    completion_date?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    _count?: intervention_historyCountOrderByAggregateInput
    _avg?: intervention_historyAvgOrderByAggregateInput
    _max?: intervention_historyMaxOrderByAggregateInput
    _min?: intervention_historyMinOrderByAggregateInput
    _sum?: intervention_historySumOrderByAggregateInput
  }

  export type intervention_historyScalarWhereWithAggregatesInput = {
    AND?: intervention_historyScalarWhereWithAggregatesInput | intervention_historyScalarWhereWithAggregatesInput[]
    OR?: intervention_historyScalarWhereWithAggregatesInput[]
    NOT?: intervention_historyScalarWhereWithAggregatesInput | intervention_historyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"intervention_history"> | number
    device_id?: IntNullableWithAggregatesFilter<"intervention_history"> | number | null
    maintenancier_id?: IntNullableWithAggregatesFilter<"intervention_history"> | number | null
    scheduled_date?: DateTimeWithAggregatesFilter<"intervention_history"> | Date | string
    completion_date?: DateTimeNullableWithAggregatesFilter<"intervention_history"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"intervention_history"> | string | null
    status?: StringNullableWithAggregatesFilter<"intervention_history"> | string | null
    type?: Enumintervention_typeNullableWithAggregatesFilter<"intervention_history"> | $Enums.intervention_type | null
    title?: StringNullableWithAggregatesFilter<"intervention_history"> | string | null
    location?: StringNullableWithAggregatesFilter<"intervention_history"> | string | null
  }

  export type localisationWhereInput = {
    AND?: localisationWhereInput | localisationWhereInput[]
    OR?: localisationWhereInput[]
    NOT?: localisationWhereInput | localisationWhereInput[]
    id?: IntFilter<"localisation"> | number
    longitude?: StringFilter<"localisation"> | string
    latitude?: StringFilter<"localisation"> | string
    userId?: IntFilter<"localisation"> | number
    updated_at?: DateTimeFilter<"localisation"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type localisationOrderByWithRelationInput = {
    id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    userId?: SortOrder
    updated_at?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type localisationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: localisationWhereInput | localisationWhereInput[]
    OR?: localisationWhereInput[]
    NOT?: localisationWhereInput | localisationWhereInput[]
    longitude?: StringFilter<"localisation"> | string
    latitude?: StringFilter<"localisation"> | string
    updated_at?: DateTimeFilter<"localisation"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "userId">

  export type localisationOrderByWithAggregationInput = {
    id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    userId?: SortOrder
    updated_at?: SortOrder
    _count?: localisationCountOrderByAggregateInput
    _avg?: localisationAvgOrderByAggregateInput
    _max?: localisationMaxOrderByAggregateInput
    _min?: localisationMinOrderByAggregateInput
    _sum?: localisationSumOrderByAggregateInput
  }

  export type localisationScalarWhereWithAggregatesInput = {
    AND?: localisationScalarWhereWithAggregatesInput | localisationScalarWhereWithAggregatesInput[]
    OR?: localisationScalarWhereWithAggregatesInput[]
    NOT?: localisationScalarWhereWithAggregatesInput | localisationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"localisation"> | number
    longitude?: StringWithAggregatesFilter<"localisation"> | string
    latitude?: StringWithAggregatesFilter<"localisation"> | string
    userId?: IntWithAggregatesFilter<"localisation"> | number
    updated_at?: DateTimeWithAggregatesFilter<"localisation"> | Date | string
  }

  export type mapWhereInput = {
    AND?: mapWhereInput | mapWhereInput[]
    OR?: mapWhereInput[]
    NOT?: mapWhereInput | mapWhereInput[]
    id?: IntFilter<"map"> | number
    created_at?: DateTimeFilter<"map"> | Date | string
    format_id?: IntNullableFilter<"map"> | number | null
    environment?: EnvironmentListRelationFilter
    format?: XOR<FormatNullableScalarRelationFilter, formatWhereInput> | null
    poi?: PoiListRelationFilter
    zone?: ZoneListRelationFilter
  }

  export type mapOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    format_id?: SortOrderInput | SortOrder
    environment?: environmentOrderByRelationAggregateInput
    format?: formatOrderByWithRelationInput
    poi?: poiOrderByRelationAggregateInput
    zone?: zoneOrderByRelationAggregateInput
  }

  export type mapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: mapWhereInput | mapWhereInput[]
    OR?: mapWhereInput[]
    NOT?: mapWhereInput | mapWhereInput[]
    created_at?: DateTimeFilter<"map"> | Date | string
    format_id?: IntNullableFilter<"map"> | number | null
    environment?: EnvironmentListRelationFilter
    format?: XOR<FormatNullableScalarRelationFilter, formatWhereInput> | null
    poi?: PoiListRelationFilter
    zone?: ZoneListRelationFilter
  }, "id">

  export type mapOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    format_id?: SortOrderInput | SortOrder
    _count?: mapCountOrderByAggregateInput
    _avg?: mapAvgOrderByAggregateInput
    _max?: mapMaxOrderByAggregateInput
    _min?: mapMinOrderByAggregateInput
    _sum?: mapSumOrderByAggregateInput
  }

  export type mapScalarWhereWithAggregatesInput = {
    AND?: mapScalarWhereWithAggregatesInput | mapScalarWhereWithAggregatesInput[]
    OR?: mapScalarWhereWithAggregatesInput[]
    NOT?: mapScalarWhereWithAggregatesInput | mapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"map"> | number
    created_at?: DateTimeWithAggregatesFilter<"map"> | Date | string
    format_id?: IntNullableWithAggregatesFilter<"map"> | number | null
  }

  export type market_potentielWhereInput = {
    AND?: market_potentielWhereInput | market_potentielWhereInput[]
    OR?: market_potentielWhereInput[]
    NOT?: market_potentielWhereInput | market_potentielWhereInput[]
    id?: BigIntFilter<"market_potentiel"> | bigint | number
    created_at?: DateTimeFilter<"market_potentiel"> | Date | string
    city?: StringFilter<"market_potentiel"> | string
    potential_value?: IntNullableFilter<"market_potentiel"> | number | null
  }

  export type market_potentielOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    city?: SortOrder
    potential_value?: SortOrderInput | SortOrder
  }

  export type market_potentielWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    city?: string
    AND?: market_potentielWhereInput | market_potentielWhereInput[]
    OR?: market_potentielWhereInput[]
    NOT?: market_potentielWhereInput | market_potentielWhereInput[]
    created_at?: DateTimeFilter<"market_potentiel"> | Date | string
    potential_value?: IntNullableFilter<"market_potentiel"> | number | null
  }, "id" | "city">

  export type market_potentielOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    city?: SortOrder
    potential_value?: SortOrderInput | SortOrder
    _count?: market_potentielCountOrderByAggregateInput
    _avg?: market_potentielAvgOrderByAggregateInput
    _max?: market_potentielMaxOrderByAggregateInput
    _min?: market_potentielMinOrderByAggregateInput
    _sum?: market_potentielSumOrderByAggregateInput
  }

  export type market_potentielScalarWhereWithAggregatesInput = {
    AND?: market_potentielScalarWhereWithAggregatesInput | market_potentielScalarWhereWithAggregatesInput[]
    OR?: market_potentielScalarWhereWithAggregatesInput[]
    NOT?: market_potentielScalarWhereWithAggregatesInput | market_potentielScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"market_potentiel"> | bigint | number
    created_at?: DateTimeWithAggregatesFilter<"market_potentiel"> | Date | string
    city?: StringWithAggregatesFilter<"market_potentiel"> | string
    potential_value?: IntNullableWithAggregatesFilter<"market_potentiel"> | number | null
  }

  export type panne_historyWhereInput = {
    AND?: panne_historyWhereInput | panne_historyWhereInput[]
    OR?: panne_historyWhereInput[]
    NOT?: panne_historyWhereInput | panne_historyWhereInput[]
    id?: IntFilter<"panne_history"> | number
    alert_id?: IntNullableFilter<"panne_history"> | number | null
    alert?: XOR<AlertNullableScalarRelationFilter, alertWhereInput> | null
  }

  export type panne_historyOrderByWithRelationInput = {
    id?: SortOrder
    alert_id?: SortOrderInput | SortOrder
    alert?: alertOrderByWithRelationInput
  }

  export type panne_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: panne_historyWhereInput | panne_historyWhereInput[]
    OR?: panne_historyWhereInput[]
    NOT?: panne_historyWhereInput | panne_historyWhereInput[]
    alert_id?: IntNullableFilter<"panne_history"> | number | null
    alert?: XOR<AlertNullableScalarRelationFilter, alertWhereInput> | null
  }, "id">

  export type panne_historyOrderByWithAggregationInput = {
    id?: SortOrder
    alert_id?: SortOrderInput | SortOrder
    _count?: panne_historyCountOrderByAggregateInput
    _avg?: panne_historyAvgOrderByAggregateInput
    _max?: panne_historyMaxOrderByAggregateInput
    _min?: panne_historyMinOrderByAggregateInput
    _sum?: panne_historySumOrderByAggregateInput
  }

  export type panne_historyScalarWhereWithAggregatesInput = {
    AND?: panne_historyScalarWhereWithAggregatesInput | panne_historyScalarWhereWithAggregatesInput[]
    OR?: panne_historyScalarWhereWithAggregatesInput[]
    NOT?: panne_historyScalarWhereWithAggregatesInput | panne_historyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"panne_history"> | number
    alert_id?: IntNullableWithAggregatesFilter<"panne_history"> | number | null
  }

  export type poiWhereInput = {
    AND?: poiWhereInput | poiWhereInput[]
    OR?: poiWhereInput[]
    NOT?: poiWhereInput | poiWhereInput[]
    id?: IntFilter<"poi"> | number
    created_at?: DateTimeFilter<"poi"> | Date | string
    env_id?: IntNullableFilter<"poi"> | number | null
    category_id?: IntNullableFilter<"poi"> | number | null
    name?: StringNullableFilter<"poi"> | string | null
    description?: StringNullableFilter<"poi"> | string | null
    coordinates?: JsonNullableFilter<"poi">
    image_url?: StringNullableFilter<"poi"> | string | null
    map_id?: IntNullableFilter<"poi"> | number | null
    poi_category?: XOR<Poi_categoryNullableScalarRelationFilter, poi_categoryWhereInput> | null
    environment?: XOR<EnvironmentNullableScalarRelationFilter, environmentWhereInput> | null
    map?: XOR<MapNullableScalarRelationFilter, mapWhereInput> | null
    poi_zone?: Poi_zoneListRelationFilter
  }

  export type poiOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    env_id?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    coordinates?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    map_id?: SortOrderInput | SortOrder
    poi_category?: poi_categoryOrderByWithRelationInput
    environment?: environmentOrderByWithRelationInput
    map?: mapOrderByWithRelationInput
    poi_zone?: poi_zoneOrderByRelationAggregateInput
  }

  export type poiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: poiWhereInput | poiWhereInput[]
    OR?: poiWhereInput[]
    NOT?: poiWhereInput | poiWhereInput[]
    created_at?: DateTimeFilter<"poi"> | Date | string
    env_id?: IntNullableFilter<"poi"> | number | null
    category_id?: IntNullableFilter<"poi"> | number | null
    name?: StringNullableFilter<"poi"> | string | null
    description?: StringNullableFilter<"poi"> | string | null
    coordinates?: JsonNullableFilter<"poi">
    image_url?: StringNullableFilter<"poi"> | string | null
    map_id?: IntNullableFilter<"poi"> | number | null
    poi_category?: XOR<Poi_categoryNullableScalarRelationFilter, poi_categoryWhereInput> | null
    environment?: XOR<EnvironmentNullableScalarRelationFilter, environmentWhereInput> | null
    map?: XOR<MapNullableScalarRelationFilter, mapWhereInput> | null
    poi_zone?: Poi_zoneListRelationFilter
  }, "id">

  export type poiOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    env_id?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    coordinates?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    map_id?: SortOrderInput | SortOrder
    _count?: poiCountOrderByAggregateInput
    _avg?: poiAvgOrderByAggregateInput
    _max?: poiMaxOrderByAggregateInput
    _min?: poiMinOrderByAggregateInput
    _sum?: poiSumOrderByAggregateInput
  }

  export type poiScalarWhereWithAggregatesInput = {
    AND?: poiScalarWhereWithAggregatesInput | poiScalarWhereWithAggregatesInput[]
    OR?: poiScalarWhereWithAggregatesInput[]
    NOT?: poiScalarWhereWithAggregatesInput | poiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"poi"> | number
    created_at?: DateTimeWithAggregatesFilter<"poi"> | Date | string
    env_id?: IntNullableWithAggregatesFilter<"poi"> | number | null
    category_id?: IntNullableWithAggregatesFilter<"poi"> | number | null
    name?: StringNullableWithAggregatesFilter<"poi"> | string | null
    description?: StringNullableWithAggregatesFilter<"poi"> | string | null
    coordinates?: JsonNullableWithAggregatesFilter<"poi">
    image_url?: StringNullableWithAggregatesFilter<"poi"> | string | null
    map_id?: IntNullableWithAggregatesFilter<"poi"> | number | null
  }

  export type poi_categoryWhereInput = {
    AND?: poi_categoryWhereInput | poi_categoryWhereInput[]
    OR?: poi_categoryWhereInput[]
    NOT?: poi_categoryWhereInput | poi_categoryWhereInput[]
    id?: IntFilter<"poi_category"> | number
    category?: StringFilter<"poi_category"> | string
    poi?: PoiListRelationFilter
  }

  export type poi_categoryOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    poi?: poiOrderByRelationAggregateInput
  }

  export type poi_categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: poi_categoryWhereInput | poi_categoryWhereInput[]
    OR?: poi_categoryWhereInput[]
    NOT?: poi_categoryWhereInput | poi_categoryWhereInput[]
    category?: StringFilter<"poi_category"> | string
    poi?: PoiListRelationFilter
  }, "id">

  export type poi_categoryOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    _count?: poi_categoryCountOrderByAggregateInput
    _avg?: poi_categoryAvgOrderByAggregateInput
    _max?: poi_categoryMaxOrderByAggregateInput
    _min?: poi_categoryMinOrderByAggregateInput
    _sum?: poi_categorySumOrderByAggregateInput
  }

  export type poi_categoryScalarWhereWithAggregatesInput = {
    AND?: poi_categoryScalarWhereWithAggregatesInput | poi_categoryScalarWhereWithAggregatesInput[]
    OR?: poi_categoryScalarWhereWithAggregatesInput[]
    NOT?: poi_categoryScalarWhereWithAggregatesInput | poi_categoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"poi_category"> | number
    category?: StringWithAggregatesFilter<"poi_category"> | string
  }

  export type poi_zoneWhereInput = {
    AND?: poi_zoneWhereInput | poi_zoneWhereInput[]
    OR?: poi_zoneWhereInput[]
    NOT?: poi_zoneWhereInput | poi_zoneWhereInput[]
    id?: IntFilter<"poi_zone"> | number
    created_at?: DateTimeFilter<"poi_zone"> | Date | string
    poi_id?: IntNullableFilter<"poi_zone"> | number | null
    zone_id?: IntNullableFilter<"poi_zone"> | number | null
    poi?: XOR<PoiNullableScalarRelationFilter, poiWhereInput> | null
    zone?: XOR<ZoneNullableScalarRelationFilter, zoneWhereInput> | null
  }

  export type poi_zoneOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    poi_id?: SortOrderInput | SortOrder
    zone_id?: SortOrderInput | SortOrder
    poi?: poiOrderByWithRelationInput
    zone?: zoneOrderByWithRelationInput
  }

  export type poi_zoneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: poi_zoneWhereInput | poi_zoneWhereInput[]
    OR?: poi_zoneWhereInput[]
    NOT?: poi_zoneWhereInput | poi_zoneWhereInput[]
    created_at?: DateTimeFilter<"poi_zone"> | Date | string
    poi_id?: IntNullableFilter<"poi_zone"> | number | null
    zone_id?: IntNullableFilter<"poi_zone"> | number | null
    poi?: XOR<PoiNullableScalarRelationFilter, poiWhereInput> | null
    zone?: XOR<ZoneNullableScalarRelationFilter, zoneWhereInput> | null
  }, "id">

  export type poi_zoneOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    poi_id?: SortOrderInput | SortOrder
    zone_id?: SortOrderInput | SortOrder
    _count?: poi_zoneCountOrderByAggregateInput
    _avg?: poi_zoneAvgOrderByAggregateInput
    _max?: poi_zoneMaxOrderByAggregateInput
    _min?: poi_zoneMinOrderByAggregateInput
    _sum?: poi_zoneSumOrderByAggregateInput
  }

  export type poi_zoneScalarWhereWithAggregatesInput = {
    AND?: poi_zoneScalarWhereWithAggregatesInput | poi_zoneScalarWhereWithAggregatesInput[]
    OR?: poi_zoneScalarWhereWithAggregatesInput[]
    NOT?: poi_zoneScalarWhereWithAggregatesInput | poi_zoneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"poi_zone"> | number
    created_at?: DateTimeWithAggregatesFilter<"poi_zone"> | Date | string
    poi_id?: IntNullableWithAggregatesFilter<"poi_zone"> | number | null
    zone_id?: IntNullableWithAggregatesFilter<"poi_zone"> | number | null
  }

  export type pricingWhereInput = {
    AND?: pricingWhereInput | pricingWhereInput[]
    OR?: pricingWhereInput[]
    NOT?: pricingWhereInput | pricingWhereInput[]
    id?: IntFilter<"pricing"> | number
    attribute?: StringNullableFilter<"pricing"> | string | null
    price?: FloatNullableFilter<"pricing"> | number | null
  }

  export type pricingOrderByWithRelationInput = {
    id?: SortOrder
    attribute?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
  }

  export type pricingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    attribute?: string
    AND?: pricingWhereInput | pricingWhereInput[]
    OR?: pricingWhereInput[]
    NOT?: pricingWhereInput | pricingWhereInput[]
    price?: FloatNullableFilter<"pricing"> | number | null
  }, "id" | "attribute">

  export type pricingOrderByWithAggregationInput = {
    id?: SortOrder
    attribute?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    _count?: pricingCountOrderByAggregateInput
    _avg?: pricingAvgOrderByAggregateInput
    _max?: pricingMaxOrderByAggregateInput
    _min?: pricingMinOrderByAggregateInput
    _sum?: pricingSumOrderByAggregateInput
  }

  export type pricingScalarWhereWithAggregatesInput = {
    AND?: pricingScalarWhereWithAggregatesInput | pricingScalarWhereWithAggregatesInput[]
    OR?: pricingScalarWhereWithAggregatesInput[]
    NOT?: pricingScalarWhereWithAggregatesInput | pricingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pricing"> | number
    attribute?: StringNullableWithAggregatesFilter<"pricing"> | string | null
    price?: FloatNullableWithAggregatesFilter<"pricing"> | number | null
  }

  export type purchase_historyWhereInput = {
    AND?: purchase_historyWhereInput | purchase_historyWhereInput[]
    OR?: purchase_historyWhereInput[]
    NOT?: purchase_historyWhereInput | purchase_historyWhereInput[]
    id?: IntFilter<"purchase_history"> | number
    date?: DateTimeFilter<"purchase_history"> | Date | string
    user_id?: IntNullableFilter<"purchase_history"> | number | null
    device_id?: IntNullableFilter<"purchase_history"> | number | null
    public?: BoolNullableFilter<"purchase_history"> | boolean | null
    device?: XOR<DeviceNullableScalarRelationFilter, deviceWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type purchase_historyOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    user_id?: SortOrderInput | SortOrder
    device_id?: SortOrderInput | SortOrder
    public?: SortOrderInput | SortOrder
    device?: deviceOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type purchase_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: purchase_historyWhereInput | purchase_historyWhereInput[]
    OR?: purchase_historyWhereInput[]
    NOT?: purchase_historyWhereInput | purchase_historyWhereInput[]
    date?: DateTimeFilter<"purchase_history"> | Date | string
    user_id?: IntNullableFilter<"purchase_history"> | number | null
    device_id?: IntNullableFilter<"purchase_history"> | number | null
    public?: BoolNullableFilter<"purchase_history"> | boolean | null
    device?: XOR<DeviceNullableScalarRelationFilter, deviceWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type purchase_historyOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    user_id?: SortOrderInput | SortOrder
    device_id?: SortOrderInput | SortOrder
    public?: SortOrderInput | SortOrder
    _count?: purchase_historyCountOrderByAggregateInput
    _avg?: purchase_historyAvgOrderByAggregateInput
    _max?: purchase_historyMaxOrderByAggregateInput
    _min?: purchase_historyMinOrderByAggregateInput
    _sum?: purchase_historySumOrderByAggregateInput
  }

  export type purchase_historyScalarWhereWithAggregatesInput = {
    AND?: purchase_historyScalarWhereWithAggregatesInput | purchase_historyScalarWhereWithAggregatesInput[]
    OR?: purchase_historyScalarWhereWithAggregatesInput[]
    NOT?: purchase_historyScalarWhereWithAggregatesInput | purchase_historyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"purchase_history"> | number
    date?: DateTimeWithAggregatesFilter<"purchase_history"> | Date | string
    user_id?: IntNullableWithAggregatesFilter<"purchase_history"> | number | null
    device_id?: IntNullableWithAggregatesFilter<"purchase_history"> | number | null
    public?: BoolNullableWithAggregatesFilter<"purchase_history"> | boolean | null
  }

  export type state_typeWhereInput = {
    AND?: state_typeWhereInput | state_typeWhereInput[]
    OR?: state_typeWhereInput[]
    NOT?: state_typeWhereInput | state_typeWhereInput[]
    id?: IntFilter<"state_type"> | number
    state?: StringFilter<"state_type"> | string
    device?: DeviceListRelationFilter
  }

  export type state_typeOrderByWithRelationInput = {
    id?: SortOrder
    state?: SortOrder
    device?: deviceOrderByRelationAggregateInput
  }

  export type state_typeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    state?: string
    AND?: state_typeWhereInput | state_typeWhereInput[]
    OR?: state_typeWhereInput[]
    NOT?: state_typeWhereInput | state_typeWhereInput[]
    device?: DeviceListRelationFilter
  }, "id" | "state">

  export type state_typeOrderByWithAggregationInput = {
    id?: SortOrder
    state?: SortOrder
    _count?: state_typeCountOrderByAggregateInput
    _avg?: state_typeAvgOrderByAggregateInput
    _max?: state_typeMaxOrderByAggregateInput
    _min?: state_typeMinOrderByAggregateInput
    _sum?: state_typeSumOrderByAggregateInput
  }

  export type state_typeScalarWhereWithAggregatesInput = {
    AND?: state_typeScalarWhereWithAggregatesInput | state_typeScalarWhereWithAggregatesInput[]
    OR?: state_typeScalarWhereWithAggregatesInput[]
    NOT?: state_typeScalarWhereWithAggregatesInput | state_typeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"state_type"> | number
    state?: StringWithAggregatesFilter<"state_type"> | string
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    created_at?: DateTimeFilter<"user"> | Date | string
    family_name?: StringNullableFilter<"user"> | string | null
    first_name?: StringNullableFilter<"user"> | string | null
    phone_number?: StringNullableFilter<"user"> | string | null
    password?: StringNullableFilter<"user"> | string | null
    userTypeId?: IntNullableFilter<"user"> | number | null
    email?: StringNullableFilter<"user"> | string | null
    sex?: StringNullableFilter<"user"> | string | null
    street?: StringNullableFilter<"user"> | string | null
    city?: StringNullableFilter<"user"> | string | null
    birth_date?: DateTimeNullableFilter<"user"> | Date | string | null
    Identifier?: StringNullableFilter<"user"> | string | null
    device?: DeviceListRelationFilter
    env_user?: Env_userListRelationFilter
    helper_user_helper_user_helper_idTouser?: Helper_userListRelationFilter
    helper_user_helper_user_user_idTouser?: Helper_userListRelationFilter
    intervention_history?: Intervention_historyListRelationFilter
    localisation?: XOR<LocalisationNullableScalarRelationFilter, localisationWhereInput> | null
    purchase_history?: Purchase_historyListRelationFilter
    user_type?: XOR<User_typeNullableScalarRelationFilter, user_typeWhereInput> | null
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    family_name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    userTypeId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    sex?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    Identifier?: SortOrderInput | SortOrder
    device?: deviceOrderByRelationAggregateInput
    env_user?: env_userOrderByRelationAggregateInput
    helper_user_helper_user_helper_idTouser?: helper_userOrderByRelationAggregateInput
    helper_user_helper_user_user_idTouser?: helper_userOrderByRelationAggregateInput
    intervention_history?: intervention_historyOrderByRelationAggregateInput
    localisation?: localisationOrderByWithRelationInput
    purchase_history?: purchase_historyOrderByRelationAggregateInput
    user_type?: user_typeOrderByWithRelationInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    created_at?: DateTimeFilter<"user"> | Date | string
    family_name?: StringNullableFilter<"user"> | string | null
    first_name?: StringNullableFilter<"user"> | string | null
    phone_number?: StringNullableFilter<"user"> | string | null
    password?: StringNullableFilter<"user"> | string | null
    userTypeId?: IntNullableFilter<"user"> | number | null
    sex?: StringNullableFilter<"user"> | string | null
    street?: StringNullableFilter<"user"> | string | null
    city?: StringNullableFilter<"user"> | string | null
    birth_date?: DateTimeNullableFilter<"user"> | Date | string | null
    Identifier?: StringNullableFilter<"user"> | string | null
    device?: DeviceListRelationFilter
    env_user?: Env_userListRelationFilter
    helper_user_helper_user_helper_idTouser?: Helper_userListRelationFilter
    helper_user_helper_user_user_idTouser?: Helper_userListRelationFilter
    intervention_history?: Intervention_historyListRelationFilter
    localisation?: XOR<LocalisationNullableScalarRelationFilter, localisationWhereInput> | null
    purchase_history?: Purchase_historyListRelationFilter
    user_type?: XOR<User_typeNullableScalarRelationFilter, user_typeWhereInput> | null
  }, "id" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    family_name?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    userTypeId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    sex?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    Identifier?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    created_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    family_name?: StringNullableWithAggregatesFilter<"user"> | string | null
    first_name?: StringNullableWithAggregatesFilter<"user"> | string | null
    phone_number?: StringNullableWithAggregatesFilter<"user"> | string | null
    password?: StringNullableWithAggregatesFilter<"user"> | string | null
    userTypeId?: IntNullableWithAggregatesFilter<"user"> | number | null
    email?: StringNullableWithAggregatesFilter<"user"> | string | null
    sex?: StringNullableWithAggregatesFilter<"user"> | string | null
    street?: StringNullableWithAggregatesFilter<"user"> | string | null
    city?: StringNullableWithAggregatesFilter<"user"> | string | null
    birth_date?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    Identifier?: StringNullableWithAggregatesFilter<"user"> | string | null
  }

  export type user_typeWhereInput = {
    AND?: user_typeWhereInput | user_typeWhereInput[]
    OR?: user_typeWhereInput[]
    NOT?: user_typeWhereInput | user_typeWhereInput[]
    id?: IntFilter<"user_type"> | number
    created_at?: DateTimeFilter<"user_type"> | Date | string
    type?: StringNullableFilter<"user_type"> | string | null
    user?: UserListRelationFilter
  }

  export type user_typeOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    type?: SortOrderInput | SortOrder
    user?: userOrderByRelationAggregateInput
  }

  export type user_typeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: user_typeWhereInput | user_typeWhereInput[]
    OR?: user_typeWhereInput[]
    NOT?: user_typeWhereInput | user_typeWhereInput[]
    created_at?: DateTimeFilter<"user_type"> | Date | string
    type?: StringNullableFilter<"user_type"> | string | null
    user?: UserListRelationFilter
  }, "id">

  export type user_typeOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    type?: SortOrderInput | SortOrder
    _count?: user_typeCountOrderByAggregateInput
    _avg?: user_typeAvgOrderByAggregateInput
    _max?: user_typeMaxOrderByAggregateInput
    _min?: user_typeMinOrderByAggregateInput
    _sum?: user_typeSumOrderByAggregateInput
  }

  export type user_typeScalarWhereWithAggregatesInput = {
    AND?: user_typeScalarWhereWithAggregatesInput | user_typeScalarWhereWithAggregatesInput[]
    OR?: user_typeScalarWhereWithAggregatesInput[]
    NOT?: user_typeScalarWhereWithAggregatesInput | user_typeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_type"> | number
    created_at?: DateTimeWithAggregatesFilter<"user_type"> | Date | string
    type?: StringNullableWithAggregatesFilter<"user_type"> | string | null
  }

  export type zoneWhereInput = {
    AND?: zoneWhereInput | zoneWhereInput[]
    OR?: zoneWhereInput[]
    NOT?: zoneWhereInput | zoneWhereInput[]
    id?: IntFilter<"zone"> | number
    created_at?: DateTimeFilter<"zone"> | Date | string
    env_id?: IntNullableFilter<"zone"> | number | null
    name?: StringNullableFilter<"zone"> | string | null
    description?: StringNullableFilter<"zone"> | string | null
    type_id?: IntNullableFilter<"zone"> | number | null
    coordinates?: JsonNullableFilter<"zone">
    updated_at?: DateTimeNullableFilter<"zone"> | Date | string | null
    map_id?: IntNullableFilter<"zone"> | number | null
    zone_type?: IntNullableFilter<"zone"> | number | null
    poi_zone?: Poi_zoneListRelationFilter
    environment?: XOR<EnvironmentNullableScalarRelationFilter, environmentWhereInput> | null
    map?: XOR<MapNullableScalarRelationFilter, mapWhereInput> | null
    zone_type_zone_type_idTozone_type?: XOR<Zone_typeNullableScalarRelationFilter, zone_typeWhereInput> | null
    zone_type_zone_zone_typeTozone_type?: XOR<Zone_typeNullableScalarRelationFilter, zone_typeWhereInput> | null
  }

  export type zoneOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    env_id?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type_id?: SortOrderInput | SortOrder
    coordinates?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    map_id?: SortOrderInput | SortOrder
    zone_type?: SortOrderInput | SortOrder
    poi_zone?: poi_zoneOrderByRelationAggregateInput
    environment?: environmentOrderByWithRelationInput
    map?: mapOrderByWithRelationInput
    zone_type_zone_type_idTozone_type?: zone_typeOrderByWithRelationInput
    zone_type_zone_zone_typeTozone_type?: zone_typeOrderByWithRelationInput
  }

  export type zoneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: zoneWhereInput | zoneWhereInput[]
    OR?: zoneWhereInput[]
    NOT?: zoneWhereInput | zoneWhereInput[]
    created_at?: DateTimeFilter<"zone"> | Date | string
    env_id?: IntNullableFilter<"zone"> | number | null
    name?: StringNullableFilter<"zone"> | string | null
    description?: StringNullableFilter<"zone"> | string | null
    type_id?: IntNullableFilter<"zone"> | number | null
    coordinates?: JsonNullableFilter<"zone">
    updated_at?: DateTimeNullableFilter<"zone"> | Date | string | null
    map_id?: IntNullableFilter<"zone"> | number | null
    zone_type?: IntNullableFilter<"zone"> | number | null
    poi_zone?: Poi_zoneListRelationFilter
    environment?: XOR<EnvironmentNullableScalarRelationFilter, environmentWhereInput> | null
    map?: XOR<MapNullableScalarRelationFilter, mapWhereInput> | null
    zone_type_zone_type_idTozone_type?: XOR<Zone_typeNullableScalarRelationFilter, zone_typeWhereInput> | null
    zone_type_zone_zone_typeTozone_type?: XOR<Zone_typeNullableScalarRelationFilter, zone_typeWhereInput> | null
  }, "id">

  export type zoneOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    env_id?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type_id?: SortOrderInput | SortOrder
    coordinates?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    map_id?: SortOrderInput | SortOrder
    zone_type?: SortOrderInput | SortOrder
    _count?: zoneCountOrderByAggregateInput
    _avg?: zoneAvgOrderByAggregateInput
    _max?: zoneMaxOrderByAggregateInput
    _min?: zoneMinOrderByAggregateInput
    _sum?: zoneSumOrderByAggregateInput
  }

  export type zoneScalarWhereWithAggregatesInput = {
    AND?: zoneScalarWhereWithAggregatesInput | zoneScalarWhereWithAggregatesInput[]
    OR?: zoneScalarWhereWithAggregatesInput[]
    NOT?: zoneScalarWhereWithAggregatesInput | zoneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"zone"> | number
    created_at?: DateTimeWithAggregatesFilter<"zone"> | Date | string
    env_id?: IntNullableWithAggregatesFilter<"zone"> | number | null
    name?: StringNullableWithAggregatesFilter<"zone"> | string | null
    description?: StringNullableWithAggregatesFilter<"zone"> | string | null
    type_id?: IntNullableWithAggregatesFilter<"zone"> | number | null
    coordinates?: JsonNullableWithAggregatesFilter<"zone">
    updated_at?: DateTimeNullableWithAggregatesFilter<"zone"> | Date | string | null
    map_id?: IntNullableWithAggregatesFilter<"zone"> | number | null
    zone_type?: IntNullableWithAggregatesFilter<"zone"> | number | null
  }

  export type zone_typeWhereInput = {
    AND?: zone_typeWhereInput | zone_typeWhereInput[]
    OR?: zone_typeWhereInput[]
    NOT?: zone_typeWhereInput | zone_typeWhereInput[]
    id?: IntFilter<"zone_type"> | number
    created_at?: DateTimeFilter<"zone_type"> | Date | string
    type?: StringNullableFilter<"zone_type"> | string | null
    color?: StringNullableFilter<"zone_type"> | string | null
    icon?: StringNullableFilter<"zone_type"> | string | null
    name?: StringNullableFilter<"zone_type"> | string | null
    description?: StringNullableFilter<"zone_type"> | string | null
    priority?: StringNullableFilter<"zone_type"> | string | null
    accessible?: BoolNullableFilter<"zone_type"> | boolean | null
    zone_zone_type_idTozone_type?: ZoneListRelationFilter
    zone_zone_zone_typeTozone_type?: ZoneListRelationFilter
  }

  export type zone_typeOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    type?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    accessible?: SortOrderInput | SortOrder
    zone_zone_type_idTozone_type?: zoneOrderByRelationAggregateInput
    zone_zone_zone_typeTozone_type?: zoneOrderByRelationAggregateInput
  }

  export type zone_typeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: zone_typeWhereInput | zone_typeWhereInput[]
    OR?: zone_typeWhereInput[]
    NOT?: zone_typeWhereInput | zone_typeWhereInput[]
    created_at?: DateTimeFilter<"zone_type"> | Date | string
    type?: StringNullableFilter<"zone_type"> | string | null
    color?: StringNullableFilter<"zone_type"> | string | null
    icon?: StringNullableFilter<"zone_type"> | string | null
    name?: StringNullableFilter<"zone_type"> | string | null
    description?: StringNullableFilter<"zone_type"> | string | null
    priority?: StringNullableFilter<"zone_type"> | string | null
    accessible?: BoolNullableFilter<"zone_type"> | boolean | null
    zone_zone_type_idTozone_type?: ZoneListRelationFilter
    zone_zone_zone_typeTozone_type?: ZoneListRelationFilter
  }, "id">

  export type zone_typeOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    type?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    accessible?: SortOrderInput | SortOrder
    _count?: zone_typeCountOrderByAggregateInput
    _avg?: zone_typeAvgOrderByAggregateInput
    _max?: zone_typeMaxOrderByAggregateInput
    _min?: zone_typeMinOrderByAggregateInput
    _sum?: zone_typeSumOrderByAggregateInput
  }

  export type zone_typeScalarWhereWithAggregatesInput = {
    AND?: zone_typeScalarWhereWithAggregatesInput | zone_typeScalarWhereWithAggregatesInput[]
    OR?: zone_typeScalarWhereWithAggregatesInput[]
    NOT?: zone_typeScalarWhereWithAggregatesInput | zone_typeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"zone_type"> | number
    created_at?: DateTimeWithAggregatesFilter<"zone_type"> | Date | string
    type?: StringNullableWithAggregatesFilter<"zone_type"> | string | null
    color?: StringNullableWithAggregatesFilter<"zone_type"> | string | null
    icon?: StringNullableWithAggregatesFilter<"zone_type"> | string | null
    name?: StringNullableWithAggregatesFilter<"zone_type"> | string | null
    description?: StringNullableWithAggregatesFilter<"zone_type"> | string | null
    priority?: StringNullableWithAggregatesFilter<"zone_type"> | string | null
    accessible?: BoolNullableWithAggregatesFilter<"zone_type"> | boolean | null
  }

  export type alertCreateInput = {
    type: string
    time: Date | string
    date: Date | string
    zone: string
    status: string
    level: $Enums.level_new
    device?: deviceCreateNestedOneWithoutAlertInput
    panne_history?: panne_historyCreateNestedManyWithoutAlertInput
  }

  export type alertUncheckedCreateInput = {
    id?: number
    type: string
    time: Date | string
    date: Date | string
    zone: string
    status: string
    level: $Enums.level_new
    device_id?: number | null
    panne_history?: panne_historyUncheckedCreateNestedManyWithoutAlertInput
  }

  export type alertUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: Enumlevel_newFieldUpdateOperationsInput | $Enums.level_new
    device?: deviceUpdateOneWithoutAlertNestedInput
    panne_history?: panne_historyUpdateManyWithoutAlertNestedInput
  }

  export type alertUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: Enumlevel_newFieldUpdateOperationsInput | $Enums.level_new
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    panne_history?: panne_historyUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type alertCreateManyInput = {
    id?: number
    type: string
    time: Date | string
    date: Date | string
    zone: string
    status: string
    level: $Enums.level_new
    device_id?: number | null
  }

  export type alertUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: Enumlevel_newFieldUpdateOperationsInput | $Enums.level_new
  }

  export type alertUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: Enumlevel_newFieldUpdateOperationsInput | $Enums.level_new
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type deviceCreateInput = {
    mac_address: string
    software_version: string
    date_of_service: Date | string
    comm_state: boolean
    connection_state?: boolean | null
    battery_capacity?: number
    price?: number | null
    alert?: alertCreateNestedManyWithoutDeviceInput
    state_type: state_typeCreateNestedOneWithoutDeviceInput
    device_type: device_typeCreateNestedOneWithoutDeviceInput
    user?: userCreateNestedOneWithoutDeviceInput
    purchase_history?: purchase_historyCreateNestedManyWithoutDeviceInput
  }

  export type deviceUncheckedCreateInput = {
    id?: number
    type_id: number
    state_type_id: number
    user_id?: number | null
    mac_address: string
    software_version: string
    date_of_service: Date | string
    comm_state: boolean
    connection_state?: boolean | null
    battery_capacity?: number
    price?: number | null
    alert?: alertUncheckedCreateNestedManyWithoutDeviceInput
    purchase_history?: purchase_historyUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type deviceUpdateInput = {
    mac_address?: StringFieldUpdateOperationsInput | string
    software_version?: StringFieldUpdateOperationsInput | string
    date_of_service?: DateTimeFieldUpdateOperationsInput | Date | string
    comm_state?: BoolFieldUpdateOperationsInput | boolean
    connection_state?: NullableBoolFieldUpdateOperationsInput | boolean | null
    battery_capacity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    alert?: alertUpdateManyWithoutDeviceNestedInput
    state_type?: state_typeUpdateOneRequiredWithoutDeviceNestedInput
    device_type?: device_typeUpdateOneRequiredWithoutDeviceNestedInput
    user?: userUpdateOneWithoutDeviceNestedInput
    purchase_history?: purchase_historyUpdateManyWithoutDeviceNestedInput
  }

  export type deviceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    state_type_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    mac_address?: StringFieldUpdateOperationsInput | string
    software_version?: StringFieldUpdateOperationsInput | string
    date_of_service?: DateTimeFieldUpdateOperationsInput | Date | string
    comm_state?: BoolFieldUpdateOperationsInput | boolean
    connection_state?: NullableBoolFieldUpdateOperationsInput | boolean | null
    battery_capacity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    alert?: alertUncheckedUpdateManyWithoutDeviceNestedInput
    purchase_history?: purchase_historyUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type deviceCreateManyInput = {
    id?: number
    type_id: number
    state_type_id: number
    user_id?: number | null
    mac_address: string
    software_version: string
    date_of_service: Date | string
    comm_state: boolean
    connection_state?: boolean | null
    battery_capacity?: number
    price?: number | null
  }

  export type deviceUpdateManyMutationInput = {
    mac_address?: StringFieldUpdateOperationsInput | string
    software_version?: StringFieldUpdateOperationsInput | string
    date_of_service?: DateTimeFieldUpdateOperationsInput | Date | string
    comm_state?: BoolFieldUpdateOperationsInput | boolean
    connection_state?: NullableBoolFieldUpdateOperationsInput | boolean | null
    battery_capacity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type deviceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    state_type_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    mac_address?: StringFieldUpdateOperationsInput | string
    software_version?: StringFieldUpdateOperationsInput | string
    date_of_service?: DateTimeFieldUpdateOperationsInput | Date | string
    comm_state?: BoolFieldUpdateOperationsInput | boolean
    connection_state?: NullableBoolFieldUpdateOperationsInput | boolean | null
    battery_capacity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type device_typeCreateInput = {
    type: string
    device?: deviceCreateNestedManyWithoutDevice_typeInput
  }

  export type device_typeUncheckedCreateInput = {
    id?: number
    type: string
    device?: deviceUncheckedCreateNestedManyWithoutDevice_typeInput
  }

  export type device_typeUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    device?: deviceUpdateManyWithoutDevice_typeNestedInput
  }

  export type device_typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    device?: deviceUncheckedUpdateManyWithoutDevice_typeNestedInput
  }

  export type device_typeCreateManyInput = {
    id?: number
    type: string
  }

  export type device_typeUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
  }

  export type device_typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type emergency_contactCreateInput = {
    id?: bigint | number
    label?: string | null
    number?: string | null
  }

  export type emergency_contactUncheckedCreateInput = {
    id?: bigint | number
    label?: string | null
    number?: string | null
  }

  export type emergency_contactUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type emergency_contactUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type emergency_contactCreateManyInput = {
    id?: bigint | number
    label?: string | null
    number?: string | null
  }

  export type emergency_contactUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type emergency_contactUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type env_delimiterCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    type?: string | null
    environment?: environmentCreateNestedOneWithoutEnv_delimiterInput
  }

  export type env_delimiterUncheckedCreateInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string | null
    env_id?: number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    type?: string | null
  }

  export type env_delimiterUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: environmentUpdateOneWithoutEnv_delimiterNestedInput
  }

  export type env_delimiterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type env_delimiterCreateManyInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string | null
    env_id?: number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    type?: string | null
  }

  export type env_delimiterUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type env_delimiterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type env_userCreateInput = {
    environment?: environmentCreateNestedOneWithoutEnv_userInput
    user: userCreateNestedOneWithoutEnv_userInput
  }

  export type env_userUncheckedCreateInput = {
    id?: number
    user_id: number
    env_id?: number | null
  }

  export type env_userUpdateInput = {
    environment?: environmentUpdateOneWithoutEnv_userNestedInput
    user?: userUpdateOneRequiredWithoutEnv_userNestedInput
  }

  export type env_userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type env_userCreateManyInput = {
    id?: number
    user_id: number
    env_id?: number | null
  }

  export type env_userUpdateManyMutationInput = {

  }

  export type env_userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type environmentCreateInput = {
    name: string
    description?: string | null
    address?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_public?: boolean | null
    surface?: number | null
    env_delimiter?: env_delimiterCreateNestedManyWithoutEnvironmentInput
    env_user?: env_userCreateNestedManyWithoutEnvironmentInput
    map?: mapCreateNestedOneWithoutEnvironmentInput
    poi?: poiCreateNestedManyWithoutEnvironmentInput
    zone?: zoneCreateNestedManyWithoutEnvironmentInput
  }

  export type environmentUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    address?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    map_id?: number | null
    is_public?: boolean | null
    surface?: number | null
    env_delimiter?: env_delimiterUncheckedCreateNestedManyWithoutEnvironmentInput
    env_user?: env_userUncheckedCreateNestedManyWithoutEnvironmentInput
    poi?: poiUncheckedCreateNestedManyWithoutEnvironmentInput
    zone?: zoneUncheckedCreateNestedManyWithoutEnvironmentInput
  }

  export type environmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    env_delimiter?: env_delimiterUpdateManyWithoutEnvironmentNestedInput
    env_user?: env_userUpdateManyWithoutEnvironmentNestedInput
    map?: mapUpdateOneWithoutEnvironmentNestedInput
    poi?: poiUpdateManyWithoutEnvironmentNestedInput
    zone?: zoneUpdateManyWithoutEnvironmentNestedInput
  }

  export type environmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    env_delimiter?: env_delimiterUncheckedUpdateManyWithoutEnvironmentNestedInput
    env_user?: env_userUncheckedUpdateManyWithoutEnvironmentNestedInput
    poi?: poiUncheckedUpdateManyWithoutEnvironmentNestedInput
    zone?: zoneUncheckedUpdateManyWithoutEnvironmentNestedInput
  }

  export type environmentCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    address?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    map_id?: number | null
    is_public?: boolean | null
    surface?: number | null
  }

  export type environmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type environmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type expenseCreateInput = {
    id?: bigint | number
    created_at?: Date | string
    label?: string | null
    amount?: number
    category?: $Enums.ExpenseCategory | null
    description?: string | null
    date?: Date | string | null
  }

  export type expenseUncheckedCreateInput = {
    id?: bigint | number
    created_at?: Date | string
    label?: string | null
    amount?: number
    category?: $Enums.ExpenseCategory | null
    description?: string | null
    date?: Date | string | null
  }

  export type expenseUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    category?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type expenseUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    category?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type expenseCreateManyInput = {
    id?: bigint | number
    created_at?: Date | string
    label?: string | null
    amount?: number
    category?: $Enums.ExpenseCategory | null
    description?: string | null
    date?: Date | string | null
  }

  export type expenseUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    category?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type expenseUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    category?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type formatCreateInput = {
    format: string
    map?: mapCreateNestedManyWithoutFormatInput
  }

  export type formatUncheckedCreateInput = {
    id?: number
    format: string
    map?: mapUncheckedCreateNestedManyWithoutFormatInput
  }

  export type formatUpdateInput = {
    format?: StringFieldUpdateOperationsInput | string
    map?: mapUpdateManyWithoutFormatNestedInput
  }

  export type formatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    map?: mapUncheckedUpdateManyWithoutFormatNestedInput
  }

  export type formatCreateManyInput = {
    id?: number
    format: string
  }

  export type formatUpdateManyMutationInput = {
    format?: StringFieldUpdateOperationsInput | string
  }

  export type formatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
  }

  export type helper_userCreateInput = {
    state?: string | null
    user_helper_user_helper_idTouser?: userCreateNestedOneWithoutHelper_user_helper_user_helper_idTouserInput
    user_helper_user_user_idTouser?: userCreateNestedOneWithoutHelper_user_helper_user_user_idTouserInput
  }

  export type helper_userUncheckedCreateInput = {
    id?: number
    user_id?: number | null
    helper_id?: number | null
    state?: string | null
  }

  export type helper_userUpdateInput = {
    state?: NullableStringFieldUpdateOperationsInput | string | null
    user_helper_user_helper_idTouser?: userUpdateOneWithoutHelper_user_helper_user_helper_idTouserNestedInput
    user_helper_user_user_idTouser?: userUpdateOneWithoutHelper_user_helper_user_user_idTouserNestedInput
  }

  export type helper_userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    helper_id?: NullableIntFieldUpdateOperationsInput | number | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type helper_userCreateManyInput = {
    id?: number
    user_id?: number | null
    helper_id?: number | null
    state?: string | null
  }

  export type helper_userUpdateManyMutationInput = {
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type helper_userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    helper_id?: NullableIntFieldUpdateOperationsInput | number | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type intervention_historyCreateInput = {
    device_id?: number | null
    scheduled_date: Date | string
    completion_date?: Date | string | null
    description?: string | null
    status?: string | null
    type?: $Enums.intervention_type | null
    title?: string | null
    location?: string | null
    user?: userCreateNestedOneWithoutIntervention_historyInput
  }

  export type intervention_historyUncheckedCreateInput = {
    id?: number
    device_id?: number | null
    maintenancier_id?: number | null
    scheduled_date: Date | string
    completion_date?: Date | string | null
    description?: string | null
    status?: string | null
    type?: $Enums.intervention_type | null
    title?: string | null
    location?: string | null
  }

  export type intervention_historyUpdateInput = {
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumintervention_typeFieldUpdateOperationsInput | $Enums.intervention_type | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneWithoutIntervention_historyNestedInput
  }

  export type intervention_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    maintenancier_id?: NullableIntFieldUpdateOperationsInput | number | null
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumintervention_typeFieldUpdateOperationsInput | $Enums.intervention_type | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type intervention_historyCreateManyInput = {
    id?: number
    device_id?: number | null
    maintenancier_id?: number | null
    scheduled_date: Date | string
    completion_date?: Date | string | null
    description?: string | null
    status?: string | null
    type?: $Enums.intervention_type | null
    title?: string | null
    location?: string | null
  }

  export type intervention_historyUpdateManyMutationInput = {
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumintervention_typeFieldUpdateOperationsInput | $Enums.intervention_type | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type intervention_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    maintenancier_id?: NullableIntFieldUpdateOperationsInput | number | null
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumintervention_typeFieldUpdateOperationsInput | $Enums.intervention_type | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type localisationCreateInput = {
    longitude: string
    latitude: string
    updated_at?: Date | string
    user: userCreateNestedOneWithoutLocalisationInput
  }

  export type localisationUncheckedCreateInput = {
    id?: number
    longitude: string
    latitude: string
    userId: number
    updated_at?: Date | string
  }

  export type localisationUpdateInput = {
    longitude?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutLocalisationNestedInput
  }

  export type localisationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    longitude?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type localisationCreateManyInput = {
    id?: number
    longitude: string
    latitude: string
    userId: number
    updated_at?: Date | string
  }

  export type localisationUpdateManyMutationInput = {
    longitude?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type localisationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    longitude?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mapCreateInput = {
    created_at?: Date | string
    environment?: environmentCreateNestedManyWithoutMapInput
    format?: formatCreateNestedOneWithoutMapInput
    poi?: poiCreateNestedManyWithoutMapInput
    zone?: zoneCreateNestedManyWithoutMapInput
  }

  export type mapUncheckedCreateInput = {
    id?: number
    created_at?: Date | string
    format_id?: number | null
    environment?: environmentUncheckedCreateNestedManyWithoutMapInput
    poi?: poiUncheckedCreateNestedManyWithoutMapInput
    zone?: zoneUncheckedCreateNestedManyWithoutMapInput
  }

  export type mapUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: environmentUpdateManyWithoutMapNestedInput
    format?: formatUpdateOneWithoutMapNestedInput
    poi?: poiUpdateManyWithoutMapNestedInput
    zone?: zoneUpdateManyWithoutMapNestedInput
  }

  export type mapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    format_id?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: environmentUncheckedUpdateManyWithoutMapNestedInput
    poi?: poiUncheckedUpdateManyWithoutMapNestedInput
    zone?: zoneUncheckedUpdateManyWithoutMapNestedInput
  }

  export type mapCreateManyInput = {
    id?: number
    created_at?: Date | string
    format_id?: number | null
  }

  export type mapUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    format_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type market_potentielCreateInput = {
    id?: bigint | number
    created_at?: Date | string
    city: string
    potential_value?: number | null
  }

  export type market_potentielUncheckedCreateInput = {
    id?: bigint | number
    created_at?: Date | string
    city: string
    potential_value?: number | null
  }

  export type market_potentielUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: StringFieldUpdateOperationsInput | string
    potential_value?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type market_potentielUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: StringFieldUpdateOperationsInput | string
    potential_value?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type market_potentielCreateManyInput = {
    id?: bigint | number
    created_at?: Date | string
    city: string
    potential_value?: number | null
  }

  export type market_potentielUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: StringFieldUpdateOperationsInput | string
    potential_value?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type market_potentielUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: StringFieldUpdateOperationsInput | string
    potential_value?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type panne_historyCreateInput = {
    alert?: alertCreateNestedOneWithoutPanne_historyInput
  }

  export type panne_historyUncheckedCreateInput = {
    id?: number
    alert_id?: number | null
  }

  export type panne_historyUpdateInput = {
    alert?: alertUpdateOneWithoutPanne_historyNestedInput
  }

  export type panne_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    alert_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type panne_historyCreateManyInput = {
    id?: number
    alert_id?: number | null
  }

  export type panne_historyUpdateManyMutationInput = {

  }

  export type panne_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    alert_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type poiCreateInput = {
    created_at?: Date | string
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: string | null
    poi_category?: poi_categoryCreateNestedOneWithoutPoiInput
    environment?: environmentCreateNestedOneWithoutPoiInput
    map?: mapCreateNestedOneWithoutPoiInput
    poi_zone?: poi_zoneCreateNestedManyWithoutPoiInput
  }

  export type poiUncheckedCreateInput = {
    id?: number
    created_at?: Date | string
    env_id?: number | null
    category_id?: number | null
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: string | null
    map_id?: number | null
    poi_zone?: poi_zoneUncheckedCreateNestedManyWithoutPoiInput
  }

  export type poiUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    poi_category?: poi_categoryUpdateOneWithoutPoiNestedInput
    environment?: environmentUpdateOneWithoutPoiNestedInput
    map?: mapUpdateOneWithoutPoiNestedInput
    poi_zone?: poi_zoneUpdateManyWithoutPoiNestedInput
  }

  export type poiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
    poi_zone?: poi_zoneUncheckedUpdateManyWithoutPoiNestedInput
  }

  export type poiCreateManyInput = {
    id?: number
    created_at?: Date | string
    env_id?: number | null
    category_id?: number | null
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: string | null
    map_id?: number | null
  }

  export type poiUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type poiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type poi_categoryCreateInput = {
    category: string
    poi?: poiCreateNestedManyWithoutPoi_categoryInput
  }

  export type poi_categoryUncheckedCreateInput = {
    id?: number
    category: string
    poi?: poiUncheckedCreateNestedManyWithoutPoi_categoryInput
  }

  export type poi_categoryUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    poi?: poiUpdateManyWithoutPoi_categoryNestedInput
  }

  export type poi_categoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    poi?: poiUncheckedUpdateManyWithoutPoi_categoryNestedInput
  }

  export type poi_categoryCreateManyInput = {
    id?: number
    category: string
  }

  export type poi_categoryUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
  }

  export type poi_categoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type poi_zoneCreateInput = {
    created_at?: Date | string
    poi?: poiCreateNestedOneWithoutPoi_zoneInput
    zone?: zoneCreateNestedOneWithoutPoi_zoneInput
  }

  export type poi_zoneUncheckedCreateInput = {
    id?: number
    created_at?: Date | string
    poi_id?: number | null
    zone_id?: number | null
  }

  export type poi_zoneUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    poi?: poiUpdateOneWithoutPoi_zoneNestedInput
    zone?: zoneUpdateOneWithoutPoi_zoneNestedInput
  }

  export type poi_zoneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    poi_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type poi_zoneCreateManyInput = {
    id?: number
    created_at?: Date | string
    poi_id?: number | null
    zone_id?: number | null
  }

  export type poi_zoneUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type poi_zoneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    poi_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pricingCreateInput = {
    attribute?: string | null
    price?: number | null
  }

  export type pricingUncheckedCreateInput = {
    id?: number
    attribute?: string | null
    price?: number | null
  }

  export type pricingUpdateInput = {
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type pricingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type pricingCreateManyInput = {
    id?: number
    attribute?: string | null
    price?: number | null
  }

  export type pricingUpdateManyMutationInput = {
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type pricingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type purchase_historyCreateInput = {
    date?: Date | string
    public?: boolean | null
    device?: deviceCreateNestedOneWithoutPurchase_historyInput
    user?: userCreateNestedOneWithoutPurchase_historyInput
  }

  export type purchase_historyUncheckedCreateInput = {
    id?: number
    date?: Date | string
    user_id?: number | null
    device_id?: number | null
    public?: boolean | null
  }

  export type purchase_historyUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: deviceUpdateOneWithoutPurchase_historyNestedInput
    user?: userUpdateOneWithoutPurchase_historyNestedInput
  }

  export type purchase_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type purchase_historyCreateManyInput = {
    id?: number
    date?: Date | string
    user_id?: number | null
    device_id?: number | null
    public?: boolean | null
  }

  export type purchase_historyUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type purchase_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type state_typeCreateInput = {
    state: string
    device?: deviceCreateNestedManyWithoutState_typeInput
  }

  export type state_typeUncheckedCreateInput = {
    id?: number
    state: string
    device?: deviceUncheckedCreateNestedManyWithoutState_typeInput
  }

  export type state_typeUpdateInput = {
    state?: StringFieldUpdateOperationsInput | string
    device?: deviceUpdateManyWithoutState_typeNestedInput
  }

  export type state_typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    state?: StringFieldUpdateOperationsInput | string
    device?: deviceUncheckedUpdateManyWithoutState_typeNestedInput
  }

  export type state_typeCreateManyInput = {
    id?: number
    state: string
  }

  export type state_typeUpdateManyMutationInput = {
    state?: StringFieldUpdateOperationsInput | string
  }

  export type state_typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    state?: StringFieldUpdateOperationsInput | string
  }

  export type userCreateInput = {
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    device?: deviceCreateNestedManyWithoutUserInput
    env_user?: env_userCreateNestedManyWithoutUserInput
    helper_user_helper_user_helper_idTouser?: helper_userCreateNestedManyWithoutUser_helper_user_helper_idTouserInput
    helper_user_helper_user_user_idTouser?: helper_userCreateNestedManyWithoutUser_helper_user_user_idTouserInput
    intervention_history?: intervention_historyCreateNestedManyWithoutUserInput
    localisation?: localisationCreateNestedOneWithoutUserInput
    purchase_history?: purchase_historyCreateNestedManyWithoutUserInput
    user_type?: user_typeCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    userTypeId?: number | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    device?: deviceUncheckedCreateNestedManyWithoutUserInput
    env_user?: env_userUncheckedCreateNestedManyWithoutUserInput
    helper_user_helper_user_helper_idTouser?: helper_userUncheckedCreateNestedManyWithoutUser_helper_user_helper_idTouserInput
    helper_user_helper_user_user_idTouser?: helper_userUncheckedCreateNestedManyWithoutUser_helper_user_user_idTouserInput
    intervention_history?: intervention_historyUncheckedCreateNestedManyWithoutUserInput
    localisation?: localisationUncheckedCreateNestedOneWithoutUserInput
    purchase_history?: purchase_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    device?: deviceUpdateManyWithoutUserNestedInput
    env_user?: env_userUpdateManyWithoutUserNestedInput
    helper_user_helper_user_helper_idTouser?: helper_userUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput
    helper_user_helper_user_user_idTouser?: helper_userUpdateManyWithoutUser_helper_user_user_idTouserNestedInput
    intervention_history?: intervention_historyUpdateManyWithoutUserNestedInput
    localisation?: localisationUpdateOneWithoutUserNestedInput
    purchase_history?: purchase_historyUpdateManyWithoutUserNestedInput
    user_type?: user_typeUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    userTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    device?: deviceUncheckedUpdateManyWithoutUserNestedInput
    env_user?: env_userUncheckedUpdateManyWithoutUserNestedInput
    helper_user_helper_user_helper_idTouser?: helper_userUncheckedUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput
    helper_user_helper_user_user_idTouser?: helper_userUncheckedUpdateManyWithoutUser_helper_user_user_idTouserNestedInput
    intervention_history?: intervention_historyUncheckedUpdateManyWithoutUserNestedInput
    localisation?: localisationUncheckedUpdateOneWithoutUserNestedInput
    purchase_history?: purchase_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    userTypeId?: number | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
  }

  export type userUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    userTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_typeCreateInput = {
    created_at?: Date | string
    type?: string | null
    user?: userCreateNestedManyWithoutUser_typeInput
  }

  export type user_typeUncheckedCreateInput = {
    id?: number
    created_at?: Date | string
    type?: string | null
    user?: userUncheckedCreateNestedManyWithoutUser_typeInput
  }

  export type user_typeUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateManyWithoutUser_typeNestedInput
  }

  export type user_typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUncheckedUpdateManyWithoutUser_typeNestedInput
  }

  export type user_typeCreateManyInput = {
    id?: number
    created_at?: Date | string
    type?: string | null
  }

  export type user_typeUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type zoneCreateInput = {
    created_at?: Date | string
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: Date | string | null
    poi_zone?: poi_zoneCreateNestedManyWithoutZoneInput
    environment?: environmentCreateNestedOneWithoutZoneInput
    map?: mapCreateNestedOneWithoutZoneInput
    zone_type_zone_type_idTozone_type?: zone_typeCreateNestedOneWithoutZone_zone_type_idTozone_typeInput
    zone_type_zone_zone_typeTozone_type?: zone_typeCreateNestedOneWithoutZone_zone_zone_typeTozone_typeInput
  }

  export type zoneUncheckedCreateInput = {
    id?: number
    created_at?: Date | string
    env_id?: number | null
    name?: string | null
    description?: string | null
    type_id?: number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: Date | string | null
    map_id?: number | null
    zone_type?: number | null
    poi_zone?: poi_zoneUncheckedCreateNestedManyWithoutZoneInput
  }

  export type zoneUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poi_zone?: poi_zoneUpdateManyWithoutZoneNestedInput
    environment?: environmentUpdateOneWithoutZoneNestedInput
    map?: mapUpdateOneWithoutZoneNestedInput
    zone_type_zone_type_idTozone_type?: zone_typeUpdateOneWithoutZone_zone_type_idTozone_typeNestedInput
    zone_type_zone_zone_typeTozone_type?: zone_typeUpdateOneWithoutZone_zone_zone_typeTozone_typeNestedInput
  }

  export type zoneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_type?: NullableIntFieldUpdateOperationsInput | number | null
    poi_zone?: poi_zoneUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type zoneCreateManyInput = {
    id?: number
    created_at?: Date | string
    env_id?: number | null
    name?: string | null
    description?: string | null
    type_id?: number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: Date | string | null
    map_id?: number | null
    zone_type?: number | null
  }

  export type zoneUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type zoneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_type?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type zone_typeCreateInput = {
    created_at?: Date | string
    type?: string | null
    color?: string | null
    icon?: string | null
    name?: string | null
    description?: string | null
    priority?: string | null
    accessible?: boolean | null
    zone_zone_type_idTozone_type?: zoneCreateNestedManyWithoutZone_type_zone_type_idTozone_typeInput
    zone_zone_zone_typeTozone_type?: zoneCreateNestedManyWithoutZone_type_zone_zone_typeTozone_typeInput
  }

  export type zone_typeUncheckedCreateInput = {
    id?: number
    created_at?: Date | string
    type?: string | null
    color?: string | null
    icon?: string | null
    name?: string | null
    description?: string | null
    priority?: string | null
    accessible?: boolean | null
    zone_zone_type_idTozone_type?: zoneUncheckedCreateNestedManyWithoutZone_type_zone_type_idTozone_typeInput
    zone_zone_zone_typeTozone_type?: zoneUncheckedCreateNestedManyWithoutZone_type_zone_zone_typeTozone_typeInput
  }

  export type zone_typeUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    accessible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    zone_zone_type_idTozone_type?: zoneUpdateManyWithoutZone_type_zone_type_idTozone_typeNestedInput
    zone_zone_zone_typeTozone_type?: zoneUpdateManyWithoutZone_type_zone_zone_typeTozone_typeNestedInput
  }

  export type zone_typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    accessible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    zone_zone_type_idTozone_type?: zoneUncheckedUpdateManyWithoutZone_type_zone_type_idTozone_typeNestedInput
    zone_zone_zone_typeTozone_type?: zoneUncheckedUpdateManyWithoutZone_type_zone_zone_typeTozone_typeNestedInput
  }

  export type zone_typeCreateManyInput = {
    id?: number
    created_at?: Date | string
    type?: string | null
    color?: string | null
    icon?: string | null
    name?: string | null
    description?: string | null
    priority?: string | null
    accessible?: boolean | null
  }

  export type zone_typeUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    accessible?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type zone_typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    accessible?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Enumlevel_newFilter<$PrismaModel = never> = {
    equals?: $Enums.level_new | Enumlevel_newFieldRefInput<$PrismaModel>
    in?: $Enums.level_new[] | ListEnumlevel_newFieldRefInput<$PrismaModel>
    notIn?: $Enums.level_new[] | ListEnumlevel_newFieldRefInput<$PrismaModel>
    not?: NestedEnumlevel_newFilter<$PrismaModel> | $Enums.level_new
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DeviceNullableScalarRelationFilter = {
    is?: deviceWhereInput | null
    isNot?: deviceWhereInput | null
  }

  export type Panne_historyListRelationFilter = {
    every?: panne_historyWhereInput
    some?: panne_historyWhereInput
    none?: panne_historyWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type panne_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type alertCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    time?: SortOrder
    date?: SortOrder
    zone?: SortOrder
    status?: SortOrder
    level?: SortOrder
    device_id?: SortOrder
  }

  export type alertAvgOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
  }

  export type alertMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    time?: SortOrder
    date?: SortOrder
    zone?: SortOrder
    status?: SortOrder
    level?: SortOrder
    device_id?: SortOrder
  }

  export type alertMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    time?: SortOrder
    date?: SortOrder
    zone?: SortOrder
    status?: SortOrder
    level?: SortOrder
    device_id?: SortOrder
  }

  export type alertSumOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type Enumlevel_newWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.level_new | Enumlevel_newFieldRefInput<$PrismaModel>
    in?: $Enums.level_new[] | ListEnumlevel_newFieldRefInput<$PrismaModel>
    notIn?: $Enums.level_new[] | ListEnumlevel_newFieldRefInput<$PrismaModel>
    not?: NestedEnumlevel_newWithAggregatesFilter<$PrismaModel> | $Enums.level_new
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumlevel_newFilter<$PrismaModel>
    _max?: NestedEnumlevel_newFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AlertListRelationFilter = {
    every?: alertWhereInput
    some?: alertWhereInput
    none?: alertWhereInput
  }

  export type State_typeScalarRelationFilter = {
    is?: state_typeWhereInput
    isNot?: state_typeWhereInput
  }

  export type Device_typeScalarRelationFilter = {
    is?: device_typeWhereInput
    isNot?: device_typeWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type Purchase_historyListRelationFilter = {
    every?: purchase_historyWhereInput
    some?: purchase_historyWhereInput
    none?: purchase_historyWhereInput
  }

  export type alertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type purchase_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type deviceCountOrderByAggregateInput = {
    id?: SortOrder
    type_id?: SortOrder
    state_type_id?: SortOrder
    user_id?: SortOrder
    mac_address?: SortOrder
    software_version?: SortOrder
    date_of_service?: SortOrder
    comm_state?: SortOrder
    connection_state?: SortOrder
    battery_capacity?: SortOrder
    price?: SortOrder
  }

  export type deviceAvgOrderByAggregateInput = {
    id?: SortOrder
    type_id?: SortOrder
    state_type_id?: SortOrder
    user_id?: SortOrder
    battery_capacity?: SortOrder
    price?: SortOrder
  }

  export type deviceMaxOrderByAggregateInput = {
    id?: SortOrder
    type_id?: SortOrder
    state_type_id?: SortOrder
    user_id?: SortOrder
    mac_address?: SortOrder
    software_version?: SortOrder
    date_of_service?: SortOrder
    comm_state?: SortOrder
    connection_state?: SortOrder
    battery_capacity?: SortOrder
    price?: SortOrder
  }

  export type deviceMinOrderByAggregateInput = {
    id?: SortOrder
    type_id?: SortOrder
    state_type_id?: SortOrder
    user_id?: SortOrder
    mac_address?: SortOrder
    software_version?: SortOrder
    date_of_service?: SortOrder
    comm_state?: SortOrder
    connection_state?: SortOrder
    battery_capacity?: SortOrder
    price?: SortOrder
  }

  export type deviceSumOrderByAggregateInput = {
    id?: SortOrder
    type_id?: SortOrder
    state_type_id?: SortOrder
    user_id?: SortOrder
    battery_capacity?: SortOrder
    price?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DeviceListRelationFilter = {
    every?: deviceWhereInput
    some?: deviceWhereInput
    none?: deviceWhereInput
  }

  export type deviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type device_typeCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type device_typeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type device_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type device_typeMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type device_typeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type emergency_contactCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    number?: SortOrder
  }

  export type emergency_contactAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type emergency_contactMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    number?: SortOrder
  }

  export type emergency_contactMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    number?: SortOrder
  }

  export type emergency_contactSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnvironmentNullableScalarRelationFilter = {
    is?: environmentWhereInput | null
    isNot?: environmentWhereInput | null
  }

  export type env_delimiterCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    env_id?: SortOrder
    coordinates?: SortOrder
    type?: SortOrder
  }

  export type env_delimiterAvgOrderByAggregateInput = {
    id?: SortOrder
    env_id?: SortOrder
  }

  export type env_delimiterMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    env_id?: SortOrder
    type?: SortOrder
  }

  export type env_delimiterMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    env_id?: SortOrder
    type?: SortOrder
  }

  export type env_delimiterSumOrderByAggregateInput = {
    id?: SortOrder
    env_id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type env_userCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    env_id?: SortOrder
  }

  export type env_userAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    env_id?: SortOrder
  }

  export type env_userMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    env_id?: SortOrder
  }

  export type env_userMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    env_id?: SortOrder
  }

  export type env_userSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    env_id?: SortOrder
  }

  export type Env_delimiterListRelationFilter = {
    every?: env_delimiterWhereInput
    some?: env_delimiterWhereInput
    none?: env_delimiterWhereInput
  }

  export type Env_userListRelationFilter = {
    every?: env_userWhereInput
    some?: env_userWhereInput
    none?: env_userWhereInput
  }

  export type MapNullableScalarRelationFilter = {
    is?: mapWhereInput | null
    isNot?: mapWhereInput | null
  }

  export type PoiListRelationFilter = {
    every?: poiWhereInput
    some?: poiWhereInput
    none?: poiWhereInput
  }

  export type ZoneListRelationFilter = {
    every?: zoneWhereInput
    some?: zoneWhereInput
    none?: zoneWhereInput
  }

  export type env_delimiterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type env_userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type poiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type zoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type environmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    map_id?: SortOrder
    is_public?: SortOrder
    surface?: SortOrder
  }

  export type environmentAvgOrderByAggregateInput = {
    id?: SortOrder
    map_id?: SortOrder
    surface?: SortOrder
  }

  export type environmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    map_id?: SortOrder
    is_public?: SortOrder
    surface?: SortOrder
  }

  export type environmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    map_id?: SortOrder
    is_public?: SortOrder
    surface?: SortOrder
  }

  export type environmentSumOrderByAggregateInput = {
    id?: SortOrder
    map_id?: SortOrder
    surface?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumExpenseCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumExpenseCategoryNullableFilter<$PrismaModel> | $Enums.ExpenseCategory | null
  }

  export type expenseCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    date?: SortOrder
  }

  export type expenseAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type expenseMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    date?: SortOrder
  }

  export type expenseMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    date?: SortOrder
  }

  export type expenseSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumExpenseCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumExpenseCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumExpenseCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumExpenseCategoryNullableFilter<$PrismaModel>
  }

  export type MapListRelationFilter = {
    every?: mapWhereInput
    some?: mapWhereInput
    none?: mapWhereInput
  }

  export type mapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type formatCountOrderByAggregateInput = {
    id?: SortOrder
    format?: SortOrder
  }

  export type formatAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type formatMaxOrderByAggregateInput = {
    id?: SortOrder
    format?: SortOrder
  }

  export type formatMinOrderByAggregateInput = {
    id?: SortOrder
    format?: SortOrder
  }

  export type formatSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type helper_userCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    helper_id?: SortOrder
    state?: SortOrder
  }

  export type helper_userAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    helper_id?: SortOrder
  }

  export type helper_userMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    helper_id?: SortOrder
    state?: SortOrder
  }

  export type helper_userMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    helper_id?: SortOrder
    state?: SortOrder
  }

  export type helper_userSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    helper_id?: SortOrder
  }

  export type Enumintervention_typeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.intervention_type | Enumintervention_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.intervention_type[] | ListEnumintervention_typeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.intervention_type[] | ListEnumintervention_typeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumintervention_typeNullableFilter<$PrismaModel> | $Enums.intervention_type | null
  }

  export type intervention_historyCountOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    maintenancier_id?: SortOrder
    scheduled_date?: SortOrder
    completion_date?: SortOrder
    description?: SortOrder
    status?: SortOrder
    type?: SortOrder
    title?: SortOrder
    location?: SortOrder
  }

  export type intervention_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    maintenancier_id?: SortOrder
  }

  export type intervention_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    maintenancier_id?: SortOrder
    scheduled_date?: SortOrder
    completion_date?: SortOrder
    description?: SortOrder
    status?: SortOrder
    type?: SortOrder
    title?: SortOrder
    location?: SortOrder
  }

  export type intervention_historyMinOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    maintenancier_id?: SortOrder
    scheduled_date?: SortOrder
    completion_date?: SortOrder
    description?: SortOrder
    status?: SortOrder
    type?: SortOrder
    title?: SortOrder
    location?: SortOrder
  }

  export type intervention_historySumOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    maintenancier_id?: SortOrder
  }

  export type Enumintervention_typeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.intervention_type | Enumintervention_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.intervention_type[] | ListEnumintervention_typeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.intervention_type[] | ListEnumintervention_typeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumintervention_typeNullableWithAggregatesFilter<$PrismaModel> | $Enums.intervention_type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumintervention_typeNullableFilter<$PrismaModel>
    _max?: NestedEnumintervention_typeNullableFilter<$PrismaModel>
  }

  export type localisationCountOrderByAggregateInput = {
    id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    userId?: SortOrder
    updated_at?: SortOrder
  }

  export type localisationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type localisationMaxOrderByAggregateInput = {
    id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    userId?: SortOrder
    updated_at?: SortOrder
  }

  export type localisationMinOrderByAggregateInput = {
    id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    userId?: SortOrder
    updated_at?: SortOrder
  }

  export type localisationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnvironmentListRelationFilter = {
    every?: environmentWhereInput
    some?: environmentWhereInput
    none?: environmentWhereInput
  }

  export type FormatNullableScalarRelationFilter = {
    is?: formatWhereInput | null
    isNot?: formatWhereInput | null
  }

  export type environmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mapCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    format_id?: SortOrder
  }

  export type mapAvgOrderByAggregateInput = {
    id?: SortOrder
    format_id?: SortOrder
  }

  export type mapMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    format_id?: SortOrder
  }

  export type mapMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    format_id?: SortOrder
  }

  export type mapSumOrderByAggregateInput = {
    id?: SortOrder
    format_id?: SortOrder
  }

  export type market_potentielCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    city?: SortOrder
    potential_value?: SortOrder
  }

  export type market_potentielAvgOrderByAggregateInput = {
    id?: SortOrder
    potential_value?: SortOrder
  }

  export type market_potentielMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    city?: SortOrder
    potential_value?: SortOrder
  }

  export type market_potentielMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    city?: SortOrder
    potential_value?: SortOrder
  }

  export type market_potentielSumOrderByAggregateInput = {
    id?: SortOrder
    potential_value?: SortOrder
  }

  export type AlertNullableScalarRelationFilter = {
    is?: alertWhereInput | null
    isNot?: alertWhereInput | null
  }

  export type panne_historyCountOrderByAggregateInput = {
    id?: SortOrder
    alert_id?: SortOrder
  }

  export type panne_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    alert_id?: SortOrder
  }

  export type panne_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    alert_id?: SortOrder
  }

  export type panne_historyMinOrderByAggregateInput = {
    id?: SortOrder
    alert_id?: SortOrder
  }

  export type panne_historySumOrderByAggregateInput = {
    id?: SortOrder
    alert_id?: SortOrder
  }

  export type Poi_categoryNullableScalarRelationFilter = {
    is?: poi_categoryWhereInput | null
    isNot?: poi_categoryWhereInput | null
  }

  export type Poi_zoneListRelationFilter = {
    every?: poi_zoneWhereInput
    some?: poi_zoneWhereInput
    none?: poi_zoneWhereInput
  }

  export type poi_zoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type poiCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    env_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    coordinates?: SortOrder
    image_url?: SortOrder
    map_id?: SortOrder
  }

  export type poiAvgOrderByAggregateInput = {
    id?: SortOrder
    env_id?: SortOrder
    category_id?: SortOrder
    map_id?: SortOrder
  }

  export type poiMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    env_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image_url?: SortOrder
    map_id?: SortOrder
  }

  export type poiMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    env_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image_url?: SortOrder
    map_id?: SortOrder
  }

  export type poiSumOrderByAggregateInput = {
    id?: SortOrder
    env_id?: SortOrder
    category_id?: SortOrder
    map_id?: SortOrder
  }

  export type poi_categoryCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
  }

  export type poi_categoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type poi_categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
  }

  export type poi_categoryMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
  }

  export type poi_categorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PoiNullableScalarRelationFilter = {
    is?: poiWhereInput | null
    isNot?: poiWhereInput | null
  }

  export type ZoneNullableScalarRelationFilter = {
    is?: zoneWhereInput | null
    isNot?: zoneWhereInput | null
  }

  export type poi_zoneCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    poi_id?: SortOrder
    zone_id?: SortOrder
  }

  export type poi_zoneAvgOrderByAggregateInput = {
    id?: SortOrder
    poi_id?: SortOrder
    zone_id?: SortOrder
  }

  export type poi_zoneMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    poi_id?: SortOrder
    zone_id?: SortOrder
  }

  export type poi_zoneMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    poi_id?: SortOrder
    zone_id?: SortOrder
  }

  export type poi_zoneSumOrderByAggregateInput = {
    id?: SortOrder
    poi_id?: SortOrder
    zone_id?: SortOrder
  }

  export type pricingCountOrderByAggregateInput = {
    id?: SortOrder
    attribute?: SortOrder
    price?: SortOrder
  }

  export type pricingAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type pricingMaxOrderByAggregateInput = {
    id?: SortOrder
    attribute?: SortOrder
    price?: SortOrder
  }

  export type pricingMinOrderByAggregateInput = {
    id?: SortOrder
    attribute?: SortOrder
    price?: SortOrder
  }

  export type pricingSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type purchase_historyCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    user_id?: SortOrder
    device_id?: SortOrder
    public?: SortOrder
  }

  export type purchase_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    device_id?: SortOrder
  }

  export type purchase_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    user_id?: SortOrder
    device_id?: SortOrder
    public?: SortOrder
  }

  export type purchase_historyMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    user_id?: SortOrder
    device_id?: SortOrder
    public?: SortOrder
  }

  export type purchase_historySumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    device_id?: SortOrder
  }

  export type state_typeCountOrderByAggregateInput = {
    id?: SortOrder
    state?: SortOrder
  }

  export type state_typeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type state_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    state?: SortOrder
  }

  export type state_typeMinOrderByAggregateInput = {
    id?: SortOrder
    state?: SortOrder
  }

  export type state_typeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Helper_userListRelationFilter = {
    every?: helper_userWhereInput
    some?: helper_userWhereInput
    none?: helper_userWhereInput
  }

  export type Intervention_historyListRelationFilter = {
    every?: intervention_historyWhereInput
    some?: intervention_historyWhereInput
    none?: intervention_historyWhereInput
  }

  export type LocalisationNullableScalarRelationFilter = {
    is?: localisationWhereInput | null
    isNot?: localisationWhereInput | null
  }

  export type User_typeNullableScalarRelationFilter = {
    is?: user_typeWhereInput | null
    isNot?: user_typeWhereInput | null
  }

  export type helper_userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type intervention_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    family_name?: SortOrder
    first_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    userTypeId?: SortOrder
    email?: SortOrder
    sex?: SortOrder
    street?: SortOrder
    city?: SortOrder
    birth_date?: SortOrder
    Identifier?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
    userTypeId?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    family_name?: SortOrder
    first_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    userTypeId?: SortOrder
    email?: SortOrder
    sex?: SortOrder
    street?: SortOrder
    city?: SortOrder
    birth_date?: SortOrder
    Identifier?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    family_name?: SortOrder
    first_name?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    userTypeId?: SortOrder
    email?: SortOrder
    sex?: SortOrder
    street?: SortOrder
    city?: SortOrder
    birth_date?: SortOrder
    Identifier?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
    userTypeId?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: userWhereInput
    some?: userWhereInput
    none?: userWhereInput
  }

  export type userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_typeCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    type?: SortOrder
  }

  export type user_typeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type user_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    type?: SortOrder
  }

  export type user_typeMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    type?: SortOrder
  }

  export type user_typeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Zone_typeNullableScalarRelationFilter = {
    is?: zone_typeWhereInput | null
    isNot?: zone_typeWhereInput | null
  }

  export type zoneCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    env_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    coordinates?: SortOrder
    updated_at?: SortOrder
    map_id?: SortOrder
    zone_type?: SortOrder
  }

  export type zoneAvgOrderByAggregateInput = {
    id?: SortOrder
    env_id?: SortOrder
    type_id?: SortOrder
    map_id?: SortOrder
    zone_type?: SortOrder
  }

  export type zoneMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    env_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    updated_at?: SortOrder
    map_id?: SortOrder
    zone_type?: SortOrder
  }

  export type zoneMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    env_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    updated_at?: SortOrder
    map_id?: SortOrder
    zone_type?: SortOrder
  }

  export type zoneSumOrderByAggregateInput = {
    id?: SortOrder
    env_id?: SortOrder
    type_id?: SortOrder
    map_id?: SortOrder
    zone_type?: SortOrder
  }

  export type zone_typeCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    type?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    accessible?: SortOrder
  }

  export type zone_typeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type zone_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    type?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    accessible?: SortOrder
  }

  export type zone_typeMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    type?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    accessible?: SortOrder
  }

  export type zone_typeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type deviceCreateNestedOneWithoutAlertInput = {
    create?: XOR<deviceCreateWithoutAlertInput, deviceUncheckedCreateWithoutAlertInput>
    connectOrCreate?: deviceCreateOrConnectWithoutAlertInput
    connect?: deviceWhereUniqueInput
  }

  export type panne_historyCreateNestedManyWithoutAlertInput = {
    create?: XOR<panne_historyCreateWithoutAlertInput, panne_historyUncheckedCreateWithoutAlertInput> | panne_historyCreateWithoutAlertInput[] | panne_historyUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: panne_historyCreateOrConnectWithoutAlertInput | panne_historyCreateOrConnectWithoutAlertInput[]
    createMany?: panne_historyCreateManyAlertInputEnvelope
    connect?: panne_historyWhereUniqueInput | panne_historyWhereUniqueInput[]
  }

  export type panne_historyUncheckedCreateNestedManyWithoutAlertInput = {
    create?: XOR<panne_historyCreateWithoutAlertInput, panne_historyUncheckedCreateWithoutAlertInput> | panne_historyCreateWithoutAlertInput[] | panne_historyUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: panne_historyCreateOrConnectWithoutAlertInput | panne_historyCreateOrConnectWithoutAlertInput[]
    createMany?: panne_historyCreateManyAlertInputEnvelope
    connect?: panne_historyWhereUniqueInput | panne_historyWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type Enumlevel_newFieldUpdateOperationsInput = {
    set?: $Enums.level_new
  }

  export type deviceUpdateOneWithoutAlertNestedInput = {
    create?: XOR<deviceCreateWithoutAlertInput, deviceUncheckedCreateWithoutAlertInput>
    connectOrCreate?: deviceCreateOrConnectWithoutAlertInput
    upsert?: deviceUpsertWithoutAlertInput
    disconnect?: deviceWhereInput | boolean
    delete?: deviceWhereInput | boolean
    connect?: deviceWhereUniqueInput
    update?: XOR<XOR<deviceUpdateToOneWithWhereWithoutAlertInput, deviceUpdateWithoutAlertInput>, deviceUncheckedUpdateWithoutAlertInput>
  }

  export type panne_historyUpdateManyWithoutAlertNestedInput = {
    create?: XOR<panne_historyCreateWithoutAlertInput, panne_historyUncheckedCreateWithoutAlertInput> | panne_historyCreateWithoutAlertInput[] | panne_historyUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: panne_historyCreateOrConnectWithoutAlertInput | panne_historyCreateOrConnectWithoutAlertInput[]
    upsert?: panne_historyUpsertWithWhereUniqueWithoutAlertInput | panne_historyUpsertWithWhereUniqueWithoutAlertInput[]
    createMany?: panne_historyCreateManyAlertInputEnvelope
    set?: panne_historyWhereUniqueInput | panne_historyWhereUniqueInput[]
    disconnect?: panne_historyWhereUniqueInput | panne_historyWhereUniqueInput[]
    delete?: panne_historyWhereUniqueInput | panne_historyWhereUniqueInput[]
    connect?: panne_historyWhereUniqueInput | panne_historyWhereUniqueInput[]
    update?: panne_historyUpdateWithWhereUniqueWithoutAlertInput | panne_historyUpdateWithWhereUniqueWithoutAlertInput[]
    updateMany?: panne_historyUpdateManyWithWhereWithoutAlertInput | panne_historyUpdateManyWithWhereWithoutAlertInput[]
    deleteMany?: panne_historyScalarWhereInput | panne_historyScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type panne_historyUncheckedUpdateManyWithoutAlertNestedInput = {
    create?: XOR<panne_historyCreateWithoutAlertInput, panne_historyUncheckedCreateWithoutAlertInput> | panne_historyCreateWithoutAlertInput[] | panne_historyUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: panne_historyCreateOrConnectWithoutAlertInput | panne_historyCreateOrConnectWithoutAlertInput[]
    upsert?: panne_historyUpsertWithWhereUniqueWithoutAlertInput | panne_historyUpsertWithWhereUniqueWithoutAlertInput[]
    createMany?: panne_historyCreateManyAlertInputEnvelope
    set?: panne_historyWhereUniqueInput | panne_historyWhereUniqueInput[]
    disconnect?: panne_historyWhereUniqueInput | panne_historyWhereUniqueInput[]
    delete?: panne_historyWhereUniqueInput | panne_historyWhereUniqueInput[]
    connect?: panne_historyWhereUniqueInput | panne_historyWhereUniqueInput[]
    update?: panne_historyUpdateWithWhereUniqueWithoutAlertInput | panne_historyUpdateWithWhereUniqueWithoutAlertInput[]
    updateMany?: panne_historyUpdateManyWithWhereWithoutAlertInput | panne_historyUpdateManyWithWhereWithoutAlertInput[]
    deleteMany?: panne_historyScalarWhereInput | panne_historyScalarWhereInput[]
  }

  export type alertCreateNestedManyWithoutDeviceInput = {
    create?: XOR<alertCreateWithoutDeviceInput, alertUncheckedCreateWithoutDeviceInput> | alertCreateWithoutDeviceInput[] | alertUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: alertCreateOrConnectWithoutDeviceInput | alertCreateOrConnectWithoutDeviceInput[]
    createMany?: alertCreateManyDeviceInputEnvelope
    connect?: alertWhereUniqueInput | alertWhereUniqueInput[]
  }

  export type state_typeCreateNestedOneWithoutDeviceInput = {
    create?: XOR<state_typeCreateWithoutDeviceInput, state_typeUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: state_typeCreateOrConnectWithoutDeviceInput
    connect?: state_typeWhereUniqueInput
  }

  export type device_typeCreateNestedOneWithoutDeviceInput = {
    create?: XOR<device_typeCreateWithoutDeviceInput, device_typeUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: device_typeCreateOrConnectWithoutDeviceInput
    connect?: device_typeWhereUniqueInput
  }

  export type userCreateNestedOneWithoutDeviceInput = {
    create?: XOR<userCreateWithoutDeviceInput, userUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: userCreateOrConnectWithoutDeviceInput
    connect?: userWhereUniqueInput
  }

  export type purchase_historyCreateNestedManyWithoutDeviceInput = {
    create?: XOR<purchase_historyCreateWithoutDeviceInput, purchase_historyUncheckedCreateWithoutDeviceInput> | purchase_historyCreateWithoutDeviceInput[] | purchase_historyUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: purchase_historyCreateOrConnectWithoutDeviceInput | purchase_historyCreateOrConnectWithoutDeviceInput[]
    createMany?: purchase_historyCreateManyDeviceInputEnvelope
    connect?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
  }

  export type alertUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<alertCreateWithoutDeviceInput, alertUncheckedCreateWithoutDeviceInput> | alertCreateWithoutDeviceInput[] | alertUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: alertCreateOrConnectWithoutDeviceInput | alertCreateOrConnectWithoutDeviceInput[]
    createMany?: alertCreateManyDeviceInputEnvelope
    connect?: alertWhereUniqueInput | alertWhereUniqueInput[]
  }

  export type purchase_historyUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<purchase_historyCreateWithoutDeviceInput, purchase_historyUncheckedCreateWithoutDeviceInput> | purchase_historyCreateWithoutDeviceInput[] | purchase_historyUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: purchase_historyCreateOrConnectWithoutDeviceInput | purchase_historyCreateOrConnectWithoutDeviceInput[]
    createMany?: purchase_historyCreateManyDeviceInputEnvelope
    connect?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type alertUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<alertCreateWithoutDeviceInput, alertUncheckedCreateWithoutDeviceInput> | alertCreateWithoutDeviceInput[] | alertUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: alertCreateOrConnectWithoutDeviceInput | alertCreateOrConnectWithoutDeviceInput[]
    upsert?: alertUpsertWithWhereUniqueWithoutDeviceInput | alertUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: alertCreateManyDeviceInputEnvelope
    set?: alertWhereUniqueInput | alertWhereUniqueInput[]
    disconnect?: alertWhereUniqueInput | alertWhereUniqueInput[]
    delete?: alertWhereUniqueInput | alertWhereUniqueInput[]
    connect?: alertWhereUniqueInput | alertWhereUniqueInput[]
    update?: alertUpdateWithWhereUniqueWithoutDeviceInput | alertUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: alertUpdateManyWithWhereWithoutDeviceInput | alertUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: alertScalarWhereInput | alertScalarWhereInput[]
  }

  export type state_typeUpdateOneRequiredWithoutDeviceNestedInput = {
    create?: XOR<state_typeCreateWithoutDeviceInput, state_typeUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: state_typeCreateOrConnectWithoutDeviceInput
    upsert?: state_typeUpsertWithoutDeviceInput
    connect?: state_typeWhereUniqueInput
    update?: XOR<XOR<state_typeUpdateToOneWithWhereWithoutDeviceInput, state_typeUpdateWithoutDeviceInput>, state_typeUncheckedUpdateWithoutDeviceInput>
  }

  export type device_typeUpdateOneRequiredWithoutDeviceNestedInput = {
    create?: XOR<device_typeCreateWithoutDeviceInput, device_typeUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: device_typeCreateOrConnectWithoutDeviceInput
    upsert?: device_typeUpsertWithoutDeviceInput
    connect?: device_typeWhereUniqueInput
    update?: XOR<XOR<device_typeUpdateToOneWithWhereWithoutDeviceInput, device_typeUpdateWithoutDeviceInput>, device_typeUncheckedUpdateWithoutDeviceInput>
  }

  export type userUpdateOneWithoutDeviceNestedInput = {
    create?: XOR<userCreateWithoutDeviceInput, userUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: userCreateOrConnectWithoutDeviceInput
    upsert?: userUpsertWithoutDeviceInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutDeviceInput, userUpdateWithoutDeviceInput>, userUncheckedUpdateWithoutDeviceInput>
  }

  export type purchase_historyUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<purchase_historyCreateWithoutDeviceInput, purchase_historyUncheckedCreateWithoutDeviceInput> | purchase_historyCreateWithoutDeviceInput[] | purchase_historyUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: purchase_historyCreateOrConnectWithoutDeviceInput | purchase_historyCreateOrConnectWithoutDeviceInput[]
    upsert?: purchase_historyUpsertWithWhereUniqueWithoutDeviceInput | purchase_historyUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: purchase_historyCreateManyDeviceInputEnvelope
    set?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
    disconnect?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
    delete?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
    connect?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
    update?: purchase_historyUpdateWithWhereUniqueWithoutDeviceInput | purchase_historyUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: purchase_historyUpdateManyWithWhereWithoutDeviceInput | purchase_historyUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: purchase_historyScalarWhereInput | purchase_historyScalarWhereInput[]
  }

  export type alertUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<alertCreateWithoutDeviceInput, alertUncheckedCreateWithoutDeviceInput> | alertCreateWithoutDeviceInput[] | alertUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: alertCreateOrConnectWithoutDeviceInput | alertCreateOrConnectWithoutDeviceInput[]
    upsert?: alertUpsertWithWhereUniqueWithoutDeviceInput | alertUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: alertCreateManyDeviceInputEnvelope
    set?: alertWhereUniqueInput | alertWhereUniqueInput[]
    disconnect?: alertWhereUniqueInput | alertWhereUniqueInput[]
    delete?: alertWhereUniqueInput | alertWhereUniqueInput[]
    connect?: alertWhereUniqueInput | alertWhereUniqueInput[]
    update?: alertUpdateWithWhereUniqueWithoutDeviceInput | alertUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: alertUpdateManyWithWhereWithoutDeviceInput | alertUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: alertScalarWhereInput | alertScalarWhereInput[]
  }

  export type purchase_historyUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<purchase_historyCreateWithoutDeviceInput, purchase_historyUncheckedCreateWithoutDeviceInput> | purchase_historyCreateWithoutDeviceInput[] | purchase_historyUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: purchase_historyCreateOrConnectWithoutDeviceInput | purchase_historyCreateOrConnectWithoutDeviceInput[]
    upsert?: purchase_historyUpsertWithWhereUniqueWithoutDeviceInput | purchase_historyUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: purchase_historyCreateManyDeviceInputEnvelope
    set?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
    disconnect?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
    delete?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
    connect?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
    update?: purchase_historyUpdateWithWhereUniqueWithoutDeviceInput | purchase_historyUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: purchase_historyUpdateManyWithWhereWithoutDeviceInput | purchase_historyUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: purchase_historyScalarWhereInput | purchase_historyScalarWhereInput[]
  }

  export type deviceCreateNestedManyWithoutDevice_typeInput = {
    create?: XOR<deviceCreateWithoutDevice_typeInput, deviceUncheckedCreateWithoutDevice_typeInput> | deviceCreateWithoutDevice_typeInput[] | deviceUncheckedCreateWithoutDevice_typeInput[]
    connectOrCreate?: deviceCreateOrConnectWithoutDevice_typeInput | deviceCreateOrConnectWithoutDevice_typeInput[]
    createMany?: deviceCreateManyDevice_typeInputEnvelope
    connect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
  }

  export type deviceUncheckedCreateNestedManyWithoutDevice_typeInput = {
    create?: XOR<deviceCreateWithoutDevice_typeInput, deviceUncheckedCreateWithoutDevice_typeInput> | deviceCreateWithoutDevice_typeInput[] | deviceUncheckedCreateWithoutDevice_typeInput[]
    connectOrCreate?: deviceCreateOrConnectWithoutDevice_typeInput | deviceCreateOrConnectWithoutDevice_typeInput[]
    createMany?: deviceCreateManyDevice_typeInputEnvelope
    connect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
  }

  export type deviceUpdateManyWithoutDevice_typeNestedInput = {
    create?: XOR<deviceCreateWithoutDevice_typeInput, deviceUncheckedCreateWithoutDevice_typeInput> | deviceCreateWithoutDevice_typeInput[] | deviceUncheckedCreateWithoutDevice_typeInput[]
    connectOrCreate?: deviceCreateOrConnectWithoutDevice_typeInput | deviceCreateOrConnectWithoutDevice_typeInput[]
    upsert?: deviceUpsertWithWhereUniqueWithoutDevice_typeInput | deviceUpsertWithWhereUniqueWithoutDevice_typeInput[]
    createMany?: deviceCreateManyDevice_typeInputEnvelope
    set?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    disconnect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    delete?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    connect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    update?: deviceUpdateWithWhereUniqueWithoutDevice_typeInput | deviceUpdateWithWhereUniqueWithoutDevice_typeInput[]
    updateMany?: deviceUpdateManyWithWhereWithoutDevice_typeInput | deviceUpdateManyWithWhereWithoutDevice_typeInput[]
    deleteMany?: deviceScalarWhereInput | deviceScalarWhereInput[]
  }

  export type deviceUncheckedUpdateManyWithoutDevice_typeNestedInput = {
    create?: XOR<deviceCreateWithoutDevice_typeInput, deviceUncheckedCreateWithoutDevice_typeInput> | deviceCreateWithoutDevice_typeInput[] | deviceUncheckedCreateWithoutDevice_typeInput[]
    connectOrCreate?: deviceCreateOrConnectWithoutDevice_typeInput | deviceCreateOrConnectWithoutDevice_typeInput[]
    upsert?: deviceUpsertWithWhereUniqueWithoutDevice_typeInput | deviceUpsertWithWhereUniqueWithoutDevice_typeInput[]
    createMany?: deviceCreateManyDevice_typeInputEnvelope
    set?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    disconnect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    delete?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    connect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    update?: deviceUpdateWithWhereUniqueWithoutDevice_typeInput | deviceUpdateWithWhereUniqueWithoutDevice_typeInput[]
    updateMany?: deviceUpdateManyWithWhereWithoutDevice_typeInput | deviceUpdateManyWithWhereWithoutDevice_typeInput[]
    deleteMany?: deviceScalarWhereInput | deviceScalarWhereInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type environmentCreateNestedOneWithoutEnv_delimiterInput = {
    create?: XOR<environmentCreateWithoutEnv_delimiterInput, environmentUncheckedCreateWithoutEnv_delimiterInput>
    connectOrCreate?: environmentCreateOrConnectWithoutEnv_delimiterInput
    connect?: environmentWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type environmentUpdateOneWithoutEnv_delimiterNestedInput = {
    create?: XOR<environmentCreateWithoutEnv_delimiterInput, environmentUncheckedCreateWithoutEnv_delimiterInput>
    connectOrCreate?: environmentCreateOrConnectWithoutEnv_delimiterInput
    upsert?: environmentUpsertWithoutEnv_delimiterInput
    disconnect?: environmentWhereInput | boolean
    delete?: environmentWhereInput | boolean
    connect?: environmentWhereUniqueInput
    update?: XOR<XOR<environmentUpdateToOneWithWhereWithoutEnv_delimiterInput, environmentUpdateWithoutEnv_delimiterInput>, environmentUncheckedUpdateWithoutEnv_delimiterInput>
  }

  export type environmentCreateNestedOneWithoutEnv_userInput = {
    create?: XOR<environmentCreateWithoutEnv_userInput, environmentUncheckedCreateWithoutEnv_userInput>
    connectOrCreate?: environmentCreateOrConnectWithoutEnv_userInput
    connect?: environmentWhereUniqueInput
  }

  export type userCreateNestedOneWithoutEnv_userInput = {
    create?: XOR<userCreateWithoutEnv_userInput, userUncheckedCreateWithoutEnv_userInput>
    connectOrCreate?: userCreateOrConnectWithoutEnv_userInput
    connect?: userWhereUniqueInput
  }

  export type environmentUpdateOneWithoutEnv_userNestedInput = {
    create?: XOR<environmentCreateWithoutEnv_userInput, environmentUncheckedCreateWithoutEnv_userInput>
    connectOrCreate?: environmentCreateOrConnectWithoutEnv_userInput
    upsert?: environmentUpsertWithoutEnv_userInput
    disconnect?: environmentWhereInput | boolean
    delete?: environmentWhereInput | boolean
    connect?: environmentWhereUniqueInput
    update?: XOR<XOR<environmentUpdateToOneWithWhereWithoutEnv_userInput, environmentUpdateWithoutEnv_userInput>, environmentUncheckedUpdateWithoutEnv_userInput>
  }

  export type userUpdateOneRequiredWithoutEnv_userNestedInput = {
    create?: XOR<userCreateWithoutEnv_userInput, userUncheckedCreateWithoutEnv_userInput>
    connectOrCreate?: userCreateOrConnectWithoutEnv_userInput
    upsert?: userUpsertWithoutEnv_userInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutEnv_userInput, userUpdateWithoutEnv_userInput>, userUncheckedUpdateWithoutEnv_userInput>
  }

  export type env_delimiterCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<env_delimiterCreateWithoutEnvironmentInput, env_delimiterUncheckedCreateWithoutEnvironmentInput> | env_delimiterCreateWithoutEnvironmentInput[] | env_delimiterUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: env_delimiterCreateOrConnectWithoutEnvironmentInput | env_delimiterCreateOrConnectWithoutEnvironmentInput[]
    createMany?: env_delimiterCreateManyEnvironmentInputEnvelope
    connect?: env_delimiterWhereUniqueInput | env_delimiterWhereUniqueInput[]
  }

  export type env_userCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<env_userCreateWithoutEnvironmentInput, env_userUncheckedCreateWithoutEnvironmentInput> | env_userCreateWithoutEnvironmentInput[] | env_userUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: env_userCreateOrConnectWithoutEnvironmentInput | env_userCreateOrConnectWithoutEnvironmentInput[]
    createMany?: env_userCreateManyEnvironmentInputEnvelope
    connect?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
  }

  export type mapCreateNestedOneWithoutEnvironmentInput = {
    create?: XOR<mapCreateWithoutEnvironmentInput, mapUncheckedCreateWithoutEnvironmentInput>
    connectOrCreate?: mapCreateOrConnectWithoutEnvironmentInput
    connect?: mapWhereUniqueInput
  }

  export type poiCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<poiCreateWithoutEnvironmentInput, poiUncheckedCreateWithoutEnvironmentInput> | poiCreateWithoutEnvironmentInput[] | poiUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: poiCreateOrConnectWithoutEnvironmentInput | poiCreateOrConnectWithoutEnvironmentInput[]
    createMany?: poiCreateManyEnvironmentInputEnvelope
    connect?: poiWhereUniqueInput | poiWhereUniqueInput[]
  }

  export type zoneCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<zoneCreateWithoutEnvironmentInput, zoneUncheckedCreateWithoutEnvironmentInput> | zoneCreateWithoutEnvironmentInput[] | zoneUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: zoneCreateOrConnectWithoutEnvironmentInput | zoneCreateOrConnectWithoutEnvironmentInput[]
    createMany?: zoneCreateManyEnvironmentInputEnvelope
    connect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
  }

  export type env_delimiterUncheckedCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<env_delimiterCreateWithoutEnvironmentInput, env_delimiterUncheckedCreateWithoutEnvironmentInput> | env_delimiterCreateWithoutEnvironmentInput[] | env_delimiterUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: env_delimiterCreateOrConnectWithoutEnvironmentInput | env_delimiterCreateOrConnectWithoutEnvironmentInput[]
    createMany?: env_delimiterCreateManyEnvironmentInputEnvelope
    connect?: env_delimiterWhereUniqueInput | env_delimiterWhereUniqueInput[]
  }

  export type env_userUncheckedCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<env_userCreateWithoutEnvironmentInput, env_userUncheckedCreateWithoutEnvironmentInput> | env_userCreateWithoutEnvironmentInput[] | env_userUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: env_userCreateOrConnectWithoutEnvironmentInput | env_userCreateOrConnectWithoutEnvironmentInput[]
    createMany?: env_userCreateManyEnvironmentInputEnvelope
    connect?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
  }

  export type poiUncheckedCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<poiCreateWithoutEnvironmentInput, poiUncheckedCreateWithoutEnvironmentInput> | poiCreateWithoutEnvironmentInput[] | poiUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: poiCreateOrConnectWithoutEnvironmentInput | poiCreateOrConnectWithoutEnvironmentInput[]
    createMany?: poiCreateManyEnvironmentInputEnvelope
    connect?: poiWhereUniqueInput | poiWhereUniqueInput[]
  }

  export type zoneUncheckedCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<zoneCreateWithoutEnvironmentInput, zoneUncheckedCreateWithoutEnvironmentInput> | zoneCreateWithoutEnvironmentInput[] | zoneUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: zoneCreateOrConnectWithoutEnvironmentInput | zoneCreateOrConnectWithoutEnvironmentInput[]
    createMany?: zoneCreateManyEnvironmentInputEnvelope
    connect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
  }

  export type env_delimiterUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<env_delimiterCreateWithoutEnvironmentInput, env_delimiterUncheckedCreateWithoutEnvironmentInput> | env_delimiterCreateWithoutEnvironmentInput[] | env_delimiterUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: env_delimiterCreateOrConnectWithoutEnvironmentInput | env_delimiterCreateOrConnectWithoutEnvironmentInput[]
    upsert?: env_delimiterUpsertWithWhereUniqueWithoutEnvironmentInput | env_delimiterUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: env_delimiterCreateManyEnvironmentInputEnvelope
    set?: env_delimiterWhereUniqueInput | env_delimiterWhereUniqueInput[]
    disconnect?: env_delimiterWhereUniqueInput | env_delimiterWhereUniqueInput[]
    delete?: env_delimiterWhereUniqueInput | env_delimiterWhereUniqueInput[]
    connect?: env_delimiterWhereUniqueInput | env_delimiterWhereUniqueInput[]
    update?: env_delimiterUpdateWithWhereUniqueWithoutEnvironmentInput | env_delimiterUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: env_delimiterUpdateManyWithWhereWithoutEnvironmentInput | env_delimiterUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: env_delimiterScalarWhereInput | env_delimiterScalarWhereInput[]
  }

  export type env_userUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<env_userCreateWithoutEnvironmentInput, env_userUncheckedCreateWithoutEnvironmentInput> | env_userCreateWithoutEnvironmentInput[] | env_userUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: env_userCreateOrConnectWithoutEnvironmentInput | env_userCreateOrConnectWithoutEnvironmentInput[]
    upsert?: env_userUpsertWithWhereUniqueWithoutEnvironmentInput | env_userUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: env_userCreateManyEnvironmentInputEnvelope
    set?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
    disconnect?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
    delete?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
    connect?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
    update?: env_userUpdateWithWhereUniqueWithoutEnvironmentInput | env_userUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: env_userUpdateManyWithWhereWithoutEnvironmentInput | env_userUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: env_userScalarWhereInput | env_userScalarWhereInput[]
  }

  export type mapUpdateOneWithoutEnvironmentNestedInput = {
    create?: XOR<mapCreateWithoutEnvironmentInput, mapUncheckedCreateWithoutEnvironmentInput>
    connectOrCreate?: mapCreateOrConnectWithoutEnvironmentInput
    upsert?: mapUpsertWithoutEnvironmentInput
    disconnect?: mapWhereInput | boolean
    delete?: mapWhereInput | boolean
    connect?: mapWhereUniqueInput
    update?: XOR<XOR<mapUpdateToOneWithWhereWithoutEnvironmentInput, mapUpdateWithoutEnvironmentInput>, mapUncheckedUpdateWithoutEnvironmentInput>
  }

  export type poiUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<poiCreateWithoutEnvironmentInput, poiUncheckedCreateWithoutEnvironmentInput> | poiCreateWithoutEnvironmentInput[] | poiUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: poiCreateOrConnectWithoutEnvironmentInput | poiCreateOrConnectWithoutEnvironmentInput[]
    upsert?: poiUpsertWithWhereUniqueWithoutEnvironmentInput | poiUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: poiCreateManyEnvironmentInputEnvelope
    set?: poiWhereUniqueInput | poiWhereUniqueInput[]
    disconnect?: poiWhereUniqueInput | poiWhereUniqueInput[]
    delete?: poiWhereUniqueInput | poiWhereUniqueInput[]
    connect?: poiWhereUniqueInput | poiWhereUniqueInput[]
    update?: poiUpdateWithWhereUniqueWithoutEnvironmentInput | poiUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: poiUpdateManyWithWhereWithoutEnvironmentInput | poiUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: poiScalarWhereInput | poiScalarWhereInput[]
  }

  export type zoneUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<zoneCreateWithoutEnvironmentInput, zoneUncheckedCreateWithoutEnvironmentInput> | zoneCreateWithoutEnvironmentInput[] | zoneUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: zoneCreateOrConnectWithoutEnvironmentInput | zoneCreateOrConnectWithoutEnvironmentInput[]
    upsert?: zoneUpsertWithWhereUniqueWithoutEnvironmentInput | zoneUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: zoneCreateManyEnvironmentInputEnvelope
    set?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    disconnect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    delete?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    connect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    update?: zoneUpdateWithWhereUniqueWithoutEnvironmentInput | zoneUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: zoneUpdateManyWithWhereWithoutEnvironmentInput | zoneUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: zoneScalarWhereInput | zoneScalarWhereInput[]
  }

  export type env_delimiterUncheckedUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<env_delimiterCreateWithoutEnvironmentInput, env_delimiterUncheckedCreateWithoutEnvironmentInput> | env_delimiterCreateWithoutEnvironmentInput[] | env_delimiterUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: env_delimiterCreateOrConnectWithoutEnvironmentInput | env_delimiterCreateOrConnectWithoutEnvironmentInput[]
    upsert?: env_delimiterUpsertWithWhereUniqueWithoutEnvironmentInput | env_delimiterUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: env_delimiterCreateManyEnvironmentInputEnvelope
    set?: env_delimiterWhereUniqueInput | env_delimiterWhereUniqueInput[]
    disconnect?: env_delimiterWhereUniqueInput | env_delimiterWhereUniqueInput[]
    delete?: env_delimiterWhereUniqueInput | env_delimiterWhereUniqueInput[]
    connect?: env_delimiterWhereUniqueInput | env_delimiterWhereUniqueInput[]
    update?: env_delimiterUpdateWithWhereUniqueWithoutEnvironmentInput | env_delimiterUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: env_delimiterUpdateManyWithWhereWithoutEnvironmentInput | env_delimiterUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: env_delimiterScalarWhereInput | env_delimiterScalarWhereInput[]
  }

  export type env_userUncheckedUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<env_userCreateWithoutEnvironmentInput, env_userUncheckedCreateWithoutEnvironmentInput> | env_userCreateWithoutEnvironmentInput[] | env_userUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: env_userCreateOrConnectWithoutEnvironmentInput | env_userCreateOrConnectWithoutEnvironmentInput[]
    upsert?: env_userUpsertWithWhereUniqueWithoutEnvironmentInput | env_userUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: env_userCreateManyEnvironmentInputEnvelope
    set?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
    disconnect?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
    delete?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
    connect?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
    update?: env_userUpdateWithWhereUniqueWithoutEnvironmentInput | env_userUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: env_userUpdateManyWithWhereWithoutEnvironmentInput | env_userUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: env_userScalarWhereInput | env_userScalarWhereInput[]
  }

  export type poiUncheckedUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<poiCreateWithoutEnvironmentInput, poiUncheckedCreateWithoutEnvironmentInput> | poiCreateWithoutEnvironmentInput[] | poiUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: poiCreateOrConnectWithoutEnvironmentInput | poiCreateOrConnectWithoutEnvironmentInput[]
    upsert?: poiUpsertWithWhereUniqueWithoutEnvironmentInput | poiUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: poiCreateManyEnvironmentInputEnvelope
    set?: poiWhereUniqueInput | poiWhereUniqueInput[]
    disconnect?: poiWhereUniqueInput | poiWhereUniqueInput[]
    delete?: poiWhereUniqueInput | poiWhereUniqueInput[]
    connect?: poiWhereUniqueInput | poiWhereUniqueInput[]
    update?: poiUpdateWithWhereUniqueWithoutEnvironmentInput | poiUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: poiUpdateManyWithWhereWithoutEnvironmentInput | poiUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: poiScalarWhereInput | poiScalarWhereInput[]
  }

  export type zoneUncheckedUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<zoneCreateWithoutEnvironmentInput, zoneUncheckedCreateWithoutEnvironmentInput> | zoneCreateWithoutEnvironmentInput[] | zoneUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: zoneCreateOrConnectWithoutEnvironmentInput | zoneCreateOrConnectWithoutEnvironmentInput[]
    upsert?: zoneUpsertWithWhereUniqueWithoutEnvironmentInput | zoneUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: zoneCreateManyEnvironmentInputEnvelope
    set?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    disconnect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    delete?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    connect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    update?: zoneUpdateWithWhereUniqueWithoutEnvironmentInput | zoneUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: zoneUpdateManyWithWhereWithoutEnvironmentInput | zoneUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: zoneScalarWhereInput | zoneScalarWhereInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumExpenseCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseCategory | null
  }

  export type mapCreateNestedManyWithoutFormatInput = {
    create?: XOR<mapCreateWithoutFormatInput, mapUncheckedCreateWithoutFormatInput> | mapCreateWithoutFormatInput[] | mapUncheckedCreateWithoutFormatInput[]
    connectOrCreate?: mapCreateOrConnectWithoutFormatInput | mapCreateOrConnectWithoutFormatInput[]
    createMany?: mapCreateManyFormatInputEnvelope
    connect?: mapWhereUniqueInput | mapWhereUniqueInput[]
  }

  export type mapUncheckedCreateNestedManyWithoutFormatInput = {
    create?: XOR<mapCreateWithoutFormatInput, mapUncheckedCreateWithoutFormatInput> | mapCreateWithoutFormatInput[] | mapUncheckedCreateWithoutFormatInput[]
    connectOrCreate?: mapCreateOrConnectWithoutFormatInput | mapCreateOrConnectWithoutFormatInput[]
    createMany?: mapCreateManyFormatInputEnvelope
    connect?: mapWhereUniqueInput | mapWhereUniqueInput[]
  }

  export type mapUpdateManyWithoutFormatNestedInput = {
    create?: XOR<mapCreateWithoutFormatInput, mapUncheckedCreateWithoutFormatInput> | mapCreateWithoutFormatInput[] | mapUncheckedCreateWithoutFormatInput[]
    connectOrCreate?: mapCreateOrConnectWithoutFormatInput | mapCreateOrConnectWithoutFormatInput[]
    upsert?: mapUpsertWithWhereUniqueWithoutFormatInput | mapUpsertWithWhereUniqueWithoutFormatInput[]
    createMany?: mapCreateManyFormatInputEnvelope
    set?: mapWhereUniqueInput | mapWhereUniqueInput[]
    disconnect?: mapWhereUniqueInput | mapWhereUniqueInput[]
    delete?: mapWhereUniqueInput | mapWhereUniqueInput[]
    connect?: mapWhereUniqueInput | mapWhereUniqueInput[]
    update?: mapUpdateWithWhereUniqueWithoutFormatInput | mapUpdateWithWhereUniqueWithoutFormatInput[]
    updateMany?: mapUpdateManyWithWhereWithoutFormatInput | mapUpdateManyWithWhereWithoutFormatInput[]
    deleteMany?: mapScalarWhereInput | mapScalarWhereInput[]
  }

  export type mapUncheckedUpdateManyWithoutFormatNestedInput = {
    create?: XOR<mapCreateWithoutFormatInput, mapUncheckedCreateWithoutFormatInput> | mapCreateWithoutFormatInput[] | mapUncheckedCreateWithoutFormatInput[]
    connectOrCreate?: mapCreateOrConnectWithoutFormatInput | mapCreateOrConnectWithoutFormatInput[]
    upsert?: mapUpsertWithWhereUniqueWithoutFormatInput | mapUpsertWithWhereUniqueWithoutFormatInput[]
    createMany?: mapCreateManyFormatInputEnvelope
    set?: mapWhereUniqueInput | mapWhereUniqueInput[]
    disconnect?: mapWhereUniqueInput | mapWhereUniqueInput[]
    delete?: mapWhereUniqueInput | mapWhereUniqueInput[]
    connect?: mapWhereUniqueInput | mapWhereUniqueInput[]
    update?: mapUpdateWithWhereUniqueWithoutFormatInput | mapUpdateWithWhereUniqueWithoutFormatInput[]
    updateMany?: mapUpdateManyWithWhereWithoutFormatInput | mapUpdateManyWithWhereWithoutFormatInput[]
    deleteMany?: mapScalarWhereInput | mapScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutHelper_user_helper_user_helper_idTouserInput = {
    create?: XOR<userCreateWithoutHelper_user_helper_user_helper_idTouserInput, userUncheckedCreateWithoutHelper_user_helper_user_helper_idTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutHelper_user_helper_user_helper_idTouserInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutHelper_user_helper_user_user_idTouserInput = {
    create?: XOR<userCreateWithoutHelper_user_helper_user_user_idTouserInput, userUncheckedCreateWithoutHelper_user_helper_user_user_idTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutHelper_user_helper_user_user_idTouserInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutHelper_user_helper_user_helper_idTouserNestedInput = {
    create?: XOR<userCreateWithoutHelper_user_helper_user_helper_idTouserInput, userUncheckedCreateWithoutHelper_user_helper_user_helper_idTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutHelper_user_helper_user_helper_idTouserInput
    upsert?: userUpsertWithoutHelper_user_helper_user_helper_idTouserInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutHelper_user_helper_user_helper_idTouserInput, userUpdateWithoutHelper_user_helper_user_helper_idTouserInput>, userUncheckedUpdateWithoutHelper_user_helper_user_helper_idTouserInput>
  }

  export type userUpdateOneWithoutHelper_user_helper_user_user_idTouserNestedInput = {
    create?: XOR<userCreateWithoutHelper_user_helper_user_user_idTouserInput, userUncheckedCreateWithoutHelper_user_helper_user_user_idTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutHelper_user_helper_user_user_idTouserInput
    upsert?: userUpsertWithoutHelper_user_helper_user_user_idTouserInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutHelper_user_helper_user_user_idTouserInput, userUpdateWithoutHelper_user_helper_user_user_idTouserInput>, userUncheckedUpdateWithoutHelper_user_helper_user_user_idTouserInput>
  }

  export type userCreateNestedOneWithoutIntervention_historyInput = {
    create?: XOR<userCreateWithoutIntervention_historyInput, userUncheckedCreateWithoutIntervention_historyInput>
    connectOrCreate?: userCreateOrConnectWithoutIntervention_historyInput
    connect?: userWhereUniqueInput
  }

  export type NullableEnumintervention_typeFieldUpdateOperationsInput = {
    set?: $Enums.intervention_type | null
  }

  export type userUpdateOneWithoutIntervention_historyNestedInput = {
    create?: XOR<userCreateWithoutIntervention_historyInput, userUncheckedCreateWithoutIntervention_historyInput>
    connectOrCreate?: userCreateOrConnectWithoutIntervention_historyInput
    upsert?: userUpsertWithoutIntervention_historyInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutIntervention_historyInput, userUpdateWithoutIntervention_historyInput>, userUncheckedUpdateWithoutIntervention_historyInput>
  }

  export type userCreateNestedOneWithoutLocalisationInput = {
    create?: XOR<userCreateWithoutLocalisationInput, userUncheckedCreateWithoutLocalisationInput>
    connectOrCreate?: userCreateOrConnectWithoutLocalisationInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutLocalisationNestedInput = {
    create?: XOR<userCreateWithoutLocalisationInput, userUncheckedCreateWithoutLocalisationInput>
    connectOrCreate?: userCreateOrConnectWithoutLocalisationInput
    upsert?: userUpsertWithoutLocalisationInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutLocalisationInput, userUpdateWithoutLocalisationInput>, userUncheckedUpdateWithoutLocalisationInput>
  }

  export type environmentCreateNestedManyWithoutMapInput = {
    create?: XOR<environmentCreateWithoutMapInput, environmentUncheckedCreateWithoutMapInput> | environmentCreateWithoutMapInput[] | environmentUncheckedCreateWithoutMapInput[]
    connectOrCreate?: environmentCreateOrConnectWithoutMapInput | environmentCreateOrConnectWithoutMapInput[]
    createMany?: environmentCreateManyMapInputEnvelope
    connect?: environmentWhereUniqueInput | environmentWhereUniqueInput[]
  }

  export type formatCreateNestedOneWithoutMapInput = {
    create?: XOR<formatCreateWithoutMapInput, formatUncheckedCreateWithoutMapInput>
    connectOrCreate?: formatCreateOrConnectWithoutMapInput
    connect?: formatWhereUniqueInput
  }

  export type poiCreateNestedManyWithoutMapInput = {
    create?: XOR<poiCreateWithoutMapInput, poiUncheckedCreateWithoutMapInput> | poiCreateWithoutMapInput[] | poiUncheckedCreateWithoutMapInput[]
    connectOrCreate?: poiCreateOrConnectWithoutMapInput | poiCreateOrConnectWithoutMapInput[]
    createMany?: poiCreateManyMapInputEnvelope
    connect?: poiWhereUniqueInput | poiWhereUniqueInput[]
  }

  export type zoneCreateNestedManyWithoutMapInput = {
    create?: XOR<zoneCreateWithoutMapInput, zoneUncheckedCreateWithoutMapInput> | zoneCreateWithoutMapInput[] | zoneUncheckedCreateWithoutMapInput[]
    connectOrCreate?: zoneCreateOrConnectWithoutMapInput | zoneCreateOrConnectWithoutMapInput[]
    createMany?: zoneCreateManyMapInputEnvelope
    connect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
  }

  export type environmentUncheckedCreateNestedManyWithoutMapInput = {
    create?: XOR<environmentCreateWithoutMapInput, environmentUncheckedCreateWithoutMapInput> | environmentCreateWithoutMapInput[] | environmentUncheckedCreateWithoutMapInput[]
    connectOrCreate?: environmentCreateOrConnectWithoutMapInput | environmentCreateOrConnectWithoutMapInput[]
    createMany?: environmentCreateManyMapInputEnvelope
    connect?: environmentWhereUniqueInput | environmentWhereUniqueInput[]
  }

  export type poiUncheckedCreateNestedManyWithoutMapInput = {
    create?: XOR<poiCreateWithoutMapInput, poiUncheckedCreateWithoutMapInput> | poiCreateWithoutMapInput[] | poiUncheckedCreateWithoutMapInput[]
    connectOrCreate?: poiCreateOrConnectWithoutMapInput | poiCreateOrConnectWithoutMapInput[]
    createMany?: poiCreateManyMapInputEnvelope
    connect?: poiWhereUniqueInput | poiWhereUniqueInput[]
  }

  export type zoneUncheckedCreateNestedManyWithoutMapInput = {
    create?: XOR<zoneCreateWithoutMapInput, zoneUncheckedCreateWithoutMapInput> | zoneCreateWithoutMapInput[] | zoneUncheckedCreateWithoutMapInput[]
    connectOrCreate?: zoneCreateOrConnectWithoutMapInput | zoneCreateOrConnectWithoutMapInput[]
    createMany?: zoneCreateManyMapInputEnvelope
    connect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
  }

  export type environmentUpdateManyWithoutMapNestedInput = {
    create?: XOR<environmentCreateWithoutMapInput, environmentUncheckedCreateWithoutMapInput> | environmentCreateWithoutMapInput[] | environmentUncheckedCreateWithoutMapInput[]
    connectOrCreate?: environmentCreateOrConnectWithoutMapInput | environmentCreateOrConnectWithoutMapInput[]
    upsert?: environmentUpsertWithWhereUniqueWithoutMapInput | environmentUpsertWithWhereUniqueWithoutMapInput[]
    createMany?: environmentCreateManyMapInputEnvelope
    set?: environmentWhereUniqueInput | environmentWhereUniqueInput[]
    disconnect?: environmentWhereUniqueInput | environmentWhereUniqueInput[]
    delete?: environmentWhereUniqueInput | environmentWhereUniqueInput[]
    connect?: environmentWhereUniqueInput | environmentWhereUniqueInput[]
    update?: environmentUpdateWithWhereUniqueWithoutMapInput | environmentUpdateWithWhereUniqueWithoutMapInput[]
    updateMany?: environmentUpdateManyWithWhereWithoutMapInput | environmentUpdateManyWithWhereWithoutMapInput[]
    deleteMany?: environmentScalarWhereInput | environmentScalarWhereInput[]
  }

  export type formatUpdateOneWithoutMapNestedInput = {
    create?: XOR<formatCreateWithoutMapInput, formatUncheckedCreateWithoutMapInput>
    connectOrCreate?: formatCreateOrConnectWithoutMapInput
    upsert?: formatUpsertWithoutMapInput
    disconnect?: formatWhereInput | boolean
    delete?: formatWhereInput | boolean
    connect?: formatWhereUniqueInput
    update?: XOR<XOR<formatUpdateToOneWithWhereWithoutMapInput, formatUpdateWithoutMapInput>, formatUncheckedUpdateWithoutMapInput>
  }

  export type poiUpdateManyWithoutMapNestedInput = {
    create?: XOR<poiCreateWithoutMapInput, poiUncheckedCreateWithoutMapInput> | poiCreateWithoutMapInput[] | poiUncheckedCreateWithoutMapInput[]
    connectOrCreate?: poiCreateOrConnectWithoutMapInput | poiCreateOrConnectWithoutMapInput[]
    upsert?: poiUpsertWithWhereUniqueWithoutMapInput | poiUpsertWithWhereUniqueWithoutMapInput[]
    createMany?: poiCreateManyMapInputEnvelope
    set?: poiWhereUniqueInput | poiWhereUniqueInput[]
    disconnect?: poiWhereUniqueInput | poiWhereUniqueInput[]
    delete?: poiWhereUniqueInput | poiWhereUniqueInput[]
    connect?: poiWhereUniqueInput | poiWhereUniqueInput[]
    update?: poiUpdateWithWhereUniqueWithoutMapInput | poiUpdateWithWhereUniqueWithoutMapInput[]
    updateMany?: poiUpdateManyWithWhereWithoutMapInput | poiUpdateManyWithWhereWithoutMapInput[]
    deleteMany?: poiScalarWhereInput | poiScalarWhereInput[]
  }

  export type zoneUpdateManyWithoutMapNestedInput = {
    create?: XOR<zoneCreateWithoutMapInput, zoneUncheckedCreateWithoutMapInput> | zoneCreateWithoutMapInput[] | zoneUncheckedCreateWithoutMapInput[]
    connectOrCreate?: zoneCreateOrConnectWithoutMapInput | zoneCreateOrConnectWithoutMapInput[]
    upsert?: zoneUpsertWithWhereUniqueWithoutMapInput | zoneUpsertWithWhereUniqueWithoutMapInput[]
    createMany?: zoneCreateManyMapInputEnvelope
    set?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    disconnect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    delete?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    connect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    update?: zoneUpdateWithWhereUniqueWithoutMapInput | zoneUpdateWithWhereUniqueWithoutMapInput[]
    updateMany?: zoneUpdateManyWithWhereWithoutMapInput | zoneUpdateManyWithWhereWithoutMapInput[]
    deleteMany?: zoneScalarWhereInput | zoneScalarWhereInput[]
  }

  export type environmentUncheckedUpdateManyWithoutMapNestedInput = {
    create?: XOR<environmentCreateWithoutMapInput, environmentUncheckedCreateWithoutMapInput> | environmentCreateWithoutMapInput[] | environmentUncheckedCreateWithoutMapInput[]
    connectOrCreate?: environmentCreateOrConnectWithoutMapInput | environmentCreateOrConnectWithoutMapInput[]
    upsert?: environmentUpsertWithWhereUniqueWithoutMapInput | environmentUpsertWithWhereUniqueWithoutMapInput[]
    createMany?: environmentCreateManyMapInputEnvelope
    set?: environmentWhereUniqueInput | environmentWhereUniqueInput[]
    disconnect?: environmentWhereUniqueInput | environmentWhereUniqueInput[]
    delete?: environmentWhereUniqueInput | environmentWhereUniqueInput[]
    connect?: environmentWhereUniqueInput | environmentWhereUniqueInput[]
    update?: environmentUpdateWithWhereUniqueWithoutMapInput | environmentUpdateWithWhereUniqueWithoutMapInput[]
    updateMany?: environmentUpdateManyWithWhereWithoutMapInput | environmentUpdateManyWithWhereWithoutMapInput[]
    deleteMany?: environmentScalarWhereInput | environmentScalarWhereInput[]
  }

  export type poiUncheckedUpdateManyWithoutMapNestedInput = {
    create?: XOR<poiCreateWithoutMapInput, poiUncheckedCreateWithoutMapInput> | poiCreateWithoutMapInput[] | poiUncheckedCreateWithoutMapInput[]
    connectOrCreate?: poiCreateOrConnectWithoutMapInput | poiCreateOrConnectWithoutMapInput[]
    upsert?: poiUpsertWithWhereUniqueWithoutMapInput | poiUpsertWithWhereUniqueWithoutMapInput[]
    createMany?: poiCreateManyMapInputEnvelope
    set?: poiWhereUniqueInput | poiWhereUniqueInput[]
    disconnect?: poiWhereUniqueInput | poiWhereUniqueInput[]
    delete?: poiWhereUniqueInput | poiWhereUniqueInput[]
    connect?: poiWhereUniqueInput | poiWhereUniqueInput[]
    update?: poiUpdateWithWhereUniqueWithoutMapInput | poiUpdateWithWhereUniqueWithoutMapInput[]
    updateMany?: poiUpdateManyWithWhereWithoutMapInput | poiUpdateManyWithWhereWithoutMapInput[]
    deleteMany?: poiScalarWhereInput | poiScalarWhereInput[]
  }

  export type zoneUncheckedUpdateManyWithoutMapNestedInput = {
    create?: XOR<zoneCreateWithoutMapInput, zoneUncheckedCreateWithoutMapInput> | zoneCreateWithoutMapInput[] | zoneUncheckedCreateWithoutMapInput[]
    connectOrCreate?: zoneCreateOrConnectWithoutMapInput | zoneCreateOrConnectWithoutMapInput[]
    upsert?: zoneUpsertWithWhereUniqueWithoutMapInput | zoneUpsertWithWhereUniqueWithoutMapInput[]
    createMany?: zoneCreateManyMapInputEnvelope
    set?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    disconnect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    delete?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    connect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    update?: zoneUpdateWithWhereUniqueWithoutMapInput | zoneUpdateWithWhereUniqueWithoutMapInput[]
    updateMany?: zoneUpdateManyWithWhereWithoutMapInput | zoneUpdateManyWithWhereWithoutMapInput[]
    deleteMany?: zoneScalarWhereInput | zoneScalarWhereInput[]
  }

  export type alertCreateNestedOneWithoutPanne_historyInput = {
    create?: XOR<alertCreateWithoutPanne_historyInput, alertUncheckedCreateWithoutPanne_historyInput>
    connectOrCreate?: alertCreateOrConnectWithoutPanne_historyInput
    connect?: alertWhereUniqueInput
  }

  export type alertUpdateOneWithoutPanne_historyNestedInput = {
    create?: XOR<alertCreateWithoutPanne_historyInput, alertUncheckedCreateWithoutPanne_historyInput>
    connectOrCreate?: alertCreateOrConnectWithoutPanne_historyInput
    upsert?: alertUpsertWithoutPanne_historyInput
    disconnect?: alertWhereInput | boolean
    delete?: alertWhereInput | boolean
    connect?: alertWhereUniqueInput
    update?: XOR<XOR<alertUpdateToOneWithWhereWithoutPanne_historyInput, alertUpdateWithoutPanne_historyInput>, alertUncheckedUpdateWithoutPanne_historyInput>
  }

  export type poi_categoryCreateNestedOneWithoutPoiInput = {
    create?: XOR<poi_categoryCreateWithoutPoiInput, poi_categoryUncheckedCreateWithoutPoiInput>
    connectOrCreate?: poi_categoryCreateOrConnectWithoutPoiInput
    connect?: poi_categoryWhereUniqueInput
  }

  export type environmentCreateNestedOneWithoutPoiInput = {
    create?: XOR<environmentCreateWithoutPoiInput, environmentUncheckedCreateWithoutPoiInput>
    connectOrCreate?: environmentCreateOrConnectWithoutPoiInput
    connect?: environmentWhereUniqueInput
  }

  export type mapCreateNestedOneWithoutPoiInput = {
    create?: XOR<mapCreateWithoutPoiInput, mapUncheckedCreateWithoutPoiInput>
    connectOrCreate?: mapCreateOrConnectWithoutPoiInput
    connect?: mapWhereUniqueInput
  }

  export type poi_zoneCreateNestedManyWithoutPoiInput = {
    create?: XOR<poi_zoneCreateWithoutPoiInput, poi_zoneUncheckedCreateWithoutPoiInput> | poi_zoneCreateWithoutPoiInput[] | poi_zoneUncheckedCreateWithoutPoiInput[]
    connectOrCreate?: poi_zoneCreateOrConnectWithoutPoiInput | poi_zoneCreateOrConnectWithoutPoiInput[]
    createMany?: poi_zoneCreateManyPoiInputEnvelope
    connect?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
  }

  export type poi_zoneUncheckedCreateNestedManyWithoutPoiInput = {
    create?: XOR<poi_zoneCreateWithoutPoiInput, poi_zoneUncheckedCreateWithoutPoiInput> | poi_zoneCreateWithoutPoiInput[] | poi_zoneUncheckedCreateWithoutPoiInput[]
    connectOrCreate?: poi_zoneCreateOrConnectWithoutPoiInput | poi_zoneCreateOrConnectWithoutPoiInput[]
    createMany?: poi_zoneCreateManyPoiInputEnvelope
    connect?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
  }

  export type poi_categoryUpdateOneWithoutPoiNestedInput = {
    create?: XOR<poi_categoryCreateWithoutPoiInput, poi_categoryUncheckedCreateWithoutPoiInput>
    connectOrCreate?: poi_categoryCreateOrConnectWithoutPoiInput
    upsert?: poi_categoryUpsertWithoutPoiInput
    disconnect?: poi_categoryWhereInput | boolean
    delete?: poi_categoryWhereInput | boolean
    connect?: poi_categoryWhereUniqueInput
    update?: XOR<XOR<poi_categoryUpdateToOneWithWhereWithoutPoiInput, poi_categoryUpdateWithoutPoiInput>, poi_categoryUncheckedUpdateWithoutPoiInput>
  }

  export type environmentUpdateOneWithoutPoiNestedInput = {
    create?: XOR<environmentCreateWithoutPoiInput, environmentUncheckedCreateWithoutPoiInput>
    connectOrCreate?: environmentCreateOrConnectWithoutPoiInput
    upsert?: environmentUpsertWithoutPoiInput
    disconnect?: environmentWhereInput | boolean
    delete?: environmentWhereInput | boolean
    connect?: environmentWhereUniqueInput
    update?: XOR<XOR<environmentUpdateToOneWithWhereWithoutPoiInput, environmentUpdateWithoutPoiInput>, environmentUncheckedUpdateWithoutPoiInput>
  }

  export type mapUpdateOneWithoutPoiNestedInput = {
    create?: XOR<mapCreateWithoutPoiInput, mapUncheckedCreateWithoutPoiInput>
    connectOrCreate?: mapCreateOrConnectWithoutPoiInput
    upsert?: mapUpsertWithoutPoiInput
    disconnect?: mapWhereInput | boolean
    delete?: mapWhereInput | boolean
    connect?: mapWhereUniqueInput
    update?: XOR<XOR<mapUpdateToOneWithWhereWithoutPoiInput, mapUpdateWithoutPoiInput>, mapUncheckedUpdateWithoutPoiInput>
  }

  export type poi_zoneUpdateManyWithoutPoiNestedInput = {
    create?: XOR<poi_zoneCreateWithoutPoiInput, poi_zoneUncheckedCreateWithoutPoiInput> | poi_zoneCreateWithoutPoiInput[] | poi_zoneUncheckedCreateWithoutPoiInput[]
    connectOrCreate?: poi_zoneCreateOrConnectWithoutPoiInput | poi_zoneCreateOrConnectWithoutPoiInput[]
    upsert?: poi_zoneUpsertWithWhereUniqueWithoutPoiInput | poi_zoneUpsertWithWhereUniqueWithoutPoiInput[]
    createMany?: poi_zoneCreateManyPoiInputEnvelope
    set?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
    disconnect?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
    delete?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
    connect?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
    update?: poi_zoneUpdateWithWhereUniqueWithoutPoiInput | poi_zoneUpdateWithWhereUniqueWithoutPoiInput[]
    updateMany?: poi_zoneUpdateManyWithWhereWithoutPoiInput | poi_zoneUpdateManyWithWhereWithoutPoiInput[]
    deleteMany?: poi_zoneScalarWhereInput | poi_zoneScalarWhereInput[]
  }

  export type poi_zoneUncheckedUpdateManyWithoutPoiNestedInput = {
    create?: XOR<poi_zoneCreateWithoutPoiInput, poi_zoneUncheckedCreateWithoutPoiInput> | poi_zoneCreateWithoutPoiInput[] | poi_zoneUncheckedCreateWithoutPoiInput[]
    connectOrCreate?: poi_zoneCreateOrConnectWithoutPoiInput | poi_zoneCreateOrConnectWithoutPoiInput[]
    upsert?: poi_zoneUpsertWithWhereUniqueWithoutPoiInput | poi_zoneUpsertWithWhereUniqueWithoutPoiInput[]
    createMany?: poi_zoneCreateManyPoiInputEnvelope
    set?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
    disconnect?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
    delete?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
    connect?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
    update?: poi_zoneUpdateWithWhereUniqueWithoutPoiInput | poi_zoneUpdateWithWhereUniqueWithoutPoiInput[]
    updateMany?: poi_zoneUpdateManyWithWhereWithoutPoiInput | poi_zoneUpdateManyWithWhereWithoutPoiInput[]
    deleteMany?: poi_zoneScalarWhereInput | poi_zoneScalarWhereInput[]
  }

  export type poiCreateNestedManyWithoutPoi_categoryInput = {
    create?: XOR<poiCreateWithoutPoi_categoryInput, poiUncheckedCreateWithoutPoi_categoryInput> | poiCreateWithoutPoi_categoryInput[] | poiUncheckedCreateWithoutPoi_categoryInput[]
    connectOrCreate?: poiCreateOrConnectWithoutPoi_categoryInput | poiCreateOrConnectWithoutPoi_categoryInput[]
    createMany?: poiCreateManyPoi_categoryInputEnvelope
    connect?: poiWhereUniqueInput | poiWhereUniqueInput[]
  }

  export type poiUncheckedCreateNestedManyWithoutPoi_categoryInput = {
    create?: XOR<poiCreateWithoutPoi_categoryInput, poiUncheckedCreateWithoutPoi_categoryInput> | poiCreateWithoutPoi_categoryInput[] | poiUncheckedCreateWithoutPoi_categoryInput[]
    connectOrCreate?: poiCreateOrConnectWithoutPoi_categoryInput | poiCreateOrConnectWithoutPoi_categoryInput[]
    createMany?: poiCreateManyPoi_categoryInputEnvelope
    connect?: poiWhereUniqueInput | poiWhereUniqueInput[]
  }

  export type poiUpdateManyWithoutPoi_categoryNestedInput = {
    create?: XOR<poiCreateWithoutPoi_categoryInput, poiUncheckedCreateWithoutPoi_categoryInput> | poiCreateWithoutPoi_categoryInput[] | poiUncheckedCreateWithoutPoi_categoryInput[]
    connectOrCreate?: poiCreateOrConnectWithoutPoi_categoryInput | poiCreateOrConnectWithoutPoi_categoryInput[]
    upsert?: poiUpsertWithWhereUniqueWithoutPoi_categoryInput | poiUpsertWithWhereUniqueWithoutPoi_categoryInput[]
    createMany?: poiCreateManyPoi_categoryInputEnvelope
    set?: poiWhereUniqueInput | poiWhereUniqueInput[]
    disconnect?: poiWhereUniqueInput | poiWhereUniqueInput[]
    delete?: poiWhereUniqueInput | poiWhereUniqueInput[]
    connect?: poiWhereUniqueInput | poiWhereUniqueInput[]
    update?: poiUpdateWithWhereUniqueWithoutPoi_categoryInput | poiUpdateWithWhereUniqueWithoutPoi_categoryInput[]
    updateMany?: poiUpdateManyWithWhereWithoutPoi_categoryInput | poiUpdateManyWithWhereWithoutPoi_categoryInput[]
    deleteMany?: poiScalarWhereInput | poiScalarWhereInput[]
  }

  export type poiUncheckedUpdateManyWithoutPoi_categoryNestedInput = {
    create?: XOR<poiCreateWithoutPoi_categoryInput, poiUncheckedCreateWithoutPoi_categoryInput> | poiCreateWithoutPoi_categoryInput[] | poiUncheckedCreateWithoutPoi_categoryInput[]
    connectOrCreate?: poiCreateOrConnectWithoutPoi_categoryInput | poiCreateOrConnectWithoutPoi_categoryInput[]
    upsert?: poiUpsertWithWhereUniqueWithoutPoi_categoryInput | poiUpsertWithWhereUniqueWithoutPoi_categoryInput[]
    createMany?: poiCreateManyPoi_categoryInputEnvelope
    set?: poiWhereUniqueInput | poiWhereUniqueInput[]
    disconnect?: poiWhereUniqueInput | poiWhereUniqueInput[]
    delete?: poiWhereUniqueInput | poiWhereUniqueInput[]
    connect?: poiWhereUniqueInput | poiWhereUniqueInput[]
    update?: poiUpdateWithWhereUniqueWithoutPoi_categoryInput | poiUpdateWithWhereUniqueWithoutPoi_categoryInput[]
    updateMany?: poiUpdateManyWithWhereWithoutPoi_categoryInput | poiUpdateManyWithWhereWithoutPoi_categoryInput[]
    deleteMany?: poiScalarWhereInput | poiScalarWhereInput[]
  }

  export type poiCreateNestedOneWithoutPoi_zoneInput = {
    create?: XOR<poiCreateWithoutPoi_zoneInput, poiUncheckedCreateWithoutPoi_zoneInput>
    connectOrCreate?: poiCreateOrConnectWithoutPoi_zoneInput
    connect?: poiWhereUniqueInput
  }

  export type zoneCreateNestedOneWithoutPoi_zoneInput = {
    create?: XOR<zoneCreateWithoutPoi_zoneInput, zoneUncheckedCreateWithoutPoi_zoneInput>
    connectOrCreate?: zoneCreateOrConnectWithoutPoi_zoneInput
    connect?: zoneWhereUniqueInput
  }

  export type poiUpdateOneWithoutPoi_zoneNestedInput = {
    create?: XOR<poiCreateWithoutPoi_zoneInput, poiUncheckedCreateWithoutPoi_zoneInput>
    connectOrCreate?: poiCreateOrConnectWithoutPoi_zoneInput
    upsert?: poiUpsertWithoutPoi_zoneInput
    disconnect?: poiWhereInput | boolean
    delete?: poiWhereInput | boolean
    connect?: poiWhereUniqueInput
    update?: XOR<XOR<poiUpdateToOneWithWhereWithoutPoi_zoneInput, poiUpdateWithoutPoi_zoneInput>, poiUncheckedUpdateWithoutPoi_zoneInput>
  }

  export type zoneUpdateOneWithoutPoi_zoneNestedInput = {
    create?: XOR<zoneCreateWithoutPoi_zoneInput, zoneUncheckedCreateWithoutPoi_zoneInput>
    connectOrCreate?: zoneCreateOrConnectWithoutPoi_zoneInput
    upsert?: zoneUpsertWithoutPoi_zoneInput
    disconnect?: zoneWhereInput | boolean
    delete?: zoneWhereInput | boolean
    connect?: zoneWhereUniqueInput
    update?: XOR<XOR<zoneUpdateToOneWithWhereWithoutPoi_zoneInput, zoneUpdateWithoutPoi_zoneInput>, zoneUncheckedUpdateWithoutPoi_zoneInput>
  }

  export type deviceCreateNestedOneWithoutPurchase_historyInput = {
    create?: XOR<deviceCreateWithoutPurchase_historyInput, deviceUncheckedCreateWithoutPurchase_historyInput>
    connectOrCreate?: deviceCreateOrConnectWithoutPurchase_historyInput
    connect?: deviceWhereUniqueInput
  }

  export type userCreateNestedOneWithoutPurchase_historyInput = {
    create?: XOR<userCreateWithoutPurchase_historyInput, userUncheckedCreateWithoutPurchase_historyInput>
    connectOrCreate?: userCreateOrConnectWithoutPurchase_historyInput
    connect?: userWhereUniqueInput
  }

  export type deviceUpdateOneWithoutPurchase_historyNestedInput = {
    create?: XOR<deviceCreateWithoutPurchase_historyInput, deviceUncheckedCreateWithoutPurchase_historyInput>
    connectOrCreate?: deviceCreateOrConnectWithoutPurchase_historyInput
    upsert?: deviceUpsertWithoutPurchase_historyInput
    disconnect?: deviceWhereInput | boolean
    delete?: deviceWhereInput | boolean
    connect?: deviceWhereUniqueInput
    update?: XOR<XOR<deviceUpdateToOneWithWhereWithoutPurchase_historyInput, deviceUpdateWithoutPurchase_historyInput>, deviceUncheckedUpdateWithoutPurchase_historyInput>
  }

  export type userUpdateOneWithoutPurchase_historyNestedInput = {
    create?: XOR<userCreateWithoutPurchase_historyInput, userUncheckedCreateWithoutPurchase_historyInput>
    connectOrCreate?: userCreateOrConnectWithoutPurchase_historyInput
    upsert?: userUpsertWithoutPurchase_historyInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPurchase_historyInput, userUpdateWithoutPurchase_historyInput>, userUncheckedUpdateWithoutPurchase_historyInput>
  }

  export type deviceCreateNestedManyWithoutState_typeInput = {
    create?: XOR<deviceCreateWithoutState_typeInput, deviceUncheckedCreateWithoutState_typeInput> | deviceCreateWithoutState_typeInput[] | deviceUncheckedCreateWithoutState_typeInput[]
    connectOrCreate?: deviceCreateOrConnectWithoutState_typeInput | deviceCreateOrConnectWithoutState_typeInput[]
    createMany?: deviceCreateManyState_typeInputEnvelope
    connect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
  }

  export type deviceUncheckedCreateNestedManyWithoutState_typeInput = {
    create?: XOR<deviceCreateWithoutState_typeInput, deviceUncheckedCreateWithoutState_typeInput> | deviceCreateWithoutState_typeInput[] | deviceUncheckedCreateWithoutState_typeInput[]
    connectOrCreate?: deviceCreateOrConnectWithoutState_typeInput | deviceCreateOrConnectWithoutState_typeInput[]
    createMany?: deviceCreateManyState_typeInputEnvelope
    connect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
  }

  export type deviceUpdateManyWithoutState_typeNestedInput = {
    create?: XOR<deviceCreateWithoutState_typeInput, deviceUncheckedCreateWithoutState_typeInput> | deviceCreateWithoutState_typeInput[] | deviceUncheckedCreateWithoutState_typeInput[]
    connectOrCreate?: deviceCreateOrConnectWithoutState_typeInput | deviceCreateOrConnectWithoutState_typeInput[]
    upsert?: deviceUpsertWithWhereUniqueWithoutState_typeInput | deviceUpsertWithWhereUniqueWithoutState_typeInput[]
    createMany?: deviceCreateManyState_typeInputEnvelope
    set?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    disconnect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    delete?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    connect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    update?: deviceUpdateWithWhereUniqueWithoutState_typeInput | deviceUpdateWithWhereUniqueWithoutState_typeInput[]
    updateMany?: deviceUpdateManyWithWhereWithoutState_typeInput | deviceUpdateManyWithWhereWithoutState_typeInput[]
    deleteMany?: deviceScalarWhereInput | deviceScalarWhereInput[]
  }

  export type deviceUncheckedUpdateManyWithoutState_typeNestedInput = {
    create?: XOR<deviceCreateWithoutState_typeInput, deviceUncheckedCreateWithoutState_typeInput> | deviceCreateWithoutState_typeInput[] | deviceUncheckedCreateWithoutState_typeInput[]
    connectOrCreate?: deviceCreateOrConnectWithoutState_typeInput | deviceCreateOrConnectWithoutState_typeInput[]
    upsert?: deviceUpsertWithWhereUniqueWithoutState_typeInput | deviceUpsertWithWhereUniqueWithoutState_typeInput[]
    createMany?: deviceCreateManyState_typeInputEnvelope
    set?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    disconnect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    delete?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    connect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    update?: deviceUpdateWithWhereUniqueWithoutState_typeInput | deviceUpdateWithWhereUniqueWithoutState_typeInput[]
    updateMany?: deviceUpdateManyWithWhereWithoutState_typeInput | deviceUpdateManyWithWhereWithoutState_typeInput[]
    deleteMany?: deviceScalarWhereInput | deviceScalarWhereInput[]
  }

  export type deviceCreateNestedManyWithoutUserInput = {
    create?: XOR<deviceCreateWithoutUserInput, deviceUncheckedCreateWithoutUserInput> | deviceCreateWithoutUserInput[] | deviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: deviceCreateOrConnectWithoutUserInput | deviceCreateOrConnectWithoutUserInput[]
    createMany?: deviceCreateManyUserInputEnvelope
    connect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
  }

  export type env_userCreateNestedManyWithoutUserInput = {
    create?: XOR<env_userCreateWithoutUserInput, env_userUncheckedCreateWithoutUserInput> | env_userCreateWithoutUserInput[] | env_userUncheckedCreateWithoutUserInput[]
    connectOrCreate?: env_userCreateOrConnectWithoutUserInput | env_userCreateOrConnectWithoutUserInput[]
    createMany?: env_userCreateManyUserInputEnvelope
    connect?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
  }

  export type helper_userCreateNestedManyWithoutUser_helper_user_helper_idTouserInput = {
    create?: XOR<helper_userCreateWithoutUser_helper_user_helper_idTouserInput, helper_userUncheckedCreateWithoutUser_helper_user_helper_idTouserInput> | helper_userCreateWithoutUser_helper_user_helper_idTouserInput[] | helper_userUncheckedCreateWithoutUser_helper_user_helper_idTouserInput[]
    connectOrCreate?: helper_userCreateOrConnectWithoutUser_helper_user_helper_idTouserInput | helper_userCreateOrConnectWithoutUser_helper_user_helper_idTouserInput[]
    createMany?: helper_userCreateManyUser_helper_user_helper_idTouserInputEnvelope
    connect?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
  }

  export type helper_userCreateNestedManyWithoutUser_helper_user_user_idTouserInput = {
    create?: XOR<helper_userCreateWithoutUser_helper_user_user_idTouserInput, helper_userUncheckedCreateWithoutUser_helper_user_user_idTouserInput> | helper_userCreateWithoutUser_helper_user_user_idTouserInput[] | helper_userUncheckedCreateWithoutUser_helper_user_user_idTouserInput[]
    connectOrCreate?: helper_userCreateOrConnectWithoutUser_helper_user_user_idTouserInput | helper_userCreateOrConnectWithoutUser_helper_user_user_idTouserInput[]
    createMany?: helper_userCreateManyUser_helper_user_user_idTouserInputEnvelope
    connect?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
  }

  export type intervention_historyCreateNestedManyWithoutUserInput = {
    create?: XOR<intervention_historyCreateWithoutUserInput, intervention_historyUncheckedCreateWithoutUserInput> | intervention_historyCreateWithoutUserInput[] | intervention_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: intervention_historyCreateOrConnectWithoutUserInput | intervention_historyCreateOrConnectWithoutUserInput[]
    createMany?: intervention_historyCreateManyUserInputEnvelope
    connect?: intervention_historyWhereUniqueInput | intervention_historyWhereUniqueInput[]
  }

  export type localisationCreateNestedOneWithoutUserInput = {
    create?: XOR<localisationCreateWithoutUserInput, localisationUncheckedCreateWithoutUserInput>
    connectOrCreate?: localisationCreateOrConnectWithoutUserInput
    connect?: localisationWhereUniqueInput
  }

  export type purchase_historyCreateNestedManyWithoutUserInput = {
    create?: XOR<purchase_historyCreateWithoutUserInput, purchase_historyUncheckedCreateWithoutUserInput> | purchase_historyCreateWithoutUserInput[] | purchase_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: purchase_historyCreateOrConnectWithoutUserInput | purchase_historyCreateOrConnectWithoutUserInput[]
    createMany?: purchase_historyCreateManyUserInputEnvelope
    connect?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
  }

  export type user_typeCreateNestedOneWithoutUserInput = {
    create?: XOR<user_typeCreateWithoutUserInput, user_typeUncheckedCreateWithoutUserInput>
    connectOrCreate?: user_typeCreateOrConnectWithoutUserInput
    connect?: user_typeWhereUniqueInput
  }

  export type deviceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<deviceCreateWithoutUserInput, deviceUncheckedCreateWithoutUserInput> | deviceCreateWithoutUserInput[] | deviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: deviceCreateOrConnectWithoutUserInput | deviceCreateOrConnectWithoutUserInput[]
    createMany?: deviceCreateManyUserInputEnvelope
    connect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
  }

  export type env_userUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<env_userCreateWithoutUserInput, env_userUncheckedCreateWithoutUserInput> | env_userCreateWithoutUserInput[] | env_userUncheckedCreateWithoutUserInput[]
    connectOrCreate?: env_userCreateOrConnectWithoutUserInput | env_userCreateOrConnectWithoutUserInput[]
    createMany?: env_userCreateManyUserInputEnvelope
    connect?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
  }

  export type helper_userUncheckedCreateNestedManyWithoutUser_helper_user_helper_idTouserInput = {
    create?: XOR<helper_userCreateWithoutUser_helper_user_helper_idTouserInput, helper_userUncheckedCreateWithoutUser_helper_user_helper_idTouserInput> | helper_userCreateWithoutUser_helper_user_helper_idTouserInput[] | helper_userUncheckedCreateWithoutUser_helper_user_helper_idTouserInput[]
    connectOrCreate?: helper_userCreateOrConnectWithoutUser_helper_user_helper_idTouserInput | helper_userCreateOrConnectWithoutUser_helper_user_helper_idTouserInput[]
    createMany?: helper_userCreateManyUser_helper_user_helper_idTouserInputEnvelope
    connect?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
  }

  export type helper_userUncheckedCreateNestedManyWithoutUser_helper_user_user_idTouserInput = {
    create?: XOR<helper_userCreateWithoutUser_helper_user_user_idTouserInput, helper_userUncheckedCreateWithoutUser_helper_user_user_idTouserInput> | helper_userCreateWithoutUser_helper_user_user_idTouserInput[] | helper_userUncheckedCreateWithoutUser_helper_user_user_idTouserInput[]
    connectOrCreate?: helper_userCreateOrConnectWithoutUser_helper_user_user_idTouserInput | helper_userCreateOrConnectWithoutUser_helper_user_user_idTouserInput[]
    createMany?: helper_userCreateManyUser_helper_user_user_idTouserInputEnvelope
    connect?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
  }

  export type intervention_historyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<intervention_historyCreateWithoutUserInput, intervention_historyUncheckedCreateWithoutUserInput> | intervention_historyCreateWithoutUserInput[] | intervention_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: intervention_historyCreateOrConnectWithoutUserInput | intervention_historyCreateOrConnectWithoutUserInput[]
    createMany?: intervention_historyCreateManyUserInputEnvelope
    connect?: intervention_historyWhereUniqueInput | intervention_historyWhereUniqueInput[]
  }

  export type localisationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<localisationCreateWithoutUserInput, localisationUncheckedCreateWithoutUserInput>
    connectOrCreate?: localisationCreateOrConnectWithoutUserInput
    connect?: localisationWhereUniqueInput
  }

  export type purchase_historyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<purchase_historyCreateWithoutUserInput, purchase_historyUncheckedCreateWithoutUserInput> | purchase_historyCreateWithoutUserInput[] | purchase_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: purchase_historyCreateOrConnectWithoutUserInput | purchase_historyCreateOrConnectWithoutUserInput[]
    createMany?: purchase_historyCreateManyUserInputEnvelope
    connect?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
  }

  export type deviceUpdateManyWithoutUserNestedInput = {
    create?: XOR<deviceCreateWithoutUserInput, deviceUncheckedCreateWithoutUserInput> | deviceCreateWithoutUserInput[] | deviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: deviceCreateOrConnectWithoutUserInput | deviceCreateOrConnectWithoutUserInput[]
    upsert?: deviceUpsertWithWhereUniqueWithoutUserInput | deviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: deviceCreateManyUserInputEnvelope
    set?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    disconnect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    delete?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    connect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    update?: deviceUpdateWithWhereUniqueWithoutUserInput | deviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: deviceUpdateManyWithWhereWithoutUserInput | deviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: deviceScalarWhereInput | deviceScalarWhereInput[]
  }

  export type env_userUpdateManyWithoutUserNestedInput = {
    create?: XOR<env_userCreateWithoutUserInput, env_userUncheckedCreateWithoutUserInput> | env_userCreateWithoutUserInput[] | env_userUncheckedCreateWithoutUserInput[]
    connectOrCreate?: env_userCreateOrConnectWithoutUserInput | env_userCreateOrConnectWithoutUserInput[]
    upsert?: env_userUpsertWithWhereUniqueWithoutUserInput | env_userUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: env_userCreateManyUserInputEnvelope
    set?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
    disconnect?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
    delete?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
    connect?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
    update?: env_userUpdateWithWhereUniqueWithoutUserInput | env_userUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: env_userUpdateManyWithWhereWithoutUserInput | env_userUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: env_userScalarWhereInput | env_userScalarWhereInput[]
  }

  export type helper_userUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput = {
    create?: XOR<helper_userCreateWithoutUser_helper_user_helper_idTouserInput, helper_userUncheckedCreateWithoutUser_helper_user_helper_idTouserInput> | helper_userCreateWithoutUser_helper_user_helper_idTouserInput[] | helper_userUncheckedCreateWithoutUser_helper_user_helper_idTouserInput[]
    connectOrCreate?: helper_userCreateOrConnectWithoutUser_helper_user_helper_idTouserInput | helper_userCreateOrConnectWithoutUser_helper_user_helper_idTouserInput[]
    upsert?: helper_userUpsertWithWhereUniqueWithoutUser_helper_user_helper_idTouserInput | helper_userUpsertWithWhereUniqueWithoutUser_helper_user_helper_idTouserInput[]
    createMany?: helper_userCreateManyUser_helper_user_helper_idTouserInputEnvelope
    set?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
    disconnect?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
    delete?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
    connect?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
    update?: helper_userUpdateWithWhereUniqueWithoutUser_helper_user_helper_idTouserInput | helper_userUpdateWithWhereUniqueWithoutUser_helper_user_helper_idTouserInput[]
    updateMany?: helper_userUpdateManyWithWhereWithoutUser_helper_user_helper_idTouserInput | helper_userUpdateManyWithWhereWithoutUser_helper_user_helper_idTouserInput[]
    deleteMany?: helper_userScalarWhereInput | helper_userScalarWhereInput[]
  }

  export type helper_userUpdateManyWithoutUser_helper_user_user_idTouserNestedInput = {
    create?: XOR<helper_userCreateWithoutUser_helper_user_user_idTouserInput, helper_userUncheckedCreateWithoutUser_helper_user_user_idTouserInput> | helper_userCreateWithoutUser_helper_user_user_idTouserInput[] | helper_userUncheckedCreateWithoutUser_helper_user_user_idTouserInput[]
    connectOrCreate?: helper_userCreateOrConnectWithoutUser_helper_user_user_idTouserInput | helper_userCreateOrConnectWithoutUser_helper_user_user_idTouserInput[]
    upsert?: helper_userUpsertWithWhereUniqueWithoutUser_helper_user_user_idTouserInput | helper_userUpsertWithWhereUniqueWithoutUser_helper_user_user_idTouserInput[]
    createMany?: helper_userCreateManyUser_helper_user_user_idTouserInputEnvelope
    set?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
    disconnect?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
    delete?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
    connect?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
    update?: helper_userUpdateWithWhereUniqueWithoutUser_helper_user_user_idTouserInput | helper_userUpdateWithWhereUniqueWithoutUser_helper_user_user_idTouserInput[]
    updateMany?: helper_userUpdateManyWithWhereWithoutUser_helper_user_user_idTouserInput | helper_userUpdateManyWithWhereWithoutUser_helper_user_user_idTouserInput[]
    deleteMany?: helper_userScalarWhereInput | helper_userScalarWhereInput[]
  }

  export type intervention_historyUpdateManyWithoutUserNestedInput = {
    create?: XOR<intervention_historyCreateWithoutUserInput, intervention_historyUncheckedCreateWithoutUserInput> | intervention_historyCreateWithoutUserInput[] | intervention_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: intervention_historyCreateOrConnectWithoutUserInput | intervention_historyCreateOrConnectWithoutUserInput[]
    upsert?: intervention_historyUpsertWithWhereUniqueWithoutUserInput | intervention_historyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: intervention_historyCreateManyUserInputEnvelope
    set?: intervention_historyWhereUniqueInput | intervention_historyWhereUniqueInput[]
    disconnect?: intervention_historyWhereUniqueInput | intervention_historyWhereUniqueInput[]
    delete?: intervention_historyWhereUniqueInput | intervention_historyWhereUniqueInput[]
    connect?: intervention_historyWhereUniqueInput | intervention_historyWhereUniqueInput[]
    update?: intervention_historyUpdateWithWhereUniqueWithoutUserInput | intervention_historyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: intervention_historyUpdateManyWithWhereWithoutUserInput | intervention_historyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: intervention_historyScalarWhereInput | intervention_historyScalarWhereInput[]
  }

  export type localisationUpdateOneWithoutUserNestedInput = {
    create?: XOR<localisationCreateWithoutUserInput, localisationUncheckedCreateWithoutUserInput>
    connectOrCreate?: localisationCreateOrConnectWithoutUserInput
    upsert?: localisationUpsertWithoutUserInput
    disconnect?: localisationWhereInput | boolean
    delete?: localisationWhereInput | boolean
    connect?: localisationWhereUniqueInput
    update?: XOR<XOR<localisationUpdateToOneWithWhereWithoutUserInput, localisationUpdateWithoutUserInput>, localisationUncheckedUpdateWithoutUserInput>
  }

  export type purchase_historyUpdateManyWithoutUserNestedInput = {
    create?: XOR<purchase_historyCreateWithoutUserInput, purchase_historyUncheckedCreateWithoutUserInput> | purchase_historyCreateWithoutUserInput[] | purchase_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: purchase_historyCreateOrConnectWithoutUserInput | purchase_historyCreateOrConnectWithoutUserInput[]
    upsert?: purchase_historyUpsertWithWhereUniqueWithoutUserInput | purchase_historyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: purchase_historyCreateManyUserInputEnvelope
    set?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
    disconnect?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
    delete?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
    connect?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
    update?: purchase_historyUpdateWithWhereUniqueWithoutUserInput | purchase_historyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: purchase_historyUpdateManyWithWhereWithoutUserInput | purchase_historyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: purchase_historyScalarWhereInput | purchase_historyScalarWhereInput[]
  }

  export type user_typeUpdateOneWithoutUserNestedInput = {
    create?: XOR<user_typeCreateWithoutUserInput, user_typeUncheckedCreateWithoutUserInput>
    connectOrCreate?: user_typeCreateOrConnectWithoutUserInput
    upsert?: user_typeUpsertWithoutUserInput
    disconnect?: user_typeWhereInput | boolean
    delete?: user_typeWhereInput | boolean
    connect?: user_typeWhereUniqueInput
    update?: XOR<XOR<user_typeUpdateToOneWithWhereWithoutUserInput, user_typeUpdateWithoutUserInput>, user_typeUncheckedUpdateWithoutUserInput>
  }

  export type deviceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<deviceCreateWithoutUserInput, deviceUncheckedCreateWithoutUserInput> | deviceCreateWithoutUserInput[] | deviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: deviceCreateOrConnectWithoutUserInput | deviceCreateOrConnectWithoutUserInput[]
    upsert?: deviceUpsertWithWhereUniqueWithoutUserInput | deviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: deviceCreateManyUserInputEnvelope
    set?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    disconnect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    delete?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    connect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    update?: deviceUpdateWithWhereUniqueWithoutUserInput | deviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: deviceUpdateManyWithWhereWithoutUserInput | deviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: deviceScalarWhereInput | deviceScalarWhereInput[]
  }

  export type env_userUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<env_userCreateWithoutUserInput, env_userUncheckedCreateWithoutUserInput> | env_userCreateWithoutUserInput[] | env_userUncheckedCreateWithoutUserInput[]
    connectOrCreate?: env_userCreateOrConnectWithoutUserInput | env_userCreateOrConnectWithoutUserInput[]
    upsert?: env_userUpsertWithWhereUniqueWithoutUserInput | env_userUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: env_userCreateManyUserInputEnvelope
    set?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
    disconnect?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
    delete?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
    connect?: env_userWhereUniqueInput | env_userWhereUniqueInput[]
    update?: env_userUpdateWithWhereUniqueWithoutUserInput | env_userUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: env_userUpdateManyWithWhereWithoutUserInput | env_userUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: env_userScalarWhereInput | env_userScalarWhereInput[]
  }

  export type helper_userUncheckedUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput = {
    create?: XOR<helper_userCreateWithoutUser_helper_user_helper_idTouserInput, helper_userUncheckedCreateWithoutUser_helper_user_helper_idTouserInput> | helper_userCreateWithoutUser_helper_user_helper_idTouserInput[] | helper_userUncheckedCreateWithoutUser_helper_user_helper_idTouserInput[]
    connectOrCreate?: helper_userCreateOrConnectWithoutUser_helper_user_helper_idTouserInput | helper_userCreateOrConnectWithoutUser_helper_user_helper_idTouserInput[]
    upsert?: helper_userUpsertWithWhereUniqueWithoutUser_helper_user_helper_idTouserInput | helper_userUpsertWithWhereUniqueWithoutUser_helper_user_helper_idTouserInput[]
    createMany?: helper_userCreateManyUser_helper_user_helper_idTouserInputEnvelope
    set?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
    disconnect?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
    delete?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
    connect?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
    update?: helper_userUpdateWithWhereUniqueWithoutUser_helper_user_helper_idTouserInput | helper_userUpdateWithWhereUniqueWithoutUser_helper_user_helper_idTouserInput[]
    updateMany?: helper_userUpdateManyWithWhereWithoutUser_helper_user_helper_idTouserInput | helper_userUpdateManyWithWhereWithoutUser_helper_user_helper_idTouserInput[]
    deleteMany?: helper_userScalarWhereInput | helper_userScalarWhereInput[]
  }

  export type helper_userUncheckedUpdateManyWithoutUser_helper_user_user_idTouserNestedInput = {
    create?: XOR<helper_userCreateWithoutUser_helper_user_user_idTouserInput, helper_userUncheckedCreateWithoutUser_helper_user_user_idTouserInput> | helper_userCreateWithoutUser_helper_user_user_idTouserInput[] | helper_userUncheckedCreateWithoutUser_helper_user_user_idTouserInput[]
    connectOrCreate?: helper_userCreateOrConnectWithoutUser_helper_user_user_idTouserInput | helper_userCreateOrConnectWithoutUser_helper_user_user_idTouserInput[]
    upsert?: helper_userUpsertWithWhereUniqueWithoutUser_helper_user_user_idTouserInput | helper_userUpsertWithWhereUniqueWithoutUser_helper_user_user_idTouserInput[]
    createMany?: helper_userCreateManyUser_helper_user_user_idTouserInputEnvelope
    set?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
    disconnect?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
    delete?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
    connect?: helper_userWhereUniqueInput | helper_userWhereUniqueInput[]
    update?: helper_userUpdateWithWhereUniqueWithoutUser_helper_user_user_idTouserInput | helper_userUpdateWithWhereUniqueWithoutUser_helper_user_user_idTouserInput[]
    updateMany?: helper_userUpdateManyWithWhereWithoutUser_helper_user_user_idTouserInput | helper_userUpdateManyWithWhereWithoutUser_helper_user_user_idTouserInput[]
    deleteMany?: helper_userScalarWhereInput | helper_userScalarWhereInput[]
  }

  export type intervention_historyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<intervention_historyCreateWithoutUserInput, intervention_historyUncheckedCreateWithoutUserInput> | intervention_historyCreateWithoutUserInput[] | intervention_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: intervention_historyCreateOrConnectWithoutUserInput | intervention_historyCreateOrConnectWithoutUserInput[]
    upsert?: intervention_historyUpsertWithWhereUniqueWithoutUserInput | intervention_historyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: intervention_historyCreateManyUserInputEnvelope
    set?: intervention_historyWhereUniqueInput | intervention_historyWhereUniqueInput[]
    disconnect?: intervention_historyWhereUniqueInput | intervention_historyWhereUniqueInput[]
    delete?: intervention_historyWhereUniqueInput | intervention_historyWhereUniqueInput[]
    connect?: intervention_historyWhereUniqueInput | intervention_historyWhereUniqueInput[]
    update?: intervention_historyUpdateWithWhereUniqueWithoutUserInput | intervention_historyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: intervention_historyUpdateManyWithWhereWithoutUserInput | intervention_historyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: intervention_historyScalarWhereInput | intervention_historyScalarWhereInput[]
  }

  export type localisationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<localisationCreateWithoutUserInput, localisationUncheckedCreateWithoutUserInput>
    connectOrCreate?: localisationCreateOrConnectWithoutUserInput
    upsert?: localisationUpsertWithoutUserInput
    disconnect?: localisationWhereInput | boolean
    delete?: localisationWhereInput | boolean
    connect?: localisationWhereUniqueInput
    update?: XOR<XOR<localisationUpdateToOneWithWhereWithoutUserInput, localisationUpdateWithoutUserInput>, localisationUncheckedUpdateWithoutUserInput>
  }

  export type purchase_historyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<purchase_historyCreateWithoutUserInput, purchase_historyUncheckedCreateWithoutUserInput> | purchase_historyCreateWithoutUserInput[] | purchase_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: purchase_historyCreateOrConnectWithoutUserInput | purchase_historyCreateOrConnectWithoutUserInput[]
    upsert?: purchase_historyUpsertWithWhereUniqueWithoutUserInput | purchase_historyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: purchase_historyCreateManyUserInputEnvelope
    set?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
    disconnect?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
    delete?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
    connect?: purchase_historyWhereUniqueInput | purchase_historyWhereUniqueInput[]
    update?: purchase_historyUpdateWithWhereUniqueWithoutUserInput | purchase_historyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: purchase_historyUpdateManyWithWhereWithoutUserInput | purchase_historyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: purchase_historyScalarWhereInput | purchase_historyScalarWhereInput[]
  }

  export type userCreateNestedManyWithoutUser_typeInput = {
    create?: XOR<userCreateWithoutUser_typeInput, userUncheckedCreateWithoutUser_typeInput> | userCreateWithoutUser_typeInput[] | userUncheckedCreateWithoutUser_typeInput[]
    connectOrCreate?: userCreateOrConnectWithoutUser_typeInput | userCreateOrConnectWithoutUser_typeInput[]
    createMany?: userCreateManyUser_typeInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutUser_typeInput = {
    create?: XOR<userCreateWithoutUser_typeInput, userUncheckedCreateWithoutUser_typeInput> | userCreateWithoutUser_typeInput[] | userUncheckedCreateWithoutUser_typeInput[]
    connectOrCreate?: userCreateOrConnectWithoutUser_typeInput | userCreateOrConnectWithoutUser_typeInput[]
    createMany?: userCreateManyUser_typeInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userUpdateManyWithoutUser_typeNestedInput = {
    create?: XOR<userCreateWithoutUser_typeInput, userUncheckedCreateWithoutUser_typeInput> | userCreateWithoutUser_typeInput[] | userUncheckedCreateWithoutUser_typeInput[]
    connectOrCreate?: userCreateOrConnectWithoutUser_typeInput | userCreateOrConnectWithoutUser_typeInput[]
    upsert?: userUpsertWithWhereUniqueWithoutUser_typeInput | userUpsertWithWhereUniqueWithoutUser_typeInput[]
    createMany?: userCreateManyUser_typeInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutUser_typeInput | userUpdateWithWhereUniqueWithoutUser_typeInput[]
    updateMany?: userUpdateManyWithWhereWithoutUser_typeInput | userUpdateManyWithWhereWithoutUser_typeInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutUser_typeNestedInput = {
    create?: XOR<userCreateWithoutUser_typeInput, userUncheckedCreateWithoutUser_typeInput> | userCreateWithoutUser_typeInput[] | userUncheckedCreateWithoutUser_typeInput[]
    connectOrCreate?: userCreateOrConnectWithoutUser_typeInput | userCreateOrConnectWithoutUser_typeInput[]
    upsert?: userUpsertWithWhereUniqueWithoutUser_typeInput | userUpsertWithWhereUniqueWithoutUser_typeInput[]
    createMany?: userCreateManyUser_typeInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutUser_typeInput | userUpdateWithWhereUniqueWithoutUser_typeInput[]
    updateMany?: userUpdateManyWithWhereWithoutUser_typeInput | userUpdateManyWithWhereWithoutUser_typeInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type poi_zoneCreateNestedManyWithoutZoneInput = {
    create?: XOR<poi_zoneCreateWithoutZoneInput, poi_zoneUncheckedCreateWithoutZoneInput> | poi_zoneCreateWithoutZoneInput[] | poi_zoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: poi_zoneCreateOrConnectWithoutZoneInput | poi_zoneCreateOrConnectWithoutZoneInput[]
    createMany?: poi_zoneCreateManyZoneInputEnvelope
    connect?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
  }

  export type environmentCreateNestedOneWithoutZoneInput = {
    create?: XOR<environmentCreateWithoutZoneInput, environmentUncheckedCreateWithoutZoneInput>
    connectOrCreate?: environmentCreateOrConnectWithoutZoneInput
    connect?: environmentWhereUniqueInput
  }

  export type mapCreateNestedOneWithoutZoneInput = {
    create?: XOR<mapCreateWithoutZoneInput, mapUncheckedCreateWithoutZoneInput>
    connectOrCreate?: mapCreateOrConnectWithoutZoneInput
    connect?: mapWhereUniqueInput
  }

  export type zone_typeCreateNestedOneWithoutZone_zone_type_idTozone_typeInput = {
    create?: XOR<zone_typeCreateWithoutZone_zone_type_idTozone_typeInput, zone_typeUncheckedCreateWithoutZone_zone_type_idTozone_typeInput>
    connectOrCreate?: zone_typeCreateOrConnectWithoutZone_zone_type_idTozone_typeInput
    connect?: zone_typeWhereUniqueInput
  }

  export type zone_typeCreateNestedOneWithoutZone_zone_zone_typeTozone_typeInput = {
    create?: XOR<zone_typeCreateWithoutZone_zone_zone_typeTozone_typeInput, zone_typeUncheckedCreateWithoutZone_zone_zone_typeTozone_typeInput>
    connectOrCreate?: zone_typeCreateOrConnectWithoutZone_zone_zone_typeTozone_typeInput
    connect?: zone_typeWhereUniqueInput
  }

  export type poi_zoneUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<poi_zoneCreateWithoutZoneInput, poi_zoneUncheckedCreateWithoutZoneInput> | poi_zoneCreateWithoutZoneInput[] | poi_zoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: poi_zoneCreateOrConnectWithoutZoneInput | poi_zoneCreateOrConnectWithoutZoneInput[]
    createMany?: poi_zoneCreateManyZoneInputEnvelope
    connect?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
  }

  export type poi_zoneUpdateManyWithoutZoneNestedInput = {
    create?: XOR<poi_zoneCreateWithoutZoneInput, poi_zoneUncheckedCreateWithoutZoneInput> | poi_zoneCreateWithoutZoneInput[] | poi_zoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: poi_zoneCreateOrConnectWithoutZoneInput | poi_zoneCreateOrConnectWithoutZoneInput[]
    upsert?: poi_zoneUpsertWithWhereUniqueWithoutZoneInput | poi_zoneUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: poi_zoneCreateManyZoneInputEnvelope
    set?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
    disconnect?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
    delete?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
    connect?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
    update?: poi_zoneUpdateWithWhereUniqueWithoutZoneInput | poi_zoneUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: poi_zoneUpdateManyWithWhereWithoutZoneInput | poi_zoneUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: poi_zoneScalarWhereInput | poi_zoneScalarWhereInput[]
  }

  export type environmentUpdateOneWithoutZoneNestedInput = {
    create?: XOR<environmentCreateWithoutZoneInput, environmentUncheckedCreateWithoutZoneInput>
    connectOrCreate?: environmentCreateOrConnectWithoutZoneInput
    upsert?: environmentUpsertWithoutZoneInput
    disconnect?: environmentWhereInput | boolean
    delete?: environmentWhereInput | boolean
    connect?: environmentWhereUniqueInput
    update?: XOR<XOR<environmentUpdateToOneWithWhereWithoutZoneInput, environmentUpdateWithoutZoneInput>, environmentUncheckedUpdateWithoutZoneInput>
  }

  export type mapUpdateOneWithoutZoneNestedInput = {
    create?: XOR<mapCreateWithoutZoneInput, mapUncheckedCreateWithoutZoneInput>
    connectOrCreate?: mapCreateOrConnectWithoutZoneInput
    upsert?: mapUpsertWithoutZoneInput
    disconnect?: mapWhereInput | boolean
    delete?: mapWhereInput | boolean
    connect?: mapWhereUniqueInput
    update?: XOR<XOR<mapUpdateToOneWithWhereWithoutZoneInput, mapUpdateWithoutZoneInput>, mapUncheckedUpdateWithoutZoneInput>
  }

  export type zone_typeUpdateOneWithoutZone_zone_type_idTozone_typeNestedInput = {
    create?: XOR<zone_typeCreateWithoutZone_zone_type_idTozone_typeInput, zone_typeUncheckedCreateWithoutZone_zone_type_idTozone_typeInput>
    connectOrCreate?: zone_typeCreateOrConnectWithoutZone_zone_type_idTozone_typeInput
    upsert?: zone_typeUpsertWithoutZone_zone_type_idTozone_typeInput
    disconnect?: zone_typeWhereInput | boolean
    delete?: zone_typeWhereInput | boolean
    connect?: zone_typeWhereUniqueInput
    update?: XOR<XOR<zone_typeUpdateToOneWithWhereWithoutZone_zone_type_idTozone_typeInput, zone_typeUpdateWithoutZone_zone_type_idTozone_typeInput>, zone_typeUncheckedUpdateWithoutZone_zone_type_idTozone_typeInput>
  }

  export type zone_typeUpdateOneWithoutZone_zone_zone_typeTozone_typeNestedInput = {
    create?: XOR<zone_typeCreateWithoutZone_zone_zone_typeTozone_typeInput, zone_typeUncheckedCreateWithoutZone_zone_zone_typeTozone_typeInput>
    connectOrCreate?: zone_typeCreateOrConnectWithoutZone_zone_zone_typeTozone_typeInput
    upsert?: zone_typeUpsertWithoutZone_zone_zone_typeTozone_typeInput
    disconnect?: zone_typeWhereInput | boolean
    delete?: zone_typeWhereInput | boolean
    connect?: zone_typeWhereUniqueInput
    update?: XOR<XOR<zone_typeUpdateToOneWithWhereWithoutZone_zone_zone_typeTozone_typeInput, zone_typeUpdateWithoutZone_zone_zone_typeTozone_typeInput>, zone_typeUncheckedUpdateWithoutZone_zone_zone_typeTozone_typeInput>
  }

  export type poi_zoneUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<poi_zoneCreateWithoutZoneInput, poi_zoneUncheckedCreateWithoutZoneInput> | poi_zoneCreateWithoutZoneInput[] | poi_zoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: poi_zoneCreateOrConnectWithoutZoneInput | poi_zoneCreateOrConnectWithoutZoneInput[]
    upsert?: poi_zoneUpsertWithWhereUniqueWithoutZoneInput | poi_zoneUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: poi_zoneCreateManyZoneInputEnvelope
    set?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
    disconnect?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
    delete?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
    connect?: poi_zoneWhereUniqueInput | poi_zoneWhereUniqueInput[]
    update?: poi_zoneUpdateWithWhereUniqueWithoutZoneInput | poi_zoneUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: poi_zoneUpdateManyWithWhereWithoutZoneInput | poi_zoneUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: poi_zoneScalarWhereInput | poi_zoneScalarWhereInput[]
  }

  export type zoneCreateNestedManyWithoutZone_type_zone_type_idTozone_typeInput = {
    create?: XOR<zoneCreateWithoutZone_type_zone_type_idTozone_typeInput, zoneUncheckedCreateWithoutZone_type_zone_type_idTozone_typeInput> | zoneCreateWithoutZone_type_zone_type_idTozone_typeInput[] | zoneUncheckedCreateWithoutZone_type_zone_type_idTozone_typeInput[]
    connectOrCreate?: zoneCreateOrConnectWithoutZone_type_zone_type_idTozone_typeInput | zoneCreateOrConnectWithoutZone_type_zone_type_idTozone_typeInput[]
    createMany?: zoneCreateManyZone_type_zone_type_idTozone_typeInputEnvelope
    connect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
  }

  export type zoneCreateNestedManyWithoutZone_type_zone_zone_typeTozone_typeInput = {
    create?: XOR<zoneCreateWithoutZone_type_zone_zone_typeTozone_typeInput, zoneUncheckedCreateWithoutZone_type_zone_zone_typeTozone_typeInput> | zoneCreateWithoutZone_type_zone_zone_typeTozone_typeInput[] | zoneUncheckedCreateWithoutZone_type_zone_zone_typeTozone_typeInput[]
    connectOrCreate?: zoneCreateOrConnectWithoutZone_type_zone_zone_typeTozone_typeInput | zoneCreateOrConnectWithoutZone_type_zone_zone_typeTozone_typeInput[]
    createMany?: zoneCreateManyZone_type_zone_zone_typeTozone_typeInputEnvelope
    connect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
  }

  export type zoneUncheckedCreateNestedManyWithoutZone_type_zone_type_idTozone_typeInput = {
    create?: XOR<zoneCreateWithoutZone_type_zone_type_idTozone_typeInput, zoneUncheckedCreateWithoutZone_type_zone_type_idTozone_typeInput> | zoneCreateWithoutZone_type_zone_type_idTozone_typeInput[] | zoneUncheckedCreateWithoutZone_type_zone_type_idTozone_typeInput[]
    connectOrCreate?: zoneCreateOrConnectWithoutZone_type_zone_type_idTozone_typeInput | zoneCreateOrConnectWithoutZone_type_zone_type_idTozone_typeInput[]
    createMany?: zoneCreateManyZone_type_zone_type_idTozone_typeInputEnvelope
    connect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
  }

  export type zoneUncheckedCreateNestedManyWithoutZone_type_zone_zone_typeTozone_typeInput = {
    create?: XOR<zoneCreateWithoutZone_type_zone_zone_typeTozone_typeInput, zoneUncheckedCreateWithoutZone_type_zone_zone_typeTozone_typeInput> | zoneCreateWithoutZone_type_zone_zone_typeTozone_typeInput[] | zoneUncheckedCreateWithoutZone_type_zone_zone_typeTozone_typeInput[]
    connectOrCreate?: zoneCreateOrConnectWithoutZone_type_zone_zone_typeTozone_typeInput | zoneCreateOrConnectWithoutZone_type_zone_zone_typeTozone_typeInput[]
    createMany?: zoneCreateManyZone_type_zone_zone_typeTozone_typeInputEnvelope
    connect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
  }

  export type zoneUpdateManyWithoutZone_type_zone_type_idTozone_typeNestedInput = {
    create?: XOR<zoneCreateWithoutZone_type_zone_type_idTozone_typeInput, zoneUncheckedCreateWithoutZone_type_zone_type_idTozone_typeInput> | zoneCreateWithoutZone_type_zone_type_idTozone_typeInput[] | zoneUncheckedCreateWithoutZone_type_zone_type_idTozone_typeInput[]
    connectOrCreate?: zoneCreateOrConnectWithoutZone_type_zone_type_idTozone_typeInput | zoneCreateOrConnectWithoutZone_type_zone_type_idTozone_typeInput[]
    upsert?: zoneUpsertWithWhereUniqueWithoutZone_type_zone_type_idTozone_typeInput | zoneUpsertWithWhereUniqueWithoutZone_type_zone_type_idTozone_typeInput[]
    createMany?: zoneCreateManyZone_type_zone_type_idTozone_typeInputEnvelope
    set?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    disconnect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    delete?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    connect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    update?: zoneUpdateWithWhereUniqueWithoutZone_type_zone_type_idTozone_typeInput | zoneUpdateWithWhereUniqueWithoutZone_type_zone_type_idTozone_typeInput[]
    updateMany?: zoneUpdateManyWithWhereWithoutZone_type_zone_type_idTozone_typeInput | zoneUpdateManyWithWhereWithoutZone_type_zone_type_idTozone_typeInput[]
    deleteMany?: zoneScalarWhereInput | zoneScalarWhereInput[]
  }

  export type zoneUpdateManyWithoutZone_type_zone_zone_typeTozone_typeNestedInput = {
    create?: XOR<zoneCreateWithoutZone_type_zone_zone_typeTozone_typeInput, zoneUncheckedCreateWithoutZone_type_zone_zone_typeTozone_typeInput> | zoneCreateWithoutZone_type_zone_zone_typeTozone_typeInput[] | zoneUncheckedCreateWithoutZone_type_zone_zone_typeTozone_typeInput[]
    connectOrCreate?: zoneCreateOrConnectWithoutZone_type_zone_zone_typeTozone_typeInput | zoneCreateOrConnectWithoutZone_type_zone_zone_typeTozone_typeInput[]
    upsert?: zoneUpsertWithWhereUniqueWithoutZone_type_zone_zone_typeTozone_typeInput | zoneUpsertWithWhereUniqueWithoutZone_type_zone_zone_typeTozone_typeInput[]
    createMany?: zoneCreateManyZone_type_zone_zone_typeTozone_typeInputEnvelope
    set?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    disconnect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    delete?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    connect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    update?: zoneUpdateWithWhereUniqueWithoutZone_type_zone_zone_typeTozone_typeInput | zoneUpdateWithWhereUniqueWithoutZone_type_zone_zone_typeTozone_typeInput[]
    updateMany?: zoneUpdateManyWithWhereWithoutZone_type_zone_zone_typeTozone_typeInput | zoneUpdateManyWithWhereWithoutZone_type_zone_zone_typeTozone_typeInput[]
    deleteMany?: zoneScalarWhereInput | zoneScalarWhereInput[]
  }

  export type zoneUncheckedUpdateManyWithoutZone_type_zone_type_idTozone_typeNestedInput = {
    create?: XOR<zoneCreateWithoutZone_type_zone_type_idTozone_typeInput, zoneUncheckedCreateWithoutZone_type_zone_type_idTozone_typeInput> | zoneCreateWithoutZone_type_zone_type_idTozone_typeInput[] | zoneUncheckedCreateWithoutZone_type_zone_type_idTozone_typeInput[]
    connectOrCreate?: zoneCreateOrConnectWithoutZone_type_zone_type_idTozone_typeInput | zoneCreateOrConnectWithoutZone_type_zone_type_idTozone_typeInput[]
    upsert?: zoneUpsertWithWhereUniqueWithoutZone_type_zone_type_idTozone_typeInput | zoneUpsertWithWhereUniqueWithoutZone_type_zone_type_idTozone_typeInput[]
    createMany?: zoneCreateManyZone_type_zone_type_idTozone_typeInputEnvelope
    set?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    disconnect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    delete?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    connect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    update?: zoneUpdateWithWhereUniqueWithoutZone_type_zone_type_idTozone_typeInput | zoneUpdateWithWhereUniqueWithoutZone_type_zone_type_idTozone_typeInput[]
    updateMany?: zoneUpdateManyWithWhereWithoutZone_type_zone_type_idTozone_typeInput | zoneUpdateManyWithWhereWithoutZone_type_zone_type_idTozone_typeInput[]
    deleteMany?: zoneScalarWhereInput | zoneScalarWhereInput[]
  }

  export type zoneUncheckedUpdateManyWithoutZone_type_zone_zone_typeTozone_typeNestedInput = {
    create?: XOR<zoneCreateWithoutZone_type_zone_zone_typeTozone_typeInput, zoneUncheckedCreateWithoutZone_type_zone_zone_typeTozone_typeInput> | zoneCreateWithoutZone_type_zone_zone_typeTozone_typeInput[] | zoneUncheckedCreateWithoutZone_type_zone_zone_typeTozone_typeInput[]
    connectOrCreate?: zoneCreateOrConnectWithoutZone_type_zone_zone_typeTozone_typeInput | zoneCreateOrConnectWithoutZone_type_zone_zone_typeTozone_typeInput[]
    upsert?: zoneUpsertWithWhereUniqueWithoutZone_type_zone_zone_typeTozone_typeInput | zoneUpsertWithWhereUniqueWithoutZone_type_zone_zone_typeTozone_typeInput[]
    createMany?: zoneCreateManyZone_type_zone_zone_typeTozone_typeInputEnvelope
    set?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    disconnect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    delete?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    connect?: zoneWhereUniqueInput | zoneWhereUniqueInput[]
    update?: zoneUpdateWithWhereUniqueWithoutZone_type_zone_zone_typeTozone_typeInput | zoneUpdateWithWhereUniqueWithoutZone_type_zone_zone_typeTozone_typeInput[]
    updateMany?: zoneUpdateManyWithWhereWithoutZone_type_zone_zone_typeTozone_typeInput | zoneUpdateManyWithWhereWithoutZone_type_zone_zone_typeTozone_typeInput[]
    deleteMany?: zoneScalarWhereInput | zoneScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumlevel_newFilter<$PrismaModel = never> = {
    equals?: $Enums.level_new | Enumlevel_newFieldRefInput<$PrismaModel>
    in?: $Enums.level_new[] | ListEnumlevel_newFieldRefInput<$PrismaModel>
    notIn?: $Enums.level_new[] | ListEnumlevel_newFieldRefInput<$PrismaModel>
    not?: NestedEnumlevel_newFilter<$PrismaModel> | $Enums.level_new
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumlevel_newWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.level_new | Enumlevel_newFieldRefInput<$PrismaModel>
    in?: $Enums.level_new[] | ListEnumlevel_newFieldRefInput<$PrismaModel>
    notIn?: $Enums.level_new[] | ListEnumlevel_newFieldRefInput<$PrismaModel>
    not?: NestedEnumlevel_newWithAggregatesFilter<$PrismaModel> | $Enums.level_new
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumlevel_newFilter<$PrismaModel>
    _max?: NestedEnumlevel_newFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumExpenseCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumExpenseCategoryNullableFilter<$PrismaModel> | $Enums.ExpenseCategory | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumExpenseCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumExpenseCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumExpenseCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumExpenseCategoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumintervention_typeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.intervention_type | Enumintervention_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.intervention_type[] | ListEnumintervention_typeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.intervention_type[] | ListEnumintervention_typeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumintervention_typeNullableFilter<$PrismaModel> | $Enums.intervention_type | null
  }

  export type NestedEnumintervention_typeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.intervention_type | Enumintervention_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.intervention_type[] | ListEnumintervention_typeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.intervention_type[] | ListEnumintervention_typeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumintervention_typeNullableWithAggregatesFilter<$PrismaModel> | $Enums.intervention_type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumintervention_typeNullableFilter<$PrismaModel>
    _max?: NestedEnumintervention_typeNullableFilter<$PrismaModel>
  }

  export type deviceCreateWithoutAlertInput = {
    mac_address: string
    software_version: string
    date_of_service: Date | string
    comm_state: boolean
    connection_state?: boolean | null
    battery_capacity?: number
    price?: number | null
    state_type: state_typeCreateNestedOneWithoutDeviceInput
    device_type: device_typeCreateNestedOneWithoutDeviceInput
    user?: userCreateNestedOneWithoutDeviceInput
    purchase_history?: purchase_historyCreateNestedManyWithoutDeviceInput
  }

  export type deviceUncheckedCreateWithoutAlertInput = {
    id?: number
    type_id: number
    state_type_id: number
    user_id?: number | null
    mac_address: string
    software_version: string
    date_of_service: Date | string
    comm_state: boolean
    connection_state?: boolean | null
    battery_capacity?: number
    price?: number | null
    purchase_history?: purchase_historyUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type deviceCreateOrConnectWithoutAlertInput = {
    where: deviceWhereUniqueInput
    create: XOR<deviceCreateWithoutAlertInput, deviceUncheckedCreateWithoutAlertInput>
  }

  export type panne_historyCreateWithoutAlertInput = {

  }

  export type panne_historyUncheckedCreateWithoutAlertInput = {
    id?: number
  }

  export type panne_historyCreateOrConnectWithoutAlertInput = {
    where: panne_historyWhereUniqueInput
    create: XOR<panne_historyCreateWithoutAlertInput, panne_historyUncheckedCreateWithoutAlertInput>
  }

  export type panne_historyCreateManyAlertInputEnvelope = {
    data: panne_historyCreateManyAlertInput | panne_historyCreateManyAlertInput[]
    skipDuplicates?: boolean
  }

  export type deviceUpsertWithoutAlertInput = {
    update: XOR<deviceUpdateWithoutAlertInput, deviceUncheckedUpdateWithoutAlertInput>
    create: XOR<deviceCreateWithoutAlertInput, deviceUncheckedCreateWithoutAlertInput>
    where?: deviceWhereInput
  }

  export type deviceUpdateToOneWithWhereWithoutAlertInput = {
    where?: deviceWhereInput
    data: XOR<deviceUpdateWithoutAlertInput, deviceUncheckedUpdateWithoutAlertInput>
  }

  export type deviceUpdateWithoutAlertInput = {
    mac_address?: StringFieldUpdateOperationsInput | string
    software_version?: StringFieldUpdateOperationsInput | string
    date_of_service?: DateTimeFieldUpdateOperationsInput | Date | string
    comm_state?: BoolFieldUpdateOperationsInput | boolean
    connection_state?: NullableBoolFieldUpdateOperationsInput | boolean | null
    battery_capacity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    state_type?: state_typeUpdateOneRequiredWithoutDeviceNestedInput
    device_type?: device_typeUpdateOneRequiredWithoutDeviceNestedInput
    user?: userUpdateOneWithoutDeviceNestedInput
    purchase_history?: purchase_historyUpdateManyWithoutDeviceNestedInput
  }

  export type deviceUncheckedUpdateWithoutAlertInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    state_type_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    mac_address?: StringFieldUpdateOperationsInput | string
    software_version?: StringFieldUpdateOperationsInput | string
    date_of_service?: DateTimeFieldUpdateOperationsInput | Date | string
    comm_state?: BoolFieldUpdateOperationsInput | boolean
    connection_state?: NullableBoolFieldUpdateOperationsInput | boolean | null
    battery_capacity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    purchase_history?: purchase_historyUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type panne_historyUpsertWithWhereUniqueWithoutAlertInput = {
    where: panne_historyWhereUniqueInput
    update: XOR<panne_historyUpdateWithoutAlertInput, panne_historyUncheckedUpdateWithoutAlertInput>
    create: XOR<panne_historyCreateWithoutAlertInput, panne_historyUncheckedCreateWithoutAlertInput>
  }

  export type panne_historyUpdateWithWhereUniqueWithoutAlertInput = {
    where: panne_historyWhereUniqueInput
    data: XOR<panne_historyUpdateWithoutAlertInput, panne_historyUncheckedUpdateWithoutAlertInput>
  }

  export type panne_historyUpdateManyWithWhereWithoutAlertInput = {
    where: panne_historyScalarWhereInput
    data: XOR<panne_historyUpdateManyMutationInput, panne_historyUncheckedUpdateManyWithoutAlertInput>
  }

  export type panne_historyScalarWhereInput = {
    AND?: panne_historyScalarWhereInput | panne_historyScalarWhereInput[]
    OR?: panne_historyScalarWhereInput[]
    NOT?: panne_historyScalarWhereInput | panne_historyScalarWhereInput[]
    id?: IntFilter<"panne_history"> | number
    alert_id?: IntNullableFilter<"panne_history"> | number | null
  }

  export type alertCreateWithoutDeviceInput = {
    type: string
    time: Date | string
    date: Date | string
    zone: string
    status: string
    level: $Enums.level_new
    panne_history?: panne_historyCreateNestedManyWithoutAlertInput
  }

  export type alertUncheckedCreateWithoutDeviceInput = {
    id?: number
    type: string
    time: Date | string
    date: Date | string
    zone: string
    status: string
    level: $Enums.level_new
    panne_history?: panne_historyUncheckedCreateNestedManyWithoutAlertInput
  }

  export type alertCreateOrConnectWithoutDeviceInput = {
    where: alertWhereUniqueInput
    create: XOR<alertCreateWithoutDeviceInput, alertUncheckedCreateWithoutDeviceInput>
  }

  export type alertCreateManyDeviceInputEnvelope = {
    data: alertCreateManyDeviceInput | alertCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type state_typeCreateWithoutDeviceInput = {
    state: string
  }

  export type state_typeUncheckedCreateWithoutDeviceInput = {
    id?: number
    state: string
  }

  export type state_typeCreateOrConnectWithoutDeviceInput = {
    where: state_typeWhereUniqueInput
    create: XOR<state_typeCreateWithoutDeviceInput, state_typeUncheckedCreateWithoutDeviceInput>
  }

  export type device_typeCreateWithoutDeviceInput = {
    type: string
  }

  export type device_typeUncheckedCreateWithoutDeviceInput = {
    id?: number
    type: string
  }

  export type device_typeCreateOrConnectWithoutDeviceInput = {
    where: device_typeWhereUniqueInput
    create: XOR<device_typeCreateWithoutDeviceInput, device_typeUncheckedCreateWithoutDeviceInput>
  }

  export type userCreateWithoutDeviceInput = {
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    env_user?: env_userCreateNestedManyWithoutUserInput
    helper_user_helper_user_helper_idTouser?: helper_userCreateNestedManyWithoutUser_helper_user_helper_idTouserInput
    helper_user_helper_user_user_idTouser?: helper_userCreateNestedManyWithoutUser_helper_user_user_idTouserInput
    intervention_history?: intervention_historyCreateNestedManyWithoutUserInput
    localisation?: localisationCreateNestedOneWithoutUserInput
    purchase_history?: purchase_historyCreateNestedManyWithoutUserInput
    user_type?: user_typeCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutDeviceInput = {
    id?: number
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    userTypeId?: number | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    env_user?: env_userUncheckedCreateNestedManyWithoutUserInput
    helper_user_helper_user_helper_idTouser?: helper_userUncheckedCreateNestedManyWithoutUser_helper_user_helper_idTouserInput
    helper_user_helper_user_user_idTouser?: helper_userUncheckedCreateNestedManyWithoutUser_helper_user_user_idTouserInput
    intervention_history?: intervention_historyUncheckedCreateNestedManyWithoutUserInput
    localisation?: localisationUncheckedCreateNestedOneWithoutUserInput
    purchase_history?: purchase_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutDeviceInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutDeviceInput, userUncheckedCreateWithoutDeviceInput>
  }

  export type purchase_historyCreateWithoutDeviceInput = {
    date?: Date | string
    public?: boolean | null
    user?: userCreateNestedOneWithoutPurchase_historyInput
  }

  export type purchase_historyUncheckedCreateWithoutDeviceInput = {
    id?: number
    date?: Date | string
    user_id?: number | null
    public?: boolean | null
  }

  export type purchase_historyCreateOrConnectWithoutDeviceInput = {
    where: purchase_historyWhereUniqueInput
    create: XOR<purchase_historyCreateWithoutDeviceInput, purchase_historyUncheckedCreateWithoutDeviceInput>
  }

  export type purchase_historyCreateManyDeviceInputEnvelope = {
    data: purchase_historyCreateManyDeviceInput | purchase_historyCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type alertUpsertWithWhereUniqueWithoutDeviceInput = {
    where: alertWhereUniqueInput
    update: XOR<alertUpdateWithoutDeviceInput, alertUncheckedUpdateWithoutDeviceInput>
    create: XOR<alertCreateWithoutDeviceInput, alertUncheckedCreateWithoutDeviceInput>
  }

  export type alertUpdateWithWhereUniqueWithoutDeviceInput = {
    where: alertWhereUniqueInput
    data: XOR<alertUpdateWithoutDeviceInput, alertUncheckedUpdateWithoutDeviceInput>
  }

  export type alertUpdateManyWithWhereWithoutDeviceInput = {
    where: alertScalarWhereInput
    data: XOR<alertUpdateManyMutationInput, alertUncheckedUpdateManyWithoutDeviceInput>
  }

  export type alertScalarWhereInput = {
    AND?: alertScalarWhereInput | alertScalarWhereInput[]
    OR?: alertScalarWhereInput[]
    NOT?: alertScalarWhereInput | alertScalarWhereInput[]
    id?: IntFilter<"alert"> | number
    type?: StringFilter<"alert"> | string
    time?: DateTimeFilter<"alert"> | Date | string
    date?: DateTimeFilter<"alert"> | Date | string
    zone?: StringFilter<"alert"> | string
    status?: StringFilter<"alert"> | string
    level?: Enumlevel_newFilter<"alert"> | $Enums.level_new
    device_id?: IntNullableFilter<"alert"> | number | null
  }

  export type state_typeUpsertWithoutDeviceInput = {
    update: XOR<state_typeUpdateWithoutDeviceInput, state_typeUncheckedUpdateWithoutDeviceInput>
    create: XOR<state_typeCreateWithoutDeviceInput, state_typeUncheckedCreateWithoutDeviceInput>
    where?: state_typeWhereInput
  }

  export type state_typeUpdateToOneWithWhereWithoutDeviceInput = {
    where?: state_typeWhereInput
    data: XOR<state_typeUpdateWithoutDeviceInput, state_typeUncheckedUpdateWithoutDeviceInput>
  }

  export type state_typeUpdateWithoutDeviceInput = {
    state?: StringFieldUpdateOperationsInput | string
  }

  export type state_typeUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    state?: StringFieldUpdateOperationsInput | string
  }

  export type device_typeUpsertWithoutDeviceInput = {
    update: XOR<device_typeUpdateWithoutDeviceInput, device_typeUncheckedUpdateWithoutDeviceInput>
    create: XOR<device_typeCreateWithoutDeviceInput, device_typeUncheckedCreateWithoutDeviceInput>
    where?: device_typeWhereInput
  }

  export type device_typeUpdateToOneWithWhereWithoutDeviceInput = {
    where?: device_typeWhereInput
    data: XOR<device_typeUpdateWithoutDeviceInput, device_typeUncheckedUpdateWithoutDeviceInput>
  }

  export type device_typeUpdateWithoutDeviceInput = {
    type?: StringFieldUpdateOperationsInput | string
  }

  export type device_typeUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type userUpsertWithoutDeviceInput = {
    update: XOR<userUpdateWithoutDeviceInput, userUncheckedUpdateWithoutDeviceInput>
    create: XOR<userCreateWithoutDeviceInput, userUncheckedCreateWithoutDeviceInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutDeviceInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutDeviceInput, userUncheckedUpdateWithoutDeviceInput>
  }

  export type userUpdateWithoutDeviceInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    env_user?: env_userUpdateManyWithoutUserNestedInput
    helper_user_helper_user_helper_idTouser?: helper_userUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput
    helper_user_helper_user_user_idTouser?: helper_userUpdateManyWithoutUser_helper_user_user_idTouserNestedInput
    intervention_history?: intervention_historyUpdateManyWithoutUserNestedInput
    localisation?: localisationUpdateOneWithoutUserNestedInput
    purchase_history?: purchase_historyUpdateManyWithoutUserNestedInput
    user_type?: user_typeUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    userTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    env_user?: env_userUncheckedUpdateManyWithoutUserNestedInput
    helper_user_helper_user_helper_idTouser?: helper_userUncheckedUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput
    helper_user_helper_user_user_idTouser?: helper_userUncheckedUpdateManyWithoutUser_helper_user_user_idTouserNestedInput
    intervention_history?: intervention_historyUncheckedUpdateManyWithoutUserNestedInput
    localisation?: localisationUncheckedUpdateOneWithoutUserNestedInput
    purchase_history?: purchase_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type purchase_historyUpsertWithWhereUniqueWithoutDeviceInput = {
    where: purchase_historyWhereUniqueInput
    update: XOR<purchase_historyUpdateWithoutDeviceInput, purchase_historyUncheckedUpdateWithoutDeviceInput>
    create: XOR<purchase_historyCreateWithoutDeviceInput, purchase_historyUncheckedCreateWithoutDeviceInput>
  }

  export type purchase_historyUpdateWithWhereUniqueWithoutDeviceInput = {
    where: purchase_historyWhereUniqueInput
    data: XOR<purchase_historyUpdateWithoutDeviceInput, purchase_historyUncheckedUpdateWithoutDeviceInput>
  }

  export type purchase_historyUpdateManyWithWhereWithoutDeviceInput = {
    where: purchase_historyScalarWhereInput
    data: XOR<purchase_historyUpdateManyMutationInput, purchase_historyUncheckedUpdateManyWithoutDeviceInput>
  }

  export type purchase_historyScalarWhereInput = {
    AND?: purchase_historyScalarWhereInput | purchase_historyScalarWhereInput[]
    OR?: purchase_historyScalarWhereInput[]
    NOT?: purchase_historyScalarWhereInput | purchase_historyScalarWhereInput[]
    id?: IntFilter<"purchase_history"> | number
    date?: DateTimeFilter<"purchase_history"> | Date | string
    user_id?: IntNullableFilter<"purchase_history"> | number | null
    device_id?: IntNullableFilter<"purchase_history"> | number | null
    public?: BoolNullableFilter<"purchase_history"> | boolean | null
  }

  export type deviceCreateWithoutDevice_typeInput = {
    mac_address: string
    software_version: string
    date_of_service: Date | string
    comm_state: boolean
    connection_state?: boolean | null
    battery_capacity?: number
    price?: number | null
    alert?: alertCreateNestedManyWithoutDeviceInput
    state_type: state_typeCreateNestedOneWithoutDeviceInput
    user?: userCreateNestedOneWithoutDeviceInput
    purchase_history?: purchase_historyCreateNestedManyWithoutDeviceInput
  }

  export type deviceUncheckedCreateWithoutDevice_typeInput = {
    id?: number
    state_type_id: number
    user_id?: number | null
    mac_address: string
    software_version: string
    date_of_service: Date | string
    comm_state: boolean
    connection_state?: boolean | null
    battery_capacity?: number
    price?: number | null
    alert?: alertUncheckedCreateNestedManyWithoutDeviceInput
    purchase_history?: purchase_historyUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type deviceCreateOrConnectWithoutDevice_typeInput = {
    where: deviceWhereUniqueInput
    create: XOR<deviceCreateWithoutDevice_typeInput, deviceUncheckedCreateWithoutDevice_typeInput>
  }

  export type deviceCreateManyDevice_typeInputEnvelope = {
    data: deviceCreateManyDevice_typeInput | deviceCreateManyDevice_typeInput[]
    skipDuplicates?: boolean
  }

  export type deviceUpsertWithWhereUniqueWithoutDevice_typeInput = {
    where: deviceWhereUniqueInput
    update: XOR<deviceUpdateWithoutDevice_typeInput, deviceUncheckedUpdateWithoutDevice_typeInput>
    create: XOR<deviceCreateWithoutDevice_typeInput, deviceUncheckedCreateWithoutDevice_typeInput>
  }

  export type deviceUpdateWithWhereUniqueWithoutDevice_typeInput = {
    where: deviceWhereUniqueInput
    data: XOR<deviceUpdateWithoutDevice_typeInput, deviceUncheckedUpdateWithoutDevice_typeInput>
  }

  export type deviceUpdateManyWithWhereWithoutDevice_typeInput = {
    where: deviceScalarWhereInput
    data: XOR<deviceUpdateManyMutationInput, deviceUncheckedUpdateManyWithoutDevice_typeInput>
  }

  export type deviceScalarWhereInput = {
    AND?: deviceScalarWhereInput | deviceScalarWhereInput[]
    OR?: deviceScalarWhereInput[]
    NOT?: deviceScalarWhereInput | deviceScalarWhereInput[]
    id?: IntFilter<"device"> | number
    type_id?: IntFilter<"device"> | number
    state_type_id?: IntFilter<"device"> | number
    user_id?: IntNullableFilter<"device"> | number | null
    mac_address?: StringFilter<"device"> | string
    software_version?: StringFilter<"device"> | string
    date_of_service?: DateTimeFilter<"device"> | Date | string
    comm_state?: BoolFilter<"device"> | boolean
    connection_state?: BoolNullableFilter<"device"> | boolean | null
    battery_capacity?: IntFilter<"device"> | number
    price?: FloatNullableFilter<"device"> | number | null
  }

  export type environmentCreateWithoutEnv_delimiterInput = {
    name: string
    description?: string | null
    address?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_public?: boolean | null
    surface?: number | null
    env_user?: env_userCreateNestedManyWithoutEnvironmentInput
    map?: mapCreateNestedOneWithoutEnvironmentInput
    poi?: poiCreateNestedManyWithoutEnvironmentInput
    zone?: zoneCreateNestedManyWithoutEnvironmentInput
  }

  export type environmentUncheckedCreateWithoutEnv_delimiterInput = {
    id?: number
    name: string
    description?: string | null
    address?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    map_id?: number | null
    is_public?: boolean | null
    surface?: number | null
    env_user?: env_userUncheckedCreateNestedManyWithoutEnvironmentInput
    poi?: poiUncheckedCreateNestedManyWithoutEnvironmentInput
    zone?: zoneUncheckedCreateNestedManyWithoutEnvironmentInput
  }

  export type environmentCreateOrConnectWithoutEnv_delimiterInput = {
    where: environmentWhereUniqueInput
    create: XOR<environmentCreateWithoutEnv_delimiterInput, environmentUncheckedCreateWithoutEnv_delimiterInput>
  }

  export type environmentUpsertWithoutEnv_delimiterInput = {
    update: XOR<environmentUpdateWithoutEnv_delimiterInput, environmentUncheckedUpdateWithoutEnv_delimiterInput>
    create: XOR<environmentCreateWithoutEnv_delimiterInput, environmentUncheckedCreateWithoutEnv_delimiterInput>
    where?: environmentWhereInput
  }

  export type environmentUpdateToOneWithWhereWithoutEnv_delimiterInput = {
    where?: environmentWhereInput
    data: XOR<environmentUpdateWithoutEnv_delimiterInput, environmentUncheckedUpdateWithoutEnv_delimiterInput>
  }

  export type environmentUpdateWithoutEnv_delimiterInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    env_user?: env_userUpdateManyWithoutEnvironmentNestedInput
    map?: mapUpdateOneWithoutEnvironmentNestedInput
    poi?: poiUpdateManyWithoutEnvironmentNestedInput
    zone?: zoneUpdateManyWithoutEnvironmentNestedInput
  }

  export type environmentUncheckedUpdateWithoutEnv_delimiterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    env_user?: env_userUncheckedUpdateManyWithoutEnvironmentNestedInput
    poi?: poiUncheckedUpdateManyWithoutEnvironmentNestedInput
    zone?: zoneUncheckedUpdateManyWithoutEnvironmentNestedInput
  }

  export type environmentCreateWithoutEnv_userInput = {
    name: string
    description?: string | null
    address?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_public?: boolean | null
    surface?: number | null
    env_delimiter?: env_delimiterCreateNestedManyWithoutEnvironmentInput
    map?: mapCreateNestedOneWithoutEnvironmentInput
    poi?: poiCreateNestedManyWithoutEnvironmentInput
    zone?: zoneCreateNestedManyWithoutEnvironmentInput
  }

  export type environmentUncheckedCreateWithoutEnv_userInput = {
    id?: number
    name: string
    description?: string | null
    address?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    map_id?: number | null
    is_public?: boolean | null
    surface?: number | null
    env_delimiter?: env_delimiterUncheckedCreateNestedManyWithoutEnvironmentInput
    poi?: poiUncheckedCreateNestedManyWithoutEnvironmentInput
    zone?: zoneUncheckedCreateNestedManyWithoutEnvironmentInput
  }

  export type environmentCreateOrConnectWithoutEnv_userInput = {
    where: environmentWhereUniqueInput
    create: XOR<environmentCreateWithoutEnv_userInput, environmentUncheckedCreateWithoutEnv_userInput>
  }

  export type userCreateWithoutEnv_userInput = {
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    device?: deviceCreateNestedManyWithoutUserInput
    helper_user_helper_user_helper_idTouser?: helper_userCreateNestedManyWithoutUser_helper_user_helper_idTouserInput
    helper_user_helper_user_user_idTouser?: helper_userCreateNestedManyWithoutUser_helper_user_user_idTouserInput
    intervention_history?: intervention_historyCreateNestedManyWithoutUserInput
    localisation?: localisationCreateNestedOneWithoutUserInput
    purchase_history?: purchase_historyCreateNestedManyWithoutUserInput
    user_type?: user_typeCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutEnv_userInput = {
    id?: number
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    userTypeId?: number | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    device?: deviceUncheckedCreateNestedManyWithoutUserInput
    helper_user_helper_user_helper_idTouser?: helper_userUncheckedCreateNestedManyWithoutUser_helper_user_helper_idTouserInput
    helper_user_helper_user_user_idTouser?: helper_userUncheckedCreateNestedManyWithoutUser_helper_user_user_idTouserInput
    intervention_history?: intervention_historyUncheckedCreateNestedManyWithoutUserInput
    localisation?: localisationUncheckedCreateNestedOneWithoutUserInput
    purchase_history?: purchase_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutEnv_userInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutEnv_userInput, userUncheckedCreateWithoutEnv_userInput>
  }

  export type environmentUpsertWithoutEnv_userInput = {
    update: XOR<environmentUpdateWithoutEnv_userInput, environmentUncheckedUpdateWithoutEnv_userInput>
    create: XOR<environmentCreateWithoutEnv_userInput, environmentUncheckedCreateWithoutEnv_userInput>
    where?: environmentWhereInput
  }

  export type environmentUpdateToOneWithWhereWithoutEnv_userInput = {
    where?: environmentWhereInput
    data: XOR<environmentUpdateWithoutEnv_userInput, environmentUncheckedUpdateWithoutEnv_userInput>
  }

  export type environmentUpdateWithoutEnv_userInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    env_delimiter?: env_delimiterUpdateManyWithoutEnvironmentNestedInput
    map?: mapUpdateOneWithoutEnvironmentNestedInput
    poi?: poiUpdateManyWithoutEnvironmentNestedInput
    zone?: zoneUpdateManyWithoutEnvironmentNestedInput
  }

  export type environmentUncheckedUpdateWithoutEnv_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    env_delimiter?: env_delimiterUncheckedUpdateManyWithoutEnvironmentNestedInput
    poi?: poiUncheckedUpdateManyWithoutEnvironmentNestedInput
    zone?: zoneUncheckedUpdateManyWithoutEnvironmentNestedInput
  }

  export type userUpsertWithoutEnv_userInput = {
    update: XOR<userUpdateWithoutEnv_userInput, userUncheckedUpdateWithoutEnv_userInput>
    create: XOR<userCreateWithoutEnv_userInput, userUncheckedCreateWithoutEnv_userInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutEnv_userInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutEnv_userInput, userUncheckedUpdateWithoutEnv_userInput>
  }

  export type userUpdateWithoutEnv_userInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    device?: deviceUpdateManyWithoutUserNestedInput
    helper_user_helper_user_helper_idTouser?: helper_userUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput
    helper_user_helper_user_user_idTouser?: helper_userUpdateManyWithoutUser_helper_user_user_idTouserNestedInput
    intervention_history?: intervention_historyUpdateManyWithoutUserNestedInput
    localisation?: localisationUpdateOneWithoutUserNestedInput
    purchase_history?: purchase_historyUpdateManyWithoutUserNestedInput
    user_type?: user_typeUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutEnv_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    userTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    device?: deviceUncheckedUpdateManyWithoutUserNestedInput
    helper_user_helper_user_helper_idTouser?: helper_userUncheckedUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput
    helper_user_helper_user_user_idTouser?: helper_userUncheckedUpdateManyWithoutUser_helper_user_user_idTouserNestedInput
    intervention_history?: intervention_historyUncheckedUpdateManyWithoutUserNestedInput
    localisation?: localisationUncheckedUpdateOneWithoutUserNestedInput
    purchase_history?: purchase_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type env_delimiterCreateWithoutEnvironmentInput = {
    created_at?: Date | string
    updated_at?: Date | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    type?: string | null
  }

  export type env_delimiterUncheckedCreateWithoutEnvironmentInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    type?: string | null
  }

  export type env_delimiterCreateOrConnectWithoutEnvironmentInput = {
    where: env_delimiterWhereUniqueInput
    create: XOR<env_delimiterCreateWithoutEnvironmentInput, env_delimiterUncheckedCreateWithoutEnvironmentInput>
  }

  export type env_delimiterCreateManyEnvironmentInputEnvelope = {
    data: env_delimiterCreateManyEnvironmentInput | env_delimiterCreateManyEnvironmentInput[]
    skipDuplicates?: boolean
  }

  export type env_userCreateWithoutEnvironmentInput = {
    user: userCreateNestedOneWithoutEnv_userInput
  }

  export type env_userUncheckedCreateWithoutEnvironmentInput = {
    id?: number
    user_id: number
  }

  export type env_userCreateOrConnectWithoutEnvironmentInput = {
    where: env_userWhereUniqueInput
    create: XOR<env_userCreateWithoutEnvironmentInput, env_userUncheckedCreateWithoutEnvironmentInput>
  }

  export type env_userCreateManyEnvironmentInputEnvelope = {
    data: env_userCreateManyEnvironmentInput | env_userCreateManyEnvironmentInput[]
    skipDuplicates?: boolean
  }

  export type mapCreateWithoutEnvironmentInput = {
    created_at?: Date | string
    format?: formatCreateNestedOneWithoutMapInput
    poi?: poiCreateNestedManyWithoutMapInput
    zone?: zoneCreateNestedManyWithoutMapInput
  }

  export type mapUncheckedCreateWithoutEnvironmentInput = {
    id?: number
    created_at?: Date | string
    format_id?: number | null
    poi?: poiUncheckedCreateNestedManyWithoutMapInput
    zone?: zoneUncheckedCreateNestedManyWithoutMapInput
  }

  export type mapCreateOrConnectWithoutEnvironmentInput = {
    where: mapWhereUniqueInput
    create: XOR<mapCreateWithoutEnvironmentInput, mapUncheckedCreateWithoutEnvironmentInput>
  }

  export type poiCreateWithoutEnvironmentInput = {
    created_at?: Date | string
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: string | null
    poi_category?: poi_categoryCreateNestedOneWithoutPoiInput
    map?: mapCreateNestedOneWithoutPoiInput
    poi_zone?: poi_zoneCreateNestedManyWithoutPoiInput
  }

  export type poiUncheckedCreateWithoutEnvironmentInput = {
    id?: number
    created_at?: Date | string
    category_id?: number | null
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: string | null
    map_id?: number | null
    poi_zone?: poi_zoneUncheckedCreateNestedManyWithoutPoiInput
  }

  export type poiCreateOrConnectWithoutEnvironmentInput = {
    where: poiWhereUniqueInput
    create: XOR<poiCreateWithoutEnvironmentInput, poiUncheckedCreateWithoutEnvironmentInput>
  }

  export type poiCreateManyEnvironmentInputEnvelope = {
    data: poiCreateManyEnvironmentInput | poiCreateManyEnvironmentInput[]
    skipDuplicates?: boolean
  }

  export type zoneCreateWithoutEnvironmentInput = {
    created_at?: Date | string
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: Date | string | null
    poi_zone?: poi_zoneCreateNestedManyWithoutZoneInput
    map?: mapCreateNestedOneWithoutZoneInput
    zone_type_zone_type_idTozone_type?: zone_typeCreateNestedOneWithoutZone_zone_type_idTozone_typeInput
    zone_type_zone_zone_typeTozone_type?: zone_typeCreateNestedOneWithoutZone_zone_zone_typeTozone_typeInput
  }

  export type zoneUncheckedCreateWithoutEnvironmentInput = {
    id?: number
    created_at?: Date | string
    name?: string | null
    description?: string | null
    type_id?: number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: Date | string | null
    map_id?: number | null
    zone_type?: number | null
    poi_zone?: poi_zoneUncheckedCreateNestedManyWithoutZoneInput
  }

  export type zoneCreateOrConnectWithoutEnvironmentInput = {
    where: zoneWhereUniqueInput
    create: XOR<zoneCreateWithoutEnvironmentInput, zoneUncheckedCreateWithoutEnvironmentInput>
  }

  export type zoneCreateManyEnvironmentInputEnvelope = {
    data: zoneCreateManyEnvironmentInput | zoneCreateManyEnvironmentInput[]
    skipDuplicates?: boolean
  }

  export type env_delimiterUpsertWithWhereUniqueWithoutEnvironmentInput = {
    where: env_delimiterWhereUniqueInput
    update: XOR<env_delimiterUpdateWithoutEnvironmentInput, env_delimiterUncheckedUpdateWithoutEnvironmentInput>
    create: XOR<env_delimiterCreateWithoutEnvironmentInput, env_delimiterUncheckedCreateWithoutEnvironmentInput>
  }

  export type env_delimiterUpdateWithWhereUniqueWithoutEnvironmentInput = {
    where: env_delimiterWhereUniqueInput
    data: XOR<env_delimiterUpdateWithoutEnvironmentInput, env_delimiterUncheckedUpdateWithoutEnvironmentInput>
  }

  export type env_delimiterUpdateManyWithWhereWithoutEnvironmentInput = {
    where: env_delimiterScalarWhereInput
    data: XOR<env_delimiterUpdateManyMutationInput, env_delimiterUncheckedUpdateManyWithoutEnvironmentInput>
  }

  export type env_delimiterScalarWhereInput = {
    AND?: env_delimiterScalarWhereInput | env_delimiterScalarWhereInput[]
    OR?: env_delimiterScalarWhereInput[]
    NOT?: env_delimiterScalarWhereInput | env_delimiterScalarWhereInput[]
    id?: IntFilter<"env_delimiter"> | number
    created_at?: DateTimeFilter<"env_delimiter"> | Date | string
    updated_at?: DateTimeNullableFilter<"env_delimiter"> | Date | string | null
    env_id?: IntNullableFilter<"env_delimiter"> | number | null
    coordinates?: JsonNullableFilter<"env_delimiter">
    type?: StringNullableFilter<"env_delimiter"> | string | null
  }

  export type env_userUpsertWithWhereUniqueWithoutEnvironmentInput = {
    where: env_userWhereUniqueInput
    update: XOR<env_userUpdateWithoutEnvironmentInput, env_userUncheckedUpdateWithoutEnvironmentInput>
    create: XOR<env_userCreateWithoutEnvironmentInput, env_userUncheckedCreateWithoutEnvironmentInput>
  }

  export type env_userUpdateWithWhereUniqueWithoutEnvironmentInput = {
    where: env_userWhereUniqueInput
    data: XOR<env_userUpdateWithoutEnvironmentInput, env_userUncheckedUpdateWithoutEnvironmentInput>
  }

  export type env_userUpdateManyWithWhereWithoutEnvironmentInput = {
    where: env_userScalarWhereInput
    data: XOR<env_userUpdateManyMutationInput, env_userUncheckedUpdateManyWithoutEnvironmentInput>
  }

  export type env_userScalarWhereInput = {
    AND?: env_userScalarWhereInput | env_userScalarWhereInput[]
    OR?: env_userScalarWhereInput[]
    NOT?: env_userScalarWhereInput | env_userScalarWhereInput[]
    id?: IntFilter<"env_user"> | number
    user_id?: IntFilter<"env_user"> | number
    env_id?: IntNullableFilter<"env_user"> | number | null
  }

  export type mapUpsertWithoutEnvironmentInput = {
    update: XOR<mapUpdateWithoutEnvironmentInput, mapUncheckedUpdateWithoutEnvironmentInput>
    create: XOR<mapCreateWithoutEnvironmentInput, mapUncheckedCreateWithoutEnvironmentInput>
    where?: mapWhereInput
  }

  export type mapUpdateToOneWithWhereWithoutEnvironmentInput = {
    where?: mapWhereInput
    data: XOR<mapUpdateWithoutEnvironmentInput, mapUncheckedUpdateWithoutEnvironmentInput>
  }

  export type mapUpdateWithoutEnvironmentInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    format?: formatUpdateOneWithoutMapNestedInput
    poi?: poiUpdateManyWithoutMapNestedInput
    zone?: zoneUpdateManyWithoutMapNestedInput
  }

  export type mapUncheckedUpdateWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    format_id?: NullableIntFieldUpdateOperationsInput | number | null
    poi?: poiUncheckedUpdateManyWithoutMapNestedInput
    zone?: zoneUncheckedUpdateManyWithoutMapNestedInput
  }

  export type poiUpsertWithWhereUniqueWithoutEnvironmentInput = {
    where: poiWhereUniqueInput
    update: XOR<poiUpdateWithoutEnvironmentInput, poiUncheckedUpdateWithoutEnvironmentInput>
    create: XOR<poiCreateWithoutEnvironmentInput, poiUncheckedCreateWithoutEnvironmentInput>
  }

  export type poiUpdateWithWhereUniqueWithoutEnvironmentInput = {
    where: poiWhereUniqueInput
    data: XOR<poiUpdateWithoutEnvironmentInput, poiUncheckedUpdateWithoutEnvironmentInput>
  }

  export type poiUpdateManyWithWhereWithoutEnvironmentInput = {
    where: poiScalarWhereInput
    data: XOR<poiUpdateManyMutationInput, poiUncheckedUpdateManyWithoutEnvironmentInput>
  }

  export type poiScalarWhereInput = {
    AND?: poiScalarWhereInput | poiScalarWhereInput[]
    OR?: poiScalarWhereInput[]
    NOT?: poiScalarWhereInput | poiScalarWhereInput[]
    id?: IntFilter<"poi"> | number
    created_at?: DateTimeFilter<"poi"> | Date | string
    env_id?: IntNullableFilter<"poi"> | number | null
    category_id?: IntNullableFilter<"poi"> | number | null
    name?: StringNullableFilter<"poi"> | string | null
    description?: StringNullableFilter<"poi"> | string | null
    coordinates?: JsonNullableFilter<"poi">
    image_url?: StringNullableFilter<"poi"> | string | null
    map_id?: IntNullableFilter<"poi"> | number | null
  }

  export type zoneUpsertWithWhereUniqueWithoutEnvironmentInput = {
    where: zoneWhereUniqueInput
    update: XOR<zoneUpdateWithoutEnvironmentInput, zoneUncheckedUpdateWithoutEnvironmentInput>
    create: XOR<zoneCreateWithoutEnvironmentInput, zoneUncheckedCreateWithoutEnvironmentInput>
  }

  export type zoneUpdateWithWhereUniqueWithoutEnvironmentInput = {
    where: zoneWhereUniqueInput
    data: XOR<zoneUpdateWithoutEnvironmentInput, zoneUncheckedUpdateWithoutEnvironmentInput>
  }

  export type zoneUpdateManyWithWhereWithoutEnvironmentInput = {
    where: zoneScalarWhereInput
    data: XOR<zoneUpdateManyMutationInput, zoneUncheckedUpdateManyWithoutEnvironmentInput>
  }

  export type zoneScalarWhereInput = {
    AND?: zoneScalarWhereInput | zoneScalarWhereInput[]
    OR?: zoneScalarWhereInput[]
    NOT?: zoneScalarWhereInput | zoneScalarWhereInput[]
    id?: IntFilter<"zone"> | number
    created_at?: DateTimeFilter<"zone"> | Date | string
    env_id?: IntNullableFilter<"zone"> | number | null
    name?: StringNullableFilter<"zone"> | string | null
    description?: StringNullableFilter<"zone"> | string | null
    type_id?: IntNullableFilter<"zone"> | number | null
    coordinates?: JsonNullableFilter<"zone">
    updated_at?: DateTimeNullableFilter<"zone"> | Date | string | null
    map_id?: IntNullableFilter<"zone"> | number | null
    zone_type?: IntNullableFilter<"zone"> | number | null
  }

  export type mapCreateWithoutFormatInput = {
    created_at?: Date | string
    environment?: environmentCreateNestedManyWithoutMapInput
    poi?: poiCreateNestedManyWithoutMapInput
    zone?: zoneCreateNestedManyWithoutMapInput
  }

  export type mapUncheckedCreateWithoutFormatInput = {
    id?: number
    created_at?: Date | string
    environment?: environmentUncheckedCreateNestedManyWithoutMapInput
    poi?: poiUncheckedCreateNestedManyWithoutMapInput
    zone?: zoneUncheckedCreateNestedManyWithoutMapInput
  }

  export type mapCreateOrConnectWithoutFormatInput = {
    where: mapWhereUniqueInput
    create: XOR<mapCreateWithoutFormatInput, mapUncheckedCreateWithoutFormatInput>
  }

  export type mapCreateManyFormatInputEnvelope = {
    data: mapCreateManyFormatInput | mapCreateManyFormatInput[]
    skipDuplicates?: boolean
  }

  export type mapUpsertWithWhereUniqueWithoutFormatInput = {
    where: mapWhereUniqueInput
    update: XOR<mapUpdateWithoutFormatInput, mapUncheckedUpdateWithoutFormatInput>
    create: XOR<mapCreateWithoutFormatInput, mapUncheckedCreateWithoutFormatInput>
  }

  export type mapUpdateWithWhereUniqueWithoutFormatInput = {
    where: mapWhereUniqueInput
    data: XOR<mapUpdateWithoutFormatInput, mapUncheckedUpdateWithoutFormatInput>
  }

  export type mapUpdateManyWithWhereWithoutFormatInput = {
    where: mapScalarWhereInput
    data: XOR<mapUpdateManyMutationInput, mapUncheckedUpdateManyWithoutFormatInput>
  }

  export type mapScalarWhereInput = {
    AND?: mapScalarWhereInput | mapScalarWhereInput[]
    OR?: mapScalarWhereInput[]
    NOT?: mapScalarWhereInput | mapScalarWhereInput[]
    id?: IntFilter<"map"> | number
    created_at?: DateTimeFilter<"map"> | Date | string
    format_id?: IntNullableFilter<"map"> | number | null
  }

  export type userCreateWithoutHelper_user_helper_user_helper_idTouserInput = {
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    device?: deviceCreateNestedManyWithoutUserInput
    env_user?: env_userCreateNestedManyWithoutUserInput
    helper_user_helper_user_user_idTouser?: helper_userCreateNestedManyWithoutUser_helper_user_user_idTouserInput
    intervention_history?: intervention_historyCreateNestedManyWithoutUserInput
    localisation?: localisationCreateNestedOneWithoutUserInput
    purchase_history?: purchase_historyCreateNestedManyWithoutUserInput
    user_type?: user_typeCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutHelper_user_helper_user_helper_idTouserInput = {
    id?: number
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    userTypeId?: number | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    device?: deviceUncheckedCreateNestedManyWithoutUserInput
    env_user?: env_userUncheckedCreateNestedManyWithoutUserInput
    helper_user_helper_user_user_idTouser?: helper_userUncheckedCreateNestedManyWithoutUser_helper_user_user_idTouserInput
    intervention_history?: intervention_historyUncheckedCreateNestedManyWithoutUserInput
    localisation?: localisationUncheckedCreateNestedOneWithoutUserInput
    purchase_history?: purchase_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutHelper_user_helper_user_helper_idTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutHelper_user_helper_user_helper_idTouserInput, userUncheckedCreateWithoutHelper_user_helper_user_helper_idTouserInput>
  }

  export type userCreateWithoutHelper_user_helper_user_user_idTouserInput = {
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    device?: deviceCreateNestedManyWithoutUserInput
    env_user?: env_userCreateNestedManyWithoutUserInput
    helper_user_helper_user_helper_idTouser?: helper_userCreateNestedManyWithoutUser_helper_user_helper_idTouserInput
    intervention_history?: intervention_historyCreateNestedManyWithoutUserInput
    localisation?: localisationCreateNestedOneWithoutUserInput
    purchase_history?: purchase_historyCreateNestedManyWithoutUserInput
    user_type?: user_typeCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutHelper_user_helper_user_user_idTouserInput = {
    id?: number
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    userTypeId?: number | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    device?: deviceUncheckedCreateNestedManyWithoutUserInput
    env_user?: env_userUncheckedCreateNestedManyWithoutUserInput
    helper_user_helper_user_helper_idTouser?: helper_userUncheckedCreateNestedManyWithoutUser_helper_user_helper_idTouserInput
    intervention_history?: intervention_historyUncheckedCreateNestedManyWithoutUserInput
    localisation?: localisationUncheckedCreateNestedOneWithoutUserInput
    purchase_history?: purchase_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutHelper_user_helper_user_user_idTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutHelper_user_helper_user_user_idTouserInput, userUncheckedCreateWithoutHelper_user_helper_user_user_idTouserInput>
  }

  export type userUpsertWithoutHelper_user_helper_user_helper_idTouserInput = {
    update: XOR<userUpdateWithoutHelper_user_helper_user_helper_idTouserInput, userUncheckedUpdateWithoutHelper_user_helper_user_helper_idTouserInput>
    create: XOR<userCreateWithoutHelper_user_helper_user_helper_idTouserInput, userUncheckedCreateWithoutHelper_user_helper_user_helper_idTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutHelper_user_helper_user_helper_idTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutHelper_user_helper_user_helper_idTouserInput, userUncheckedUpdateWithoutHelper_user_helper_user_helper_idTouserInput>
  }

  export type userUpdateWithoutHelper_user_helper_user_helper_idTouserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    device?: deviceUpdateManyWithoutUserNestedInput
    env_user?: env_userUpdateManyWithoutUserNestedInput
    helper_user_helper_user_user_idTouser?: helper_userUpdateManyWithoutUser_helper_user_user_idTouserNestedInput
    intervention_history?: intervention_historyUpdateManyWithoutUserNestedInput
    localisation?: localisationUpdateOneWithoutUserNestedInput
    purchase_history?: purchase_historyUpdateManyWithoutUserNestedInput
    user_type?: user_typeUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutHelper_user_helper_user_helper_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    userTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    device?: deviceUncheckedUpdateManyWithoutUserNestedInput
    env_user?: env_userUncheckedUpdateManyWithoutUserNestedInput
    helper_user_helper_user_user_idTouser?: helper_userUncheckedUpdateManyWithoutUser_helper_user_user_idTouserNestedInput
    intervention_history?: intervention_historyUncheckedUpdateManyWithoutUserNestedInput
    localisation?: localisationUncheckedUpdateOneWithoutUserNestedInput
    purchase_history?: purchase_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutHelper_user_helper_user_user_idTouserInput = {
    update: XOR<userUpdateWithoutHelper_user_helper_user_user_idTouserInput, userUncheckedUpdateWithoutHelper_user_helper_user_user_idTouserInput>
    create: XOR<userCreateWithoutHelper_user_helper_user_user_idTouserInput, userUncheckedCreateWithoutHelper_user_helper_user_user_idTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutHelper_user_helper_user_user_idTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutHelper_user_helper_user_user_idTouserInput, userUncheckedUpdateWithoutHelper_user_helper_user_user_idTouserInput>
  }

  export type userUpdateWithoutHelper_user_helper_user_user_idTouserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    device?: deviceUpdateManyWithoutUserNestedInput
    env_user?: env_userUpdateManyWithoutUserNestedInput
    helper_user_helper_user_helper_idTouser?: helper_userUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput
    intervention_history?: intervention_historyUpdateManyWithoutUserNestedInput
    localisation?: localisationUpdateOneWithoutUserNestedInput
    purchase_history?: purchase_historyUpdateManyWithoutUserNestedInput
    user_type?: user_typeUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutHelper_user_helper_user_user_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    userTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    device?: deviceUncheckedUpdateManyWithoutUserNestedInput
    env_user?: env_userUncheckedUpdateManyWithoutUserNestedInput
    helper_user_helper_user_helper_idTouser?: helper_userUncheckedUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput
    intervention_history?: intervention_historyUncheckedUpdateManyWithoutUserNestedInput
    localisation?: localisationUncheckedUpdateOneWithoutUserNestedInput
    purchase_history?: purchase_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutIntervention_historyInput = {
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    device?: deviceCreateNestedManyWithoutUserInput
    env_user?: env_userCreateNestedManyWithoutUserInput
    helper_user_helper_user_helper_idTouser?: helper_userCreateNestedManyWithoutUser_helper_user_helper_idTouserInput
    helper_user_helper_user_user_idTouser?: helper_userCreateNestedManyWithoutUser_helper_user_user_idTouserInput
    localisation?: localisationCreateNestedOneWithoutUserInput
    purchase_history?: purchase_historyCreateNestedManyWithoutUserInput
    user_type?: user_typeCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutIntervention_historyInput = {
    id?: number
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    userTypeId?: number | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    device?: deviceUncheckedCreateNestedManyWithoutUserInput
    env_user?: env_userUncheckedCreateNestedManyWithoutUserInput
    helper_user_helper_user_helper_idTouser?: helper_userUncheckedCreateNestedManyWithoutUser_helper_user_helper_idTouserInput
    helper_user_helper_user_user_idTouser?: helper_userUncheckedCreateNestedManyWithoutUser_helper_user_user_idTouserInput
    localisation?: localisationUncheckedCreateNestedOneWithoutUserInput
    purchase_history?: purchase_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutIntervention_historyInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutIntervention_historyInput, userUncheckedCreateWithoutIntervention_historyInput>
  }

  export type userUpsertWithoutIntervention_historyInput = {
    update: XOR<userUpdateWithoutIntervention_historyInput, userUncheckedUpdateWithoutIntervention_historyInput>
    create: XOR<userCreateWithoutIntervention_historyInput, userUncheckedCreateWithoutIntervention_historyInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutIntervention_historyInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutIntervention_historyInput, userUncheckedUpdateWithoutIntervention_historyInput>
  }

  export type userUpdateWithoutIntervention_historyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    device?: deviceUpdateManyWithoutUserNestedInput
    env_user?: env_userUpdateManyWithoutUserNestedInput
    helper_user_helper_user_helper_idTouser?: helper_userUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput
    helper_user_helper_user_user_idTouser?: helper_userUpdateManyWithoutUser_helper_user_user_idTouserNestedInput
    localisation?: localisationUpdateOneWithoutUserNestedInput
    purchase_history?: purchase_historyUpdateManyWithoutUserNestedInput
    user_type?: user_typeUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutIntervention_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    userTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    device?: deviceUncheckedUpdateManyWithoutUserNestedInput
    env_user?: env_userUncheckedUpdateManyWithoutUserNestedInput
    helper_user_helper_user_helper_idTouser?: helper_userUncheckedUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput
    helper_user_helper_user_user_idTouser?: helper_userUncheckedUpdateManyWithoutUser_helper_user_user_idTouserNestedInput
    localisation?: localisationUncheckedUpdateOneWithoutUserNestedInput
    purchase_history?: purchase_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutLocalisationInput = {
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    device?: deviceCreateNestedManyWithoutUserInput
    env_user?: env_userCreateNestedManyWithoutUserInput
    helper_user_helper_user_helper_idTouser?: helper_userCreateNestedManyWithoutUser_helper_user_helper_idTouserInput
    helper_user_helper_user_user_idTouser?: helper_userCreateNestedManyWithoutUser_helper_user_user_idTouserInput
    intervention_history?: intervention_historyCreateNestedManyWithoutUserInput
    purchase_history?: purchase_historyCreateNestedManyWithoutUserInput
    user_type?: user_typeCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutLocalisationInput = {
    id?: number
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    userTypeId?: number | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    device?: deviceUncheckedCreateNestedManyWithoutUserInput
    env_user?: env_userUncheckedCreateNestedManyWithoutUserInput
    helper_user_helper_user_helper_idTouser?: helper_userUncheckedCreateNestedManyWithoutUser_helper_user_helper_idTouserInput
    helper_user_helper_user_user_idTouser?: helper_userUncheckedCreateNestedManyWithoutUser_helper_user_user_idTouserInput
    intervention_history?: intervention_historyUncheckedCreateNestedManyWithoutUserInput
    purchase_history?: purchase_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutLocalisationInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutLocalisationInput, userUncheckedCreateWithoutLocalisationInput>
  }

  export type userUpsertWithoutLocalisationInput = {
    update: XOR<userUpdateWithoutLocalisationInput, userUncheckedUpdateWithoutLocalisationInput>
    create: XOR<userCreateWithoutLocalisationInput, userUncheckedCreateWithoutLocalisationInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutLocalisationInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutLocalisationInput, userUncheckedUpdateWithoutLocalisationInput>
  }

  export type userUpdateWithoutLocalisationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    device?: deviceUpdateManyWithoutUserNestedInput
    env_user?: env_userUpdateManyWithoutUserNestedInput
    helper_user_helper_user_helper_idTouser?: helper_userUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput
    helper_user_helper_user_user_idTouser?: helper_userUpdateManyWithoutUser_helper_user_user_idTouserNestedInput
    intervention_history?: intervention_historyUpdateManyWithoutUserNestedInput
    purchase_history?: purchase_historyUpdateManyWithoutUserNestedInput
    user_type?: user_typeUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutLocalisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    userTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    device?: deviceUncheckedUpdateManyWithoutUserNestedInput
    env_user?: env_userUncheckedUpdateManyWithoutUserNestedInput
    helper_user_helper_user_helper_idTouser?: helper_userUncheckedUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput
    helper_user_helper_user_user_idTouser?: helper_userUncheckedUpdateManyWithoutUser_helper_user_user_idTouserNestedInput
    intervention_history?: intervention_historyUncheckedUpdateManyWithoutUserNestedInput
    purchase_history?: purchase_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type environmentCreateWithoutMapInput = {
    name: string
    description?: string | null
    address?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_public?: boolean | null
    surface?: number | null
    env_delimiter?: env_delimiterCreateNestedManyWithoutEnvironmentInput
    env_user?: env_userCreateNestedManyWithoutEnvironmentInput
    poi?: poiCreateNestedManyWithoutEnvironmentInput
    zone?: zoneCreateNestedManyWithoutEnvironmentInput
  }

  export type environmentUncheckedCreateWithoutMapInput = {
    id?: number
    name: string
    description?: string | null
    address?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_public?: boolean | null
    surface?: number | null
    env_delimiter?: env_delimiterUncheckedCreateNestedManyWithoutEnvironmentInput
    env_user?: env_userUncheckedCreateNestedManyWithoutEnvironmentInput
    poi?: poiUncheckedCreateNestedManyWithoutEnvironmentInput
    zone?: zoneUncheckedCreateNestedManyWithoutEnvironmentInput
  }

  export type environmentCreateOrConnectWithoutMapInput = {
    where: environmentWhereUniqueInput
    create: XOR<environmentCreateWithoutMapInput, environmentUncheckedCreateWithoutMapInput>
  }

  export type environmentCreateManyMapInputEnvelope = {
    data: environmentCreateManyMapInput | environmentCreateManyMapInput[]
    skipDuplicates?: boolean
  }

  export type formatCreateWithoutMapInput = {
    format: string
  }

  export type formatUncheckedCreateWithoutMapInput = {
    id?: number
    format: string
  }

  export type formatCreateOrConnectWithoutMapInput = {
    where: formatWhereUniqueInput
    create: XOR<formatCreateWithoutMapInput, formatUncheckedCreateWithoutMapInput>
  }

  export type poiCreateWithoutMapInput = {
    created_at?: Date | string
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: string | null
    poi_category?: poi_categoryCreateNestedOneWithoutPoiInput
    environment?: environmentCreateNestedOneWithoutPoiInput
    poi_zone?: poi_zoneCreateNestedManyWithoutPoiInput
  }

  export type poiUncheckedCreateWithoutMapInput = {
    id?: number
    created_at?: Date | string
    env_id?: number | null
    category_id?: number | null
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: string | null
    poi_zone?: poi_zoneUncheckedCreateNestedManyWithoutPoiInput
  }

  export type poiCreateOrConnectWithoutMapInput = {
    where: poiWhereUniqueInput
    create: XOR<poiCreateWithoutMapInput, poiUncheckedCreateWithoutMapInput>
  }

  export type poiCreateManyMapInputEnvelope = {
    data: poiCreateManyMapInput | poiCreateManyMapInput[]
    skipDuplicates?: boolean
  }

  export type zoneCreateWithoutMapInput = {
    created_at?: Date | string
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: Date | string | null
    poi_zone?: poi_zoneCreateNestedManyWithoutZoneInput
    environment?: environmentCreateNestedOneWithoutZoneInput
    zone_type_zone_type_idTozone_type?: zone_typeCreateNestedOneWithoutZone_zone_type_idTozone_typeInput
    zone_type_zone_zone_typeTozone_type?: zone_typeCreateNestedOneWithoutZone_zone_zone_typeTozone_typeInput
  }

  export type zoneUncheckedCreateWithoutMapInput = {
    id?: number
    created_at?: Date | string
    env_id?: number | null
    name?: string | null
    description?: string | null
    type_id?: number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: Date | string | null
    zone_type?: number | null
    poi_zone?: poi_zoneUncheckedCreateNestedManyWithoutZoneInput
  }

  export type zoneCreateOrConnectWithoutMapInput = {
    where: zoneWhereUniqueInput
    create: XOR<zoneCreateWithoutMapInput, zoneUncheckedCreateWithoutMapInput>
  }

  export type zoneCreateManyMapInputEnvelope = {
    data: zoneCreateManyMapInput | zoneCreateManyMapInput[]
    skipDuplicates?: boolean
  }

  export type environmentUpsertWithWhereUniqueWithoutMapInput = {
    where: environmentWhereUniqueInput
    update: XOR<environmentUpdateWithoutMapInput, environmentUncheckedUpdateWithoutMapInput>
    create: XOR<environmentCreateWithoutMapInput, environmentUncheckedCreateWithoutMapInput>
  }

  export type environmentUpdateWithWhereUniqueWithoutMapInput = {
    where: environmentWhereUniqueInput
    data: XOR<environmentUpdateWithoutMapInput, environmentUncheckedUpdateWithoutMapInput>
  }

  export type environmentUpdateManyWithWhereWithoutMapInput = {
    where: environmentScalarWhereInput
    data: XOR<environmentUpdateManyMutationInput, environmentUncheckedUpdateManyWithoutMapInput>
  }

  export type environmentScalarWhereInput = {
    AND?: environmentScalarWhereInput | environmentScalarWhereInput[]
    OR?: environmentScalarWhereInput[]
    NOT?: environmentScalarWhereInput | environmentScalarWhereInput[]
    id?: IntFilter<"environment"> | number
    name?: StringFilter<"environment"> | string
    description?: StringNullableFilter<"environment"> | string | null
    address?: StringNullableFilter<"environment"> | string | null
    created_at?: DateTimeNullableFilter<"environment"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"environment"> | Date | string | null
    map_id?: IntNullableFilter<"environment"> | number | null
    is_public?: BoolNullableFilter<"environment"> | boolean | null
    surface?: FloatNullableFilter<"environment"> | number | null
  }

  export type formatUpsertWithoutMapInput = {
    update: XOR<formatUpdateWithoutMapInput, formatUncheckedUpdateWithoutMapInput>
    create: XOR<formatCreateWithoutMapInput, formatUncheckedCreateWithoutMapInput>
    where?: formatWhereInput
  }

  export type formatUpdateToOneWithWhereWithoutMapInput = {
    where?: formatWhereInput
    data: XOR<formatUpdateWithoutMapInput, formatUncheckedUpdateWithoutMapInput>
  }

  export type formatUpdateWithoutMapInput = {
    format?: StringFieldUpdateOperationsInput | string
  }

  export type formatUncheckedUpdateWithoutMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
  }

  export type poiUpsertWithWhereUniqueWithoutMapInput = {
    where: poiWhereUniqueInput
    update: XOR<poiUpdateWithoutMapInput, poiUncheckedUpdateWithoutMapInput>
    create: XOR<poiCreateWithoutMapInput, poiUncheckedCreateWithoutMapInput>
  }

  export type poiUpdateWithWhereUniqueWithoutMapInput = {
    where: poiWhereUniqueInput
    data: XOR<poiUpdateWithoutMapInput, poiUncheckedUpdateWithoutMapInput>
  }

  export type poiUpdateManyWithWhereWithoutMapInput = {
    where: poiScalarWhereInput
    data: XOR<poiUpdateManyMutationInput, poiUncheckedUpdateManyWithoutMapInput>
  }

  export type zoneUpsertWithWhereUniqueWithoutMapInput = {
    where: zoneWhereUniqueInput
    update: XOR<zoneUpdateWithoutMapInput, zoneUncheckedUpdateWithoutMapInput>
    create: XOR<zoneCreateWithoutMapInput, zoneUncheckedCreateWithoutMapInput>
  }

  export type zoneUpdateWithWhereUniqueWithoutMapInput = {
    where: zoneWhereUniqueInput
    data: XOR<zoneUpdateWithoutMapInput, zoneUncheckedUpdateWithoutMapInput>
  }

  export type zoneUpdateManyWithWhereWithoutMapInput = {
    where: zoneScalarWhereInput
    data: XOR<zoneUpdateManyMutationInput, zoneUncheckedUpdateManyWithoutMapInput>
  }

  export type alertCreateWithoutPanne_historyInput = {
    type: string
    time: Date | string
    date: Date | string
    zone: string
    status: string
    level: $Enums.level_new
    device?: deviceCreateNestedOneWithoutAlertInput
  }

  export type alertUncheckedCreateWithoutPanne_historyInput = {
    id?: number
    type: string
    time: Date | string
    date: Date | string
    zone: string
    status: string
    level: $Enums.level_new
    device_id?: number | null
  }

  export type alertCreateOrConnectWithoutPanne_historyInput = {
    where: alertWhereUniqueInput
    create: XOR<alertCreateWithoutPanne_historyInput, alertUncheckedCreateWithoutPanne_historyInput>
  }

  export type alertUpsertWithoutPanne_historyInput = {
    update: XOR<alertUpdateWithoutPanne_historyInput, alertUncheckedUpdateWithoutPanne_historyInput>
    create: XOR<alertCreateWithoutPanne_historyInput, alertUncheckedCreateWithoutPanne_historyInput>
    where?: alertWhereInput
  }

  export type alertUpdateToOneWithWhereWithoutPanne_historyInput = {
    where?: alertWhereInput
    data: XOR<alertUpdateWithoutPanne_historyInput, alertUncheckedUpdateWithoutPanne_historyInput>
  }

  export type alertUpdateWithoutPanne_historyInput = {
    type?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: Enumlevel_newFieldUpdateOperationsInput | $Enums.level_new
    device?: deviceUpdateOneWithoutAlertNestedInput
  }

  export type alertUncheckedUpdateWithoutPanne_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: Enumlevel_newFieldUpdateOperationsInput | $Enums.level_new
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type poi_categoryCreateWithoutPoiInput = {
    category: string
  }

  export type poi_categoryUncheckedCreateWithoutPoiInput = {
    id?: number
    category: string
  }

  export type poi_categoryCreateOrConnectWithoutPoiInput = {
    where: poi_categoryWhereUniqueInput
    create: XOR<poi_categoryCreateWithoutPoiInput, poi_categoryUncheckedCreateWithoutPoiInput>
  }

  export type environmentCreateWithoutPoiInput = {
    name: string
    description?: string | null
    address?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_public?: boolean | null
    surface?: number | null
    env_delimiter?: env_delimiterCreateNestedManyWithoutEnvironmentInput
    env_user?: env_userCreateNestedManyWithoutEnvironmentInput
    map?: mapCreateNestedOneWithoutEnvironmentInput
    zone?: zoneCreateNestedManyWithoutEnvironmentInput
  }

  export type environmentUncheckedCreateWithoutPoiInput = {
    id?: number
    name: string
    description?: string | null
    address?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    map_id?: number | null
    is_public?: boolean | null
    surface?: number | null
    env_delimiter?: env_delimiterUncheckedCreateNestedManyWithoutEnvironmentInput
    env_user?: env_userUncheckedCreateNestedManyWithoutEnvironmentInput
    zone?: zoneUncheckedCreateNestedManyWithoutEnvironmentInput
  }

  export type environmentCreateOrConnectWithoutPoiInput = {
    where: environmentWhereUniqueInput
    create: XOR<environmentCreateWithoutPoiInput, environmentUncheckedCreateWithoutPoiInput>
  }

  export type mapCreateWithoutPoiInput = {
    created_at?: Date | string
    environment?: environmentCreateNestedManyWithoutMapInput
    format?: formatCreateNestedOneWithoutMapInput
    zone?: zoneCreateNestedManyWithoutMapInput
  }

  export type mapUncheckedCreateWithoutPoiInput = {
    id?: number
    created_at?: Date | string
    format_id?: number | null
    environment?: environmentUncheckedCreateNestedManyWithoutMapInput
    zone?: zoneUncheckedCreateNestedManyWithoutMapInput
  }

  export type mapCreateOrConnectWithoutPoiInput = {
    where: mapWhereUniqueInput
    create: XOR<mapCreateWithoutPoiInput, mapUncheckedCreateWithoutPoiInput>
  }

  export type poi_zoneCreateWithoutPoiInput = {
    created_at?: Date | string
    zone?: zoneCreateNestedOneWithoutPoi_zoneInput
  }

  export type poi_zoneUncheckedCreateWithoutPoiInput = {
    id?: number
    created_at?: Date | string
    zone_id?: number | null
  }

  export type poi_zoneCreateOrConnectWithoutPoiInput = {
    where: poi_zoneWhereUniqueInput
    create: XOR<poi_zoneCreateWithoutPoiInput, poi_zoneUncheckedCreateWithoutPoiInput>
  }

  export type poi_zoneCreateManyPoiInputEnvelope = {
    data: poi_zoneCreateManyPoiInput | poi_zoneCreateManyPoiInput[]
    skipDuplicates?: boolean
  }

  export type poi_categoryUpsertWithoutPoiInput = {
    update: XOR<poi_categoryUpdateWithoutPoiInput, poi_categoryUncheckedUpdateWithoutPoiInput>
    create: XOR<poi_categoryCreateWithoutPoiInput, poi_categoryUncheckedCreateWithoutPoiInput>
    where?: poi_categoryWhereInput
  }

  export type poi_categoryUpdateToOneWithWhereWithoutPoiInput = {
    where?: poi_categoryWhereInput
    data: XOR<poi_categoryUpdateWithoutPoiInput, poi_categoryUncheckedUpdateWithoutPoiInput>
  }

  export type poi_categoryUpdateWithoutPoiInput = {
    category?: StringFieldUpdateOperationsInput | string
  }

  export type poi_categoryUncheckedUpdateWithoutPoiInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type environmentUpsertWithoutPoiInput = {
    update: XOR<environmentUpdateWithoutPoiInput, environmentUncheckedUpdateWithoutPoiInput>
    create: XOR<environmentCreateWithoutPoiInput, environmentUncheckedCreateWithoutPoiInput>
    where?: environmentWhereInput
  }

  export type environmentUpdateToOneWithWhereWithoutPoiInput = {
    where?: environmentWhereInput
    data: XOR<environmentUpdateWithoutPoiInput, environmentUncheckedUpdateWithoutPoiInput>
  }

  export type environmentUpdateWithoutPoiInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    env_delimiter?: env_delimiterUpdateManyWithoutEnvironmentNestedInput
    env_user?: env_userUpdateManyWithoutEnvironmentNestedInput
    map?: mapUpdateOneWithoutEnvironmentNestedInput
    zone?: zoneUpdateManyWithoutEnvironmentNestedInput
  }

  export type environmentUncheckedUpdateWithoutPoiInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    env_delimiter?: env_delimiterUncheckedUpdateManyWithoutEnvironmentNestedInput
    env_user?: env_userUncheckedUpdateManyWithoutEnvironmentNestedInput
    zone?: zoneUncheckedUpdateManyWithoutEnvironmentNestedInput
  }

  export type mapUpsertWithoutPoiInput = {
    update: XOR<mapUpdateWithoutPoiInput, mapUncheckedUpdateWithoutPoiInput>
    create: XOR<mapCreateWithoutPoiInput, mapUncheckedCreateWithoutPoiInput>
    where?: mapWhereInput
  }

  export type mapUpdateToOneWithWhereWithoutPoiInput = {
    where?: mapWhereInput
    data: XOR<mapUpdateWithoutPoiInput, mapUncheckedUpdateWithoutPoiInput>
  }

  export type mapUpdateWithoutPoiInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: environmentUpdateManyWithoutMapNestedInput
    format?: formatUpdateOneWithoutMapNestedInput
    zone?: zoneUpdateManyWithoutMapNestedInput
  }

  export type mapUncheckedUpdateWithoutPoiInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    format_id?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: environmentUncheckedUpdateManyWithoutMapNestedInput
    zone?: zoneUncheckedUpdateManyWithoutMapNestedInput
  }

  export type poi_zoneUpsertWithWhereUniqueWithoutPoiInput = {
    where: poi_zoneWhereUniqueInput
    update: XOR<poi_zoneUpdateWithoutPoiInput, poi_zoneUncheckedUpdateWithoutPoiInput>
    create: XOR<poi_zoneCreateWithoutPoiInput, poi_zoneUncheckedCreateWithoutPoiInput>
  }

  export type poi_zoneUpdateWithWhereUniqueWithoutPoiInput = {
    where: poi_zoneWhereUniqueInput
    data: XOR<poi_zoneUpdateWithoutPoiInput, poi_zoneUncheckedUpdateWithoutPoiInput>
  }

  export type poi_zoneUpdateManyWithWhereWithoutPoiInput = {
    where: poi_zoneScalarWhereInput
    data: XOR<poi_zoneUpdateManyMutationInput, poi_zoneUncheckedUpdateManyWithoutPoiInput>
  }

  export type poi_zoneScalarWhereInput = {
    AND?: poi_zoneScalarWhereInput | poi_zoneScalarWhereInput[]
    OR?: poi_zoneScalarWhereInput[]
    NOT?: poi_zoneScalarWhereInput | poi_zoneScalarWhereInput[]
    id?: IntFilter<"poi_zone"> | number
    created_at?: DateTimeFilter<"poi_zone"> | Date | string
    poi_id?: IntNullableFilter<"poi_zone"> | number | null
    zone_id?: IntNullableFilter<"poi_zone"> | number | null
  }

  export type poiCreateWithoutPoi_categoryInput = {
    created_at?: Date | string
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: string | null
    environment?: environmentCreateNestedOneWithoutPoiInput
    map?: mapCreateNestedOneWithoutPoiInput
    poi_zone?: poi_zoneCreateNestedManyWithoutPoiInput
  }

  export type poiUncheckedCreateWithoutPoi_categoryInput = {
    id?: number
    created_at?: Date | string
    env_id?: number | null
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: string | null
    map_id?: number | null
    poi_zone?: poi_zoneUncheckedCreateNestedManyWithoutPoiInput
  }

  export type poiCreateOrConnectWithoutPoi_categoryInput = {
    where: poiWhereUniqueInput
    create: XOR<poiCreateWithoutPoi_categoryInput, poiUncheckedCreateWithoutPoi_categoryInput>
  }

  export type poiCreateManyPoi_categoryInputEnvelope = {
    data: poiCreateManyPoi_categoryInput | poiCreateManyPoi_categoryInput[]
    skipDuplicates?: boolean
  }

  export type poiUpsertWithWhereUniqueWithoutPoi_categoryInput = {
    where: poiWhereUniqueInput
    update: XOR<poiUpdateWithoutPoi_categoryInput, poiUncheckedUpdateWithoutPoi_categoryInput>
    create: XOR<poiCreateWithoutPoi_categoryInput, poiUncheckedCreateWithoutPoi_categoryInput>
  }

  export type poiUpdateWithWhereUniqueWithoutPoi_categoryInput = {
    where: poiWhereUniqueInput
    data: XOR<poiUpdateWithoutPoi_categoryInput, poiUncheckedUpdateWithoutPoi_categoryInput>
  }

  export type poiUpdateManyWithWhereWithoutPoi_categoryInput = {
    where: poiScalarWhereInput
    data: XOR<poiUpdateManyMutationInput, poiUncheckedUpdateManyWithoutPoi_categoryInput>
  }

  export type poiCreateWithoutPoi_zoneInput = {
    created_at?: Date | string
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: string | null
    poi_category?: poi_categoryCreateNestedOneWithoutPoiInput
    environment?: environmentCreateNestedOneWithoutPoiInput
    map?: mapCreateNestedOneWithoutPoiInput
  }

  export type poiUncheckedCreateWithoutPoi_zoneInput = {
    id?: number
    created_at?: Date | string
    env_id?: number | null
    category_id?: number | null
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: string | null
    map_id?: number | null
  }

  export type poiCreateOrConnectWithoutPoi_zoneInput = {
    where: poiWhereUniqueInput
    create: XOR<poiCreateWithoutPoi_zoneInput, poiUncheckedCreateWithoutPoi_zoneInput>
  }

  export type zoneCreateWithoutPoi_zoneInput = {
    created_at?: Date | string
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: Date | string | null
    environment?: environmentCreateNestedOneWithoutZoneInput
    map?: mapCreateNestedOneWithoutZoneInput
    zone_type_zone_type_idTozone_type?: zone_typeCreateNestedOneWithoutZone_zone_type_idTozone_typeInput
    zone_type_zone_zone_typeTozone_type?: zone_typeCreateNestedOneWithoutZone_zone_zone_typeTozone_typeInput
  }

  export type zoneUncheckedCreateWithoutPoi_zoneInput = {
    id?: number
    created_at?: Date | string
    env_id?: number | null
    name?: string | null
    description?: string | null
    type_id?: number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: Date | string | null
    map_id?: number | null
    zone_type?: number | null
  }

  export type zoneCreateOrConnectWithoutPoi_zoneInput = {
    where: zoneWhereUniqueInput
    create: XOR<zoneCreateWithoutPoi_zoneInput, zoneUncheckedCreateWithoutPoi_zoneInput>
  }

  export type poiUpsertWithoutPoi_zoneInput = {
    update: XOR<poiUpdateWithoutPoi_zoneInput, poiUncheckedUpdateWithoutPoi_zoneInput>
    create: XOR<poiCreateWithoutPoi_zoneInput, poiUncheckedCreateWithoutPoi_zoneInput>
    where?: poiWhereInput
  }

  export type poiUpdateToOneWithWhereWithoutPoi_zoneInput = {
    where?: poiWhereInput
    data: XOR<poiUpdateWithoutPoi_zoneInput, poiUncheckedUpdateWithoutPoi_zoneInput>
  }

  export type poiUpdateWithoutPoi_zoneInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    poi_category?: poi_categoryUpdateOneWithoutPoiNestedInput
    environment?: environmentUpdateOneWithoutPoiNestedInput
    map?: mapUpdateOneWithoutPoiNestedInput
  }

  export type poiUncheckedUpdateWithoutPoi_zoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type zoneUpsertWithoutPoi_zoneInput = {
    update: XOR<zoneUpdateWithoutPoi_zoneInput, zoneUncheckedUpdateWithoutPoi_zoneInput>
    create: XOR<zoneCreateWithoutPoi_zoneInput, zoneUncheckedCreateWithoutPoi_zoneInput>
    where?: zoneWhereInput
  }

  export type zoneUpdateToOneWithWhereWithoutPoi_zoneInput = {
    where?: zoneWhereInput
    data: XOR<zoneUpdateWithoutPoi_zoneInput, zoneUncheckedUpdateWithoutPoi_zoneInput>
  }

  export type zoneUpdateWithoutPoi_zoneInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    environment?: environmentUpdateOneWithoutZoneNestedInput
    map?: mapUpdateOneWithoutZoneNestedInput
    zone_type_zone_type_idTozone_type?: zone_typeUpdateOneWithoutZone_zone_type_idTozone_typeNestedInput
    zone_type_zone_zone_typeTozone_type?: zone_typeUpdateOneWithoutZone_zone_zone_typeTozone_typeNestedInput
  }

  export type zoneUncheckedUpdateWithoutPoi_zoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_type?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type deviceCreateWithoutPurchase_historyInput = {
    mac_address: string
    software_version: string
    date_of_service: Date | string
    comm_state: boolean
    connection_state?: boolean | null
    battery_capacity?: number
    price?: number | null
    alert?: alertCreateNestedManyWithoutDeviceInput
    state_type: state_typeCreateNestedOneWithoutDeviceInput
    device_type: device_typeCreateNestedOneWithoutDeviceInput
    user?: userCreateNestedOneWithoutDeviceInput
  }

  export type deviceUncheckedCreateWithoutPurchase_historyInput = {
    id?: number
    type_id: number
    state_type_id: number
    user_id?: number | null
    mac_address: string
    software_version: string
    date_of_service: Date | string
    comm_state: boolean
    connection_state?: boolean | null
    battery_capacity?: number
    price?: number | null
    alert?: alertUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type deviceCreateOrConnectWithoutPurchase_historyInput = {
    where: deviceWhereUniqueInput
    create: XOR<deviceCreateWithoutPurchase_historyInput, deviceUncheckedCreateWithoutPurchase_historyInput>
  }

  export type userCreateWithoutPurchase_historyInput = {
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    device?: deviceCreateNestedManyWithoutUserInput
    env_user?: env_userCreateNestedManyWithoutUserInput
    helper_user_helper_user_helper_idTouser?: helper_userCreateNestedManyWithoutUser_helper_user_helper_idTouserInput
    helper_user_helper_user_user_idTouser?: helper_userCreateNestedManyWithoutUser_helper_user_user_idTouserInput
    intervention_history?: intervention_historyCreateNestedManyWithoutUserInput
    localisation?: localisationCreateNestedOneWithoutUserInput
    user_type?: user_typeCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutPurchase_historyInput = {
    id?: number
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    userTypeId?: number | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    device?: deviceUncheckedCreateNestedManyWithoutUserInput
    env_user?: env_userUncheckedCreateNestedManyWithoutUserInput
    helper_user_helper_user_helper_idTouser?: helper_userUncheckedCreateNestedManyWithoutUser_helper_user_helper_idTouserInput
    helper_user_helper_user_user_idTouser?: helper_userUncheckedCreateNestedManyWithoutUser_helper_user_user_idTouserInput
    intervention_history?: intervention_historyUncheckedCreateNestedManyWithoutUserInput
    localisation?: localisationUncheckedCreateNestedOneWithoutUserInput
  }

  export type userCreateOrConnectWithoutPurchase_historyInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPurchase_historyInput, userUncheckedCreateWithoutPurchase_historyInput>
  }

  export type deviceUpsertWithoutPurchase_historyInput = {
    update: XOR<deviceUpdateWithoutPurchase_historyInput, deviceUncheckedUpdateWithoutPurchase_historyInput>
    create: XOR<deviceCreateWithoutPurchase_historyInput, deviceUncheckedCreateWithoutPurchase_historyInput>
    where?: deviceWhereInput
  }

  export type deviceUpdateToOneWithWhereWithoutPurchase_historyInput = {
    where?: deviceWhereInput
    data: XOR<deviceUpdateWithoutPurchase_historyInput, deviceUncheckedUpdateWithoutPurchase_historyInput>
  }

  export type deviceUpdateWithoutPurchase_historyInput = {
    mac_address?: StringFieldUpdateOperationsInput | string
    software_version?: StringFieldUpdateOperationsInput | string
    date_of_service?: DateTimeFieldUpdateOperationsInput | Date | string
    comm_state?: BoolFieldUpdateOperationsInput | boolean
    connection_state?: NullableBoolFieldUpdateOperationsInput | boolean | null
    battery_capacity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    alert?: alertUpdateManyWithoutDeviceNestedInput
    state_type?: state_typeUpdateOneRequiredWithoutDeviceNestedInput
    device_type?: device_typeUpdateOneRequiredWithoutDeviceNestedInput
    user?: userUpdateOneWithoutDeviceNestedInput
  }

  export type deviceUncheckedUpdateWithoutPurchase_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    state_type_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    mac_address?: StringFieldUpdateOperationsInput | string
    software_version?: StringFieldUpdateOperationsInput | string
    date_of_service?: DateTimeFieldUpdateOperationsInput | Date | string
    comm_state?: BoolFieldUpdateOperationsInput | boolean
    connection_state?: NullableBoolFieldUpdateOperationsInput | boolean | null
    battery_capacity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    alert?: alertUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type userUpsertWithoutPurchase_historyInput = {
    update: XOR<userUpdateWithoutPurchase_historyInput, userUncheckedUpdateWithoutPurchase_historyInput>
    create: XOR<userCreateWithoutPurchase_historyInput, userUncheckedCreateWithoutPurchase_historyInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPurchase_historyInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPurchase_historyInput, userUncheckedUpdateWithoutPurchase_historyInput>
  }

  export type userUpdateWithoutPurchase_historyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    device?: deviceUpdateManyWithoutUserNestedInput
    env_user?: env_userUpdateManyWithoutUserNestedInput
    helper_user_helper_user_helper_idTouser?: helper_userUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput
    helper_user_helper_user_user_idTouser?: helper_userUpdateManyWithoutUser_helper_user_user_idTouserNestedInput
    intervention_history?: intervention_historyUpdateManyWithoutUserNestedInput
    localisation?: localisationUpdateOneWithoutUserNestedInput
    user_type?: user_typeUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPurchase_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    userTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    device?: deviceUncheckedUpdateManyWithoutUserNestedInput
    env_user?: env_userUncheckedUpdateManyWithoutUserNestedInput
    helper_user_helper_user_helper_idTouser?: helper_userUncheckedUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput
    helper_user_helper_user_user_idTouser?: helper_userUncheckedUpdateManyWithoutUser_helper_user_user_idTouserNestedInput
    intervention_history?: intervention_historyUncheckedUpdateManyWithoutUserNestedInput
    localisation?: localisationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type deviceCreateWithoutState_typeInput = {
    mac_address: string
    software_version: string
    date_of_service: Date | string
    comm_state: boolean
    connection_state?: boolean | null
    battery_capacity?: number
    price?: number | null
    alert?: alertCreateNestedManyWithoutDeviceInput
    device_type: device_typeCreateNestedOneWithoutDeviceInput
    user?: userCreateNestedOneWithoutDeviceInput
    purchase_history?: purchase_historyCreateNestedManyWithoutDeviceInput
  }

  export type deviceUncheckedCreateWithoutState_typeInput = {
    id?: number
    type_id: number
    user_id?: number | null
    mac_address: string
    software_version: string
    date_of_service: Date | string
    comm_state: boolean
    connection_state?: boolean | null
    battery_capacity?: number
    price?: number | null
    alert?: alertUncheckedCreateNestedManyWithoutDeviceInput
    purchase_history?: purchase_historyUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type deviceCreateOrConnectWithoutState_typeInput = {
    where: deviceWhereUniqueInput
    create: XOR<deviceCreateWithoutState_typeInput, deviceUncheckedCreateWithoutState_typeInput>
  }

  export type deviceCreateManyState_typeInputEnvelope = {
    data: deviceCreateManyState_typeInput | deviceCreateManyState_typeInput[]
    skipDuplicates?: boolean
  }

  export type deviceUpsertWithWhereUniqueWithoutState_typeInput = {
    where: deviceWhereUniqueInput
    update: XOR<deviceUpdateWithoutState_typeInput, deviceUncheckedUpdateWithoutState_typeInput>
    create: XOR<deviceCreateWithoutState_typeInput, deviceUncheckedCreateWithoutState_typeInput>
  }

  export type deviceUpdateWithWhereUniqueWithoutState_typeInput = {
    where: deviceWhereUniqueInput
    data: XOR<deviceUpdateWithoutState_typeInput, deviceUncheckedUpdateWithoutState_typeInput>
  }

  export type deviceUpdateManyWithWhereWithoutState_typeInput = {
    where: deviceScalarWhereInput
    data: XOR<deviceUpdateManyMutationInput, deviceUncheckedUpdateManyWithoutState_typeInput>
  }

  export type deviceCreateWithoutUserInput = {
    mac_address: string
    software_version: string
    date_of_service: Date | string
    comm_state: boolean
    connection_state?: boolean | null
    battery_capacity?: number
    price?: number | null
    alert?: alertCreateNestedManyWithoutDeviceInput
    state_type: state_typeCreateNestedOneWithoutDeviceInput
    device_type: device_typeCreateNestedOneWithoutDeviceInput
    purchase_history?: purchase_historyCreateNestedManyWithoutDeviceInput
  }

  export type deviceUncheckedCreateWithoutUserInput = {
    id?: number
    type_id: number
    state_type_id: number
    mac_address: string
    software_version: string
    date_of_service: Date | string
    comm_state: boolean
    connection_state?: boolean | null
    battery_capacity?: number
    price?: number | null
    alert?: alertUncheckedCreateNestedManyWithoutDeviceInput
    purchase_history?: purchase_historyUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type deviceCreateOrConnectWithoutUserInput = {
    where: deviceWhereUniqueInput
    create: XOR<deviceCreateWithoutUserInput, deviceUncheckedCreateWithoutUserInput>
  }

  export type deviceCreateManyUserInputEnvelope = {
    data: deviceCreateManyUserInput | deviceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type env_userCreateWithoutUserInput = {
    environment?: environmentCreateNestedOneWithoutEnv_userInput
  }

  export type env_userUncheckedCreateWithoutUserInput = {
    id?: number
    env_id?: number | null
  }

  export type env_userCreateOrConnectWithoutUserInput = {
    where: env_userWhereUniqueInput
    create: XOR<env_userCreateWithoutUserInput, env_userUncheckedCreateWithoutUserInput>
  }

  export type env_userCreateManyUserInputEnvelope = {
    data: env_userCreateManyUserInput | env_userCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type helper_userCreateWithoutUser_helper_user_helper_idTouserInput = {
    state?: string | null
    user_helper_user_user_idTouser?: userCreateNestedOneWithoutHelper_user_helper_user_user_idTouserInput
  }

  export type helper_userUncheckedCreateWithoutUser_helper_user_helper_idTouserInput = {
    id?: number
    user_id?: number | null
    state?: string | null
  }

  export type helper_userCreateOrConnectWithoutUser_helper_user_helper_idTouserInput = {
    where: helper_userWhereUniqueInput
    create: XOR<helper_userCreateWithoutUser_helper_user_helper_idTouserInput, helper_userUncheckedCreateWithoutUser_helper_user_helper_idTouserInput>
  }

  export type helper_userCreateManyUser_helper_user_helper_idTouserInputEnvelope = {
    data: helper_userCreateManyUser_helper_user_helper_idTouserInput | helper_userCreateManyUser_helper_user_helper_idTouserInput[]
    skipDuplicates?: boolean
  }

  export type helper_userCreateWithoutUser_helper_user_user_idTouserInput = {
    state?: string | null
    user_helper_user_helper_idTouser?: userCreateNestedOneWithoutHelper_user_helper_user_helper_idTouserInput
  }

  export type helper_userUncheckedCreateWithoutUser_helper_user_user_idTouserInput = {
    id?: number
    helper_id?: number | null
    state?: string | null
  }

  export type helper_userCreateOrConnectWithoutUser_helper_user_user_idTouserInput = {
    where: helper_userWhereUniqueInput
    create: XOR<helper_userCreateWithoutUser_helper_user_user_idTouserInput, helper_userUncheckedCreateWithoutUser_helper_user_user_idTouserInput>
  }

  export type helper_userCreateManyUser_helper_user_user_idTouserInputEnvelope = {
    data: helper_userCreateManyUser_helper_user_user_idTouserInput | helper_userCreateManyUser_helper_user_user_idTouserInput[]
    skipDuplicates?: boolean
  }

  export type intervention_historyCreateWithoutUserInput = {
    device_id?: number | null
    scheduled_date: Date | string
    completion_date?: Date | string | null
    description?: string | null
    status?: string | null
    type?: $Enums.intervention_type | null
    title?: string | null
    location?: string | null
  }

  export type intervention_historyUncheckedCreateWithoutUserInput = {
    id?: number
    device_id?: number | null
    scheduled_date: Date | string
    completion_date?: Date | string | null
    description?: string | null
    status?: string | null
    type?: $Enums.intervention_type | null
    title?: string | null
    location?: string | null
  }

  export type intervention_historyCreateOrConnectWithoutUserInput = {
    where: intervention_historyWhereUniqueInput
    create: XOR<intervention_historyCreateWithoutUserInput, intervention_historyUncheckedCreateWithoutUserInput>
  }

  export type intervention_historyCreateManyUserInputEnvelope = {
    data: intervention_historyCreateManyUserInput | intervention_historyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type localisationCreateWithoutUserInput = {
    longitude: string
    latitude: string
    updated_at?: Date | string
  }

  export type localisationUncheckedCreateWithoutUserInput = {
    id?: number
    longitude: string
    latitude: string
    updated_at?: Date | string
  }

  export type localisationCreateOrConnectWithoutUserInput = {
    where: localisationWhereUniqueInput
    create: XOR<localisationCreateWithoutUserInput, localisationUncheckedCreateWithoutUserInput>
  }

  export type purchase_historyCreateWithoutUserInput = {
    date?: Date | string
    public?: boolean | null
    device?: deviceCreateNestedOneWithoutPurchase_historyInput
  }

  export type purchase_historyUncheckedCreateWithoutUserInput = {
    id?: number
    date?: Date | string
    device_id?: number | null
    public?: boolean | null
  }

  export type purchase_historyCreateOrConnectWithoutUserInput = {
    where: purchase_historyWhereUniqueInput
    create: XOR<purchase_historyCreateWithoutUserInput, purchase_historyUncheckedCreateWithoutUserInput>
  }

  export type purchase_historyCreateManyUserInputEnvelope = {
    data: purchase_historyCreateManyUserInput | purchase_historyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type user_typeCreateWithoutUserInput = {
    created_at?: Date | string
    type?: string | null
  }

  export type user_typeUncheckedCreateWithoutUserInput = {
    id?: number
    created_at?: Date | string
    type?: string | null
  }

  export type user_typeCreateOrConnectWithoutUserInput = {
    where: user_typeWhereUniqueInput
    create: XOR<user_typeCreateWithoutUserInput, user_typeUncheckedCreateWithoutUserInput>
  }

  export type deviceUpsertWithWhereUniqueWithoutUserInput = {
    where: deviceWhereUniqueInput
    update: XOR<deviceUpdateWithoutUserInput, deviceUncheckedUpdateWithoutUserInput>
    create: XOR<deviceCreateWithoutUserInput, deviceUncheckedCreateWithoutUserInput>
  }

  export type deviceUpdateWithWhereUniqueWithoutUserInput = {
    where: deviceWhereUniqueInput
    data: XOR<deviceUpdateWithoutUserInput, deviceUncheckedUpdateWithoutUserInput>
  }

  export type deviceUpdateManyWithWhereWithoutUserInput = {
    where: deviceScalarWhereInput
    data: XOR<deviceUpdateManyMutationInput, deviceUncheckedUpdateManyWithoutUserInput>
  }

  export type env_userUpsertWithWhereUniqueWithoutUserInput = {
    where: env_userWhereUniqueInput
    update: XOR<env_userUpdateWithoutUserInput, env_userUncheckedUpdateWithoutUserInput>
    create: XOR<env_userCreateWithoutUserInput, env_userUncheckedCreateWithoutUserInput>
  }

  export type env_userUpdateWithWhereUniqueWithoutUserInput = {
    where: env_userWhereUniqueInput
    data: XOR<env_userUpdateWithoutUserInput, env_userUncheckedUpdateWithoutUserInput>
  }

  export type env_userUpdateManyWithWhereWithoutUserInput = {
    where: env_userScalarWhereInput
    data: XOR<env_userUpdateManyMutationInput, env_userUncheckedUpdateManyWithoutUserInput>
  }

  export type helper_userUpsertWithWhereUniqueWithoutUser_helper_user_helper_idTouserInput = {
    where: helper_userWhereUniqueInput
    update: XOR<helper_userUpdateWithoutUser_helper_user_helper_idTouserInput, helper_userUncheckedUpdateWithoutUser_helper_user_helper_idTouserInput>
    create: XOR<helper_userCreateWithoutUser_helper_user_helper_idTouserInput, helper_userUncheckedCreateWithoutUser_helper_user_helper_idTouserInput>
  }

  export type helper_userUpdateWithWhereUniqueWithoutUser_helper_user_helper_idTouserInput = {
    where: helper_userWhereUniqueInput
    data: XOR<helper_userUpdateWithoutUser_helper_user_helper_idTouserInput, helper_userUncheckedUpdateWithoutUser_helper_user_helper_idTouserInput>
  }

  export type helper_userUpdateManyWithWhereWithoutUser_helper_user_helper_idTouserInput = {
    where: helper_userScalarWhereInput
    data: XOR<helper_userUpdateManyMutationInput, helper_userUncheckedUpdateManyWithoutUser_helper_user_helper_idTouserInput>
  }

  export type helper_userScalarWhereInput = {
    AND?: helper_userScalarWhereInput | helper_userScalarWhereInput[]
    OR?: helper_userScalarWhereInput[]
    NOT?: helper_userScalarWhereInput | helper_userScalarWhereInput[]
    id?: IntFilter<"helper_user"> | number
    user_id?: IntNullableFilter<"helper_user"> | number | null
    helper_id?: IntNullableFilter<"helper_user"> | number | null
    state?: StringNullableFilter<"helper_user"> | string | null
  }

  export type helper_userUpsertWithWhereUniqueWithoutUser_helper_user_user_idTouserInput = {
    where: helper_userWhereUniqueInput
    update: XOR<helper_userUpdateWithoutUser_helper_user_user_idTouserInput, helper_userUncheckedUpdateWithoutUser_helper_user_user_idTouserInput>
    create: XOR<helper_userCreateWithoutUser_helper_user_user_idTouserInput, helper_userUncheckedCreateWithoutUser_helper_user_user_idTouserInput>
  }

  export type helper_userUpdateWithWhereUniqueWithoutUser_helper_user_user_idTouserInput = {
    where: helper_userWhereUniqueInput
    data: XOR<helper_userUpdateWithoutUser_helper_user_user_idTouserInput, helper_userUncheckedUpdateWithoutUser_helper_user_user_idTouserInput>
  }

  export type helper_userUpdateManyWithWhereWithoutUser_helper_user_user_idTouserInput = {
    where: helper_userScalarWhereInput
    data: XOR<helper_userUpdateManyMutationInput, helper_userUncheckedUpdateManyWithoutUser_helper_user_user_idTouserInput>
  }

  export type intervention_historyUpsertWithWhereUniqueWithoutUserInput = {
    where: intervention_historyWhereUniqueInput
    update: XOR<intervention_historyUpdateWithoutUserInput, intervention_historyUncheckedUpdateWithoutUserInput>
    create: XOR<intervention_historyCreateWithoutUserInput, intervention_historyUncheckedCreateWithoutUserInput>
  }

  export type intervention_historyUpdateWithWhereUniqueWithoutUserInput = {
    where: intervention_historyWhereUniqueInput
    data: XOR<intervention_historyUpdateWithoutUserInput, intervention_historyUncheckedUpdateWithoutUserInput>
  }

  export type intervention_historyUpdateManyWithWhereWithoutUserInput = {
    where: intervention_historyScalarWhereInput
    data: XOR<intervention_historyUpdateManyMutationInput, intervention_historyUncheckedUpdateManyWithoutUserInput>
  }

  export type intervention_historyScalarWhereInput = {
    AND?: intervention_historyScalarWhereInput | intervention_historyScalarWhereInput[]
    OR?: intervention_historyScalarWhereInput[]
    NOT?: intervention_historyScalarWhereInput | intervention_historyScalarWhereInput[]
    id?: IntFilter<"intervention_history"> | number
    device_id?: IntNullableFilter<"intervention_history"> | number | null
    maintenancier_id?: IntNullableFilter<"intervention_history"> | number | null
    scheduled_date?: DateTimeFilter<"intervention_history"> | Date | string
    completion_date?: DateTimeNullableFilter<"intervention_history"> | Date | string | null
    description?: StringNullableFilter<"intervention_history"> | string | null
    status?: StringNullableFilter<"intervention_history"> | string | null
    type?: Enumintervention_typeNullableFilter<"intervention_history"> | $Enums.intervention_type | null
    title?: StringNullableFilter<"intervention_history"> | string | null
    location?: StringNullableFilter<"intervention_history"> | string | null
  }

  export type localisationUpsertWithoutUserInput = {
    update: XOR<localisationUpdateWithoutUserInput, localisationUncheckedUpdateWithoutUserInput>
    create: XOR<localisationCreateWithoutUserInput, localisationUncheckedCreateWithoutUserInput>
    where?: localisationWhereInput
  }

  export type localisationUpdateToOneWithWhereWithoutUserInput = {
    where?: localisationWhereInput
    data: XOR<localisationUpdateWithoutUserInput, localisationUncheckedUpdateWithoutUserInput>
  }

  export type localisationUpdateWithoutUserInput = {
    longitude?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type localisationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    longitude?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchase_historyUpsertWithWhereUniqueWithoutUserInput = {
    where: purchase_historyWhereUniqueInput
    update: XOR<purchase_historyUpdateWithoutUserInput, purchase_historyUncheckedUpdateWithoutUserInput>
    create: XOR<purchase_historyCreateWithoutUserInput, purchase_historyUncheckedCreateWithoutUserInput>
  }

  export type purchase_historyUpdateWithWhereUniqueWithoutUserInput = {
    where: purchase_historyWhereUniqueInput
    data: XOR<purchase_historyUpdateWithoutUserInput, purchase_historyUncheckedUpdateWithoutUserInput>
  }

  export type purchase_historyUpdateManyWithWhereWithoutUserInput = {
    where: purchase_historyScalarWhereInput
    data: XOR<purchase_historyUpdateManyMutationInput, purchase_historyUncheckedUpdateManyWithoutUserInput>
  }

  export type user_typeUpsertWithoutUserInput = {
    update: XOR<user_typeUpdateWithoutUserInput, user_typeUncheckedUpdateWithoutUserInput>
    create: XOR<user_typeCreateWithoutUserInput, user_typeUncheckedCreateWithoutUserInput>
    where?: user_typeWhereInput
  }

  export type user_typeUpdateToOneWithWhereWithoutUserInput = {
    where?: user_typeWhereInput
    data: XOR<user_typeUpdateWithoutUserInput, user_typeUncheckedUpdateWithoutUserInput>
  }

  export type user_typeUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_typeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userCreateWithoutUser_typeInput = {
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    device?: deviceCreateNestedManyWithoutUserInput
    env_user?: env_userCreateNestedManyWithoutUserInput
    helper_user_helper_user_helper_idTouser?: helper_userCreateNestedManyWithoutUser_helper_user_helper_idTouserInput
    helper_user_helper_user_user_idTouser?: helper_userCreateNestedManyWithoutUser_helper_user_user_idTouserInput
    intervention_history?: intervention_historyCreateNestedManyWithoutUserInput
    localisation?: localisationCreateNestedOneWithoutUserInput
    purchase_history?: purchase_historyCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUser_typeInput = {
    id?: number
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
    device?: deviceUncheckedCreateNestedManyWithoutUserInput
    env_user?: env_userUncheckedCreateNestedManyWithoutUserInput
    helper_user_helper_user_helper_idTouser?: helper_userUncheckedCreateNestedManyWithoutUser_helper_user_helper_idTouserInput
    helper_user_helper_user_user_idTouser?: helper_userUncheckedCreateNestedManyWithoutUser_helper_user_user_idTouserInput
    intervention_history?: intervention_historyUncheckedCreateNestedManyWithoutUserInput
    localisation?: localisationUncheckedCreateNestedOneWithoutUserInput
    purchase_history?: purchase_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUser_typeInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUser_typeInput, userUncheckedCreateWithoutUser_typeInput>
  }

  export type userCreateManyUser_typeInputEnvelope = {
    data: userCreateManyUser_typeInput | userCreateManyUser_typeInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithWhereUniqueWithoutUser_typeInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutUser_typeInput, userUncheckedUpdateWithoutUser_typeInput>
    create: XOR<userCreateWithoutUser_typeInput, userUncheckedCreateWithoutUser_typeInput>
  }

  export type userUpdateWithWhereUniqueWithoutUser_typeInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutUser_typeInput, userUncheckedUpdateWithoutUser_typeInput>
  }

  export type userUpdateManyWithWhereWithoutUser_typeInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutUser_typeInput>
  }

  export type userScalarWhereInput = {
    AND?: userScalarWhereInput | userScalarWhereInput[]
    OR?: userScalarWhereInput[]
    NOT?: userScalarWhereInput | userScalarWhereInput[]
    id?: IntFilter<"user"> | number
    created_at?: DateTimeFilter<"user"> | Date | string
    family_name?: StringNullableFilter<"user"> | string | null
    first_name?: StringNullableFilter<"user"> | string | null
    phone_number?: StringNullableFilter<"user"> | string | null
    password?: StringNullableFilter<"user"> | string | null
    userTypeId?: IntNullableFilter<"user"> | number | null
    email?: StringNullableFilter<"user"> | string | null
    sex?: StringNullableFilter<"user"> | string | null
    street?: StringNullableFilter<"user"> | string | null
    city?: StringNullableFilter<"user"> | string | null
    birth_date?: DateTimeNullableFilter<"user"> | Date | string | null
    Identifier?: StringNullableFilter<"user"> | string | null
  }

  export type poi_zoneCreateWithoutZoneInput = {
    created_at?: Date | string
    poi?: poiCreateNestedOneWithoutPoi_zoneInput
  }

  export type poi_zoneUncheckedCreateWithoutZoneInput = {
    id?: number
    created_at?: Date | string
    poi_id?: number | null
  }

  export type poi_zoneCreateOrConnectWithoutZoneInput = {
    where: poi_zoneWhereUniqueInput
    create: XOR<poi_zoneCreateWithoutZoneInput, poi_zoneUncheckedCreateWithoutZoneInput>
  }

  export type poi_zoneCreateManyZoneInputEnvelope = {
    data: poi_zoneCreateManyZoneInput | poi_zoneCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type environmentCreateWithoutZoneInput = {
    name: string
    description?: string | null
    address?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_public?: boolean | null
    surface?: number | null
    env_delimiter?: env_delimiterCreateNestedManyWithoutEnvironmentInput
    env_user?: env_userCreateNestedManyWithoutEnvironmentInput
    map?: mapCreateNestedOneWithoutEnvironmentInput
    poi?: poiCreateNestedManyWithoutEnvironmentInput
  }

  export type environmentUncheckedCreateWithoutZoneInput = {
    id?: number
    name: string
    description?: string | null
    address?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    map_id?: number | null
    is_public?: boolean | null
    surface?: number | null
    env_delimiter?: env_delimiterUncheckedCreateNestedManyWithoutEnvironmentInput
    env_user?: env_userUncheckedCreateNestedManyWithoutEnvironmentInput
    poi?: poiUncheckedCreateNestedManyWithoutEnvironmentInput
  }

  export type environmentCreateOrConnectWithoutZoneInput = {
    where: environmentWhereUniqueInput
    create: XOR<environmentCreateWithoutZoneInput, environmentUncheckedCreateWithoutZoneInput>
  }

  export type mapCreateWithoutZoneInput = {
    created_at?: Date | string
    environment?: environmentCreateNestedManyWithoutMapInput
    format?: formatCreateNestedOneWithoutMapInput
    poi?: poiCreateNestedManyWithoutMapInput
  }

  export type mapUncheckedCreateWithoutZoneInput = {
    id?: number
    created_at?: Date | string
    format_id?: number | null
    environment?: environmentUncheckedCreateNestedManyWithoutMapInput
    poi?: poiUncheckedCreateNestedManyWithoutMapInput
  }

  export type mapCreateOrConnectWithoutZoneInput = {
    where: mapWhereUniqueInput
    create: XOR<mapCreateWithoutZoneInput, mapUncheckedCreateWithoutZoneInput>
  }

  export type zone_typeCreateWithoutZone_zone_type_idTozone_typeInput = {
    created_at?: Date | string
    type?: string | null
    color?: string | null
    icon?: string | null
    name?: string | null
    description?: string | null
    priority?: string | null
    accessible?: boolean | null
    zone_zone_zone_typeTozone_type?: zoneCreateNestedManyWithoutZone_type_zone_zone_typeTozone_typeInput
  }

  export type zone_typeUncheckedCreateWithoutZone_zone_type_idTozone_typeInput = {
    id?: number
    created_at?: Date | string
    type?: string | null
    color?: string | null
    icon?: string | null
    name?: string | null
    description?: string | null
    priority?: string | null
    accessible?: boolean | null
    zone_zone_zone_typeTozone_type?: zoneUncheckedCreateNestedManyWithoutZone_type_zone_zone_typeTozone_typeInput
  }

  export type zone_typeCreateOrConnectWithoutZone_zone_type_idTozone_typeInput = {
    where: zone_typeWhereUniqueInput
    create: XOR<zone_typeCreateWithoutZone_zone_type_idTozone_typeInput, zone_typeUncheckedCreateWithoutZone_zone_type_idTozone_typeInput>
  }

  export type zone_typeCreateWithoutZone_zone_zone_typeTozone_typeInput = {
    created_at?: Date | string
    type?: string | null
    color?: string | null
    icon?: string | null
    name?: string | null
    description?: string | null
    priority?: string | null
    accessible?: boolean | null
    zone_zone_type_idTozone_type?: zoneCreateNestedManyWithoutZone_type_zone_type_idTozone_typeInput
  }

  export type zone_typeUncheckedCreateWithoutZone_zone_zone_typeTozone_typeInput = {
    id?: number
    created_at?: Date | string
    type?: string | null
    color?: string | null
    icon?: string | null
    name?: string | null
    description?: string | null
    priority?: string | null
    accessible?: boolean | null
    zone_zone_type_idTozone_type?: zoneUncheckedCreateNestedManyWithoutZone_type_zone_type_idTozone_typeInput
  }

  export type zone_typeCreateOrConnectWithoutZone_zone_zone_typeTozone_typeInput = {
    where: zone_typeWhereUniqueInput
    create: XOR<zone_typeCreateWithoutZone_zone_zone_typeTozone_typeInput, zone_typeUncheckedCreateWithoutZone_zone_zone_typeTozone_typeInput>
  }

  export type poi_zoneUpsertWithWhereUniqueWithoutZoneInput = {
    where: poi_zoneWhereUniqueInput
    update: XOR<poi_zoneUpdateWithoutZoneInput, poi_zoneUncheckedUpdateWithoutZoneInput>
    create: XOR<poi_zoneCreateWithoutZoneInput, poi_zoneUncheckedCreateWithoutZoneInput>
  }

  export type poi_zoneUpdateWithWhereUniqueWithoutZoneInput = {
    where: poi_zoneWhereUniqueInput
    data: XOR<poi_zoneUpdateWithoutZoneInput, poi_zoneUncheckedUpdateWithoutZoneInput>
  }

  export type poi_zoneUpdateManyWithWhereWithoutZoneInput = {
    where: poi_zoneScalarWhereInput
    data: XOR<poi_zoneUpdateManyMutationInput, poi_zoneUncheckedUpdateManyWithoutZoneInput>
  }

  export type environmentUpsertWithoutZoneInput = {
    update: XOR<environmentUpdateWithoutZoneInput, environmentUncheckedUpdateWithoutZoneInput>
    create: XOR<environmentCreateWithoutZoneInput, environmentUncheckedCreateWithoutZoneInput>
    where?: environmentWhereInput
  }

  export type environmentUpdateToOneWithWhereWithoutZoneInput = {
    where?: environmentWhereInput
    data: XOR<environmentUpdateWithoutZoneInput, environmentUncheckedUpdateWithoutZoneInput>
  }

  export type environmentUpdateWithoutZoneInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    env_delimiter?: env_delimiterUpdateManyWithoutEnvironmentNestedInput
    env_user?: env_userUpdateManyWithoutEnvironmentNestedInput
    map?: mapUpdateOneWithoutEnvironmentNestedInput
    poi?: poiUpdateManyWithoutEnvironmentNestedInput
  }

  export type environmentUncheckedUpdateWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    env_delimiter?: env_delimiterUncheckedUpdateManyWithoutEnvironmentNestedInput
    env_user?: env_userUncheckedUpdateManyWithoutEnvironmentNestedInput
    poi?: poiUncheckedUpdateManyWithoutEnvironmentNestedInput
  }

  export type mapUpsertWithoutZoneInput = {
    update: XOR<mapUpdateWithoutZoneInput, mapUncheckedUpdateWithoutZoneInput>
    create: XOR<mapCreateWithoutZoneInput, mapUncheckedCreateWithoutZoneInput>
    where?: mapWhereInput
  }

  export type mapUpdateToOneWithWhereWithoutZoneInput = {
    where?: mapWhereInput
    data: XOR<mapUpdateWithoutZoneInput, mapUncheckedUpdateWithoutZoneInput>
  }

  export type mapUpdateWithoutZoneInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: environmentUpdateManyWithoutMapNestedInput
    format?: formatUpdateOneWithoutMapNestedInput
    poi?: poiUpdateManyWithoutMapNestedInput
  }

  export type mapUncheckedUpdateWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    format_id?: NullableIntFieldUpdateOperationsInput | number | null
    environment?: environmentUncheckedUpdateManyWithoutMapNestedInput
    poi?: poiUncheckedUpdateManyWithoutMapNestedInput
  }

  export type zone_typeUpsertWithoutZone_zone_type_idTozone_typeInput = {
    update: XOR<zone_typeUpdateWithoutZone_zone_type_idTozone_typeInput, zone_typeUncheckedUpdateWithoutZone_zone_type_idTozone_typeInput>
    create: XOR<zone_typeCreateWithoutZone_zone_type_idTozone_typeInput, zone_typeUncheckedCreateWithoutZone_zone_type_idTozone_typeInput>
    where?: zone_typeWhereInput
  }

  export type zone_typeUpdateToOneWithWhereWithoutZone_zone_type_idTozone_typeInput = {
    where?: zone_typeWhereInput
    data: XOR<zone_typeUpdateWithoutZone_zone_type_idTozone_typeInput, zone_typeUncheckedUpdateWithoutZone_zone_type_idTozone_typeInput>
  }

  export type zone_typeUpdateWithoutZone_zone_type_idTozone_typeInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    accessible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    zone_zone_zone_typeTozone_type?: zoneUpdateManyWithoutZone_type_zone_zone_typeTozone_typeNestedInput
  }

  export type zone_typeUncheckedUpdateWithoutZone_zone_type_idTozone_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    accessible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    zone_zone_zone_typeTozone_type?: zoneUncheckedUpdateManyWithoutZone_type_zone_zone_typeTozone_typeNestedInput
  }

  export type zone_typeUpsertWithoutZone_zone_zone_typeTozone_typeInput = {
    update: XOR<zone_typeUpdateWithoutZone_zone_zone_typeTozone_typeInput, zone_typeUncheckedUpdateWithoutZone_zone_zone_typeTozone_typeInput>
    create: XOR<zone_typeCreateWithoutZone_zone_zone_typeTozone_typeInput, zone_typeUncheckedCreateWithoutZone_zone_zone_typeTozone_typeInput>
    where?: zone_typeWhereInput
  }

  export type zone_typeUpdateToOneWithWhereWithoutZone_zone_zone_typeTozone_typeInput = {
    where?: zone_typeWhereInput
    data: XOR<zone_typeUpdateWithoutZone_zone_zone_typeTozone_typeInput, zone_typeUncheckedUpdateWithoutZone_zone_zone_typeTozone_typeInput>
  }

  export type zone_typeUpdateWithoutZone_zone_zone_typeTozone_typeInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    accessible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    zone_zone_type_idTozone_type?: zoneUpdateManyWithoutZone_type_zone_type_idTozone_typeNestedInput
  }

  export type zone_typeUncheckedUpdateWithoutZone_zone_zone_typeTozone_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    accessible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    zone_zone_type_idTozone_type?: zoneUncheckedUpdateManyWithoutZone_type_zone_type_idTozone_typeNestedInput
  }

  export type zoneCreateWithoutZone_type_zone_type_idTozone_typeInput = {
    created_at?: Date | string
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: Date | string | null
    poi_zone?: poi_zoneCreateNestedManyWithoutZoneInput
    environment?: environmentCreateNestedOneWithoutZoneInput
    map?: mapCreateNestedOneWithoutZoneInput
    zone_type_zone_zone_typeTozone_type?: zone_typeCreateNestedOneWithoutZone_zone_zone_typeTozone_typeInput
  }

  export type zoneUncheckedCreateWithoutZone_type_zone_type_idTozone_typeInput = {
    id?: number
    created_at?: Date | string
    env_id?: number | null
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: Date | string | null
    map_id?: number | null
    zone_type?: number | null
    poi_zone?: poi_zoneUncheckedCreateNestedManyWithoutZoneInput
  }

  export type zoneCreateOrConnectWithoutZone_type_zone_type_idTozone_typeInput = {
    where: zoneWhereUniqueInput
    create: XOR<zoneCreateWithoutZone_type_zone_type_idTozone_typeInput, zoneUncheckedCreateWithoutZone_type_zone_type_idTozone_typeInput>
  }

  export type zoneCreateManyZone_type_zone_type_idTozone_typeInputEnvelope = {
    data: zoneCreateManyZone_type_zone_type_idTozone_typeInput | zoneCreateManyZone_type_zone_type_idTozone_typeInput[]
    skipDuplicates?: boolean
  }

  export type zoneCreateWithoutZone_type_zone_zone_typeTozone_typeInput = {
    created_at?: Date | string
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: Date | string | null
    poi_zone?: poi_zoneCreateNestedManyWithoutZoneInput
    environment?: environmentCreateNestedOneWithoutZoneInput
    map?: mapCreateNestedOneWithoutZoneInput
    zone_type_zone_type_idTozone_type?: zone_typeCreateNestedOneWithoutZone_zone_type_idTozone_typeInput
  }

  export type zoneUncheckedCreateWithoutZone_type_zone_zone_typeTozone_typeInput = {
    id?: number
    created_at?: Date | string
    env_id?: number | null
    name?: string | null
    description?: string | null
    type_id?: number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: Date | string | null
    map_id?: number | null
    poi_zone?: poi_zoneUncheckedCreateNestedManyWithoutZoneInput
  }

  export type zoneCreateOrConnectWithoutZone_type_zone_zone_typeTozone_typeInput = {
    where: zoneWhereUniqueInput
    create: XOR<zoneCreateWithoutZone_type_zone_zone_typeTozone_typeInput, zoneUncheckedCreateWithoutZone_type_zone_zone_typeTozone_typeInput>
  }

  export type zoneCreateManyZone_type_zone_zone_typeTozone_typeInputEnvelope = {
    data: zoneCreateManyZone_type_zone_zone_typeTozone_typeInput | zoneCreateManyZone_type_zone_zone_typeTozone_typeInput[]
    skipDuplicates?: boolean
  }

  export type zoneUpsertWithWhereUniqueWithoutZone_type_zone_type_idTozone_typeInput = {
    where: zoneWhereUniqueInput
    update: XOR<zoneUpdateWithoutZone_type_zone_type_idTozone_typeInput, zoneUncheckedUpdateWithoutZone_type_zone_type_idTozone_typeInput>
    create: XOR<zoneCreateWithoutZone_type_zone_type_idTozone_typeInput, zoneUncheckedCreateWithoutZone_type_zone_type_idTozone_typeInput>
  }

  export type zoneUpdateWithWhereUniqueWithoutZone_type_zone_type_idTozone_typeInput = {
    where: zoneWhereUniqueInput
    data: XOR<zoneUpdateWithoutZone_type_zone_type_idTozone_typeInput, zoneUncheckedUpdateWithoutZone_type_zone_type_idTozone_typeInput>
  }

  export type zoneUpdateManyWithWhereWithoutZone_type_zone_type_idTozone_typeInput = {
    where: zoneScalarWhereInput
    data: XOR<zoneUpdateManyMutationInput, zoneUncheckedUpdateManyWithoutZone_type_zone_type_idTozone_typeInput>
  }

  export type zoneUpsertWithWhereUniqueWithoutZone_type_zone_zone_typeTozone_typeInput = {
    where: zoneWhereUniqueInput
    update: XOR<zoneUpdateWithoutZone_type_zone_zone_typeTozone_typeInput, zoneUncheckedUpdateWithoutZone_type_zone_zone_typeTozone_typeInput>
    create: XOR<zoneCreateWithoutZone_type_zone_zone_typeTozone_typeInput, zoneUncheckedCreateWithoutZone_type_zone_zone_typeTozone_typeInput>
  }

  export type zoneUpdateWithWhereUniqueWithoutZone_type_zone_zone_typeTozone_typeInput = {
    where: zoneWhereUniqueInput
    data: XOR<zoneUpdateWithoutZone_type_zone_zone_typeTozone_typeInput, zoneUncheckedUpdateWithoutZone_type_zone_zone_typeTozone_typeInput>
  }

  export type zoneUpdateManyWithWhereWithoutZone_type_zone_zone_typeTozone_typeInput = {
    where: zoneScalarWhereInput
    data: XOR<zoneUpdateManyMutationInput, zoneUncheckedUpdateManyWithoutZone_type_zone_zone_typeTozone_typeInput>
  }

  export type panne_historyCreateManyAlertInput = {
    id?: number
  }

  export type panne_historyUpdateWithoutAlertInput = {

  }

  export type panne_historyUncheckedUpdateWithoutAlertInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type panne_historyUncheckedUpdateManyWithoutAlertInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type alertCreateManyDeviceInput = {
    id?: number
    type: string
    time: Date | string
    date: Date | string
    zone: string
    status: string
    level: $Enums.level_new
  }

  export type purchase_historyCreateManyDeviceInput = {
    id?: number
    date?: Date | string
    user_id?: number | null
    public?: boolean | null
  }

  export type alertUpdateWithoutDeviceInput = {
    type?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: Enumlevel_newFieldUpdateOperationsInput | $Enums.level_new
    panne_history?: panne_historyUpdateManyWithoutAlertNestedInput
  }

  export type alertUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: Enumlevel_newFieldUpdateOperationsInput | $Enums.level_new
    panne_history?: panne_historyUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type alertUncheckedUpdateManyWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    level?: Enumlevel_newFieldUpdateOperationsInput | $Enums.level_new
  }

  export type purchase_historyUpdateWithoutDeviceInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: userUpdateOneWithoutPurchase_historyNestedInput
  }

  export type purchase_historyUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type purchase_historyUncheckedUpdateManyWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type deviceCreateManyDevice_typeInput = {
    id?: number
    state_type_id: number
    user_id?: number | null
    mac_address: string
    software_version: string
    date_of_service: Date | string
    comm_state: boolean
    connection_state?: boolean | null
    battery_capacity?: number
    price?: number | null
  }

  export type deviceUpdateWithoutDevice_typeInput = {
    mac_address?: StringFieldUpdateOperationsInput | string
    software_version?: StringFieldUpdateOperationsInput | string
    date_of_service?: DateTimeFieldUpdateOperationsInput | Date | string
    comm_state?: BoolFieldUpdateOperationsInput | boolean
    connection_state?: NullableBoolFieldUpdateOperationsInput | boolean | null
    battery_capacity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    alert?: alertUpdateManyWithoutDeviceNestedInput
    state_type?: state_typeUpdateOneRequiredWithoutDeviceNestedInput
    user?: userUpdateOneWithoutDeviceNestedInput
    purchase_history?: purchase_historyUpdateManyWithoutDeviceNestedInput
  }

  export type deviceUncheckedUpdateWithoutDevice_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    state_type_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    mac_address?: StringFieldUpdateOperationsInput | string
    software_version?: StringFieldUpdateOperationsInput | string
    date_of_service?: DateTimeFieldUpdateOperationsInput | Date | string
    comm_state?: BoolFieldUpdateOperationsInput | boolean
    connection_state?: NullableBoolFieldUpdateOperationsInput | boolean | null
    battery_capacity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    alert?: alertUncheckedUpdateManyWithoutDeviceNestedInput
    purchase_history?: purchase_historyUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type deviceUncheckedUpdateManyWithoutDevice_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    state_type_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    mac_address?: StringFieldUpdateOperationsInput | string
    software_version?: StringFieldUpdateOperationsInput | string
    date_of_service?: DateTimeFieldUpdateOperationsInput | Date | string
    comm_state?: BoolFieldUpdateOperationsInput | boolean
    connection_state?: NullableBoolFieldUpdateOperationsInput | boolean | null
    battery_capacity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type env_delimiterCreateManyEnvironmentInput = {
    id?: number
    created_at?: Date | string
    updated_at?: Date | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    type?: string | null
  }

  export type env_userCreateManyEnvironmentInput = {
    id?: number
    user_id: number
  }

  export type poiCreateManyEnvironmentInput = {
    id?: number
    created_at?: Date | string
    category_id?: number | null
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: string | null
    map_id?: number | null
  }

  export type zoneCreateManyEnvironmentInput = {
    id?: number
    created_at?: Date | string
    name?: string | null
    description?: string | null
    type_id?: number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: Date | string | null
    map_id?: number | null
    zone_type?: number | null
  }

  export type env_delimiterUpdateWithoutEnvironmentInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type env_delimiterUncheckedUpdateWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type env_delimiterUncheckedUpdateManyWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type env_userUpdateWithoutEnvironmentInput = {
    user?: userUpdateOneRequiredWithoutEnv_userNestedInput
  }

  export type env_userUncheckedUpdateWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type env_userUncheckedUpdateManyWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type poiUpdateWithoutEnvironmentInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    poi_category?: poi_categoryUpdateOneWithoutPoiNestedInput
    map?: mapUpdateOneWithoutPoiNestedInput
    poi_zone?: poi_zoneUpdateManyWithoutPoiNestedInput
  }

  export type poiUncheckedUpdateWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
    poi_zone?: poi_zoneUncheckedUpdateManyWithoutPoiNestedInput
  }

  export type poiUncheckedUpdateManyWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type zoneUpdateWithoutEnvironmentInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poi_zone?: poi_zoneUpdateManyWithoutZoneNestedInput
    map?: mapUpdateOneWithoutZoneNestedInput
    zone_type_zone_type_idTozone_type?: zone_typeUpdateOneWithoutZone_zone_type_idTozone_typeNestedInput
    zone_type_zone_zone_typeTozone_type?: zone_typeUpdateOneWithoutZone_zone_zone_typeTozone_typeNestedInput
  }

  export type zoneUncheckedUpdateWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_type?: NullableIntFieldUpdateOperationsInput | number | null
    poi_zone?: poi_zoneUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type zoneUncheckedUpdateManyWithoutEnvironmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_type?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mapCreateManyFormatInput = {
    id?: number
    created_at?: Date | string
  }

  export type mapUpdateWithoutFormatInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: environmentUpdateManyWithoutMapNestedInput
    poi?: poiUpdateManyWithoutMapNestedInput
    zone?: zoneUpdateManyWithoutMapNestedInput
  }

  export type mapUncheckedUpdateWithoutFormatInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: environmentUncheckedUpdateManyWithoutMapNestedInput
    poi?: poiUncheckedUpdateManyWithoutMapNestedInput
    zone?: zoneUncheckedUpdateManyWithoutMapNestedInput
  }

  export type mapUncheckedUpdateManyWithoutFormatInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type environmentCreateManyMapInput = {
    id?: number
    name: string
    description?: string | null
    address?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_public?: boolean | null
    surface?: number | null
  }

  export type poiCreateManyMapInput = {
    id?: number
    created_at?: Date | string
    env_id?: number | null
    category_id?: number | null
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: string | null
  }

  export type zoneCreateManyMapInput = {
    id?: number
    created_at?: Date | string
    env_id?: number | null
    name?: string | null
    description?: string | null
    type_id?: number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: Date | string | null
    zone_type?: number | null
  }

  export type environmentUpdateWithoutMapInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    env_delimiter?: env_delimiterUpdateManyWithoutEnvironmentNestedInput
    env_user?: env_userUpdateManyWithoutEnvironmentNestedInput
    poi?: poiUpdateManyWithoutEnvironmentNestedInput
    zone?: zoneUpdateManyWithoutEnvironmentNestedInput
  }

  export type environmentUncheckedUpdateWithoutMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
    env_delimiter?: env_delimiterUncheckedUpdateManyWithoutEnvironmentNestedInput
    env_user?: env_userUncheckedUpdateManyWithoutEnvironmentNestedInput
    poi?: poiUncheckedUpdateManyWithoutEnvironmentNestedInput
    zone?: zoneUncheckedUpdateManyWithoutEnvironmentNestedInput
  }

  export type environmentUncheckedUpdateManyWithoutMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type poiUpdateWithoutMapInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    poi_category?: poi_categoryUpdateOneWithoutPoiNestedInput
    environment?: environmentUpdateOneWithoutPoiNestedInput
    poi_zone?: poi_zoneUpdateManyWithoutPoiNestedInput
  }

  export type poiUncheckedUpdateWithoutMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    poi_zone?: poi_zoneUncheckedUpdateManyWithoutPoiNestedInput
  }

  export type poiUncheckedUpdateManyWithoutMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type zoneUpdateWithoutMapInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poi_zone?: poi_zoneUpdateManyWithoutZoneNestedInput
    environment?: environmentUpdateOneWithoutZoneNestedInput
    zone_type_zone_type_idTozone_type?: zone_typeUpdateOneWithoutZone_zone_type_idTozone_typeNestedInput
    zone_type_zone_zone_typeTozone_type?: zone_typeUpdateOneWithoutZone_zone_zone_typeTozone_typeNestedInput
  }

  export type zoneUncheckedUpdateWithoutMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zone_type?: NullableIntFieldUpdateOperationsInput | number | null
    poi_zone?: poi_zoneUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type zoneUncheckedUpdateManyWithoutMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zone_type?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type poi_zoneCreateManyPoiInput = {
    id?: number
    created_at?: Date | string
    zone_id?: number | null
  }

  export type poi_zoneUpdateWithoutPoiInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: zoneUpdateOneWithoutPoi_zoneNestedInput
  }

  export type poi_zoneUncheckedUpdateWithoutPoiInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type poi_zoneUncheckedUpdateManyWithoutPoiInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    zone_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type poiCreateManyPoi_categoryInput = {
    id?: number
    created_at?: Date | string
    env_id?: number | null
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: string | null
    map_id?: number | null
  }

  export type poiUpdateWithoutPoi_categoryInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: environmentUpdateOneWithoutPoiNestedInput
    map?: mapUpdateOneWithoutPoiNestedInput
    poi_zone?: poi_zoneUpdateManyWithoutPoiNestedInput
  }

  export type poiUncheckedUpdateWithoutPoi_categoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
    poi_zone?: poi_zoneUncheckedUpdateManyWithoutPoiNestedInput
  }

  export type poiUncheckedUpdateManyWithoutPoi_categoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type deviceCreateManyState_typeInput = {
    id?: number
    type_id: number
    user_id?: number | null
    mac_address: string
    software_version: string
    date_of_service: Date | string
    comm_state: boolean
    connection_state?: boolean | null
    battery_capacity?: number
    price?: number | null
  }

  export type deviceUpdateWithoutState_typeInput = {
    mac_address?: StringFieldUpdateOperationsInput | string
    software_version?: StringFieldUpdateOperationsInput | string
    date_of_service?: DateTimeFieldUpdateOperationsInput | Date | string
    comm_state?: BoolFieldUpdateOperationsInput | boolean
    connection_state?: NullableBoolFieldUpdateOperationsInput | boolean | null
    battery_capacity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    alert?: alertUpdateManyWithoutDeviceNestedInput
    device_type?: device_typeUpdateOneRequiredWithoutDeviceNestedInput
    user?: userUpdateOneWithoutDeviceNestedInput
    purchase_history?: purchase_historyUpdateManyWithoutDeviceNestedInput
  }

  export type deviceUncheckedUpdateWithoutState_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    mac_address?: StringFieldUpdateOperationsInput | string
    software_version?: StringFieldUpdateOperationsInput | string
    date_of_service?: DateTimeFieldUpdateOperationsInput | Date | string
    comm_state?: BoolFieldUpdateOperationsInput | boolean
    connection_state?: NullableBoolFieldUpdateOperationsInput | boolean | null
    battery_capacity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    alert?: alertUncheckedUpdateManyWithoutDeviceNestedInput
    purchase_history?: purchase_historyUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type deviceUncheckedUpdateManyWithoutState_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    mac_address?: StringFieldUpdateOperationsInput | string
    software_version?: StringFieldUpdateOperationsInput | string
    date_of_service?: DateTimeFieldUpdateOperationsInput | Date | string
    comm_state?: BoolFieldUpdateOperationsInput | boolean
    connection_state?: NullableBoolFieldUpdateOperationsInput | boolean | null
    battery_capacity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type deviceCreateManyUserInput = {
    id?: number
    type_id: number
    state_type_id: number
    mac_address: string
    software_version: string
    date_of_service: Date | string
    comm_state: boolean
    connection_state?: boolean | null
    battery_capacity?: number
    price?: number | null
  }

  export type env_userCreateManyUserInput = {
    id?: number
    env_id?: number | null
  }

  export type helper_userCreateManyUser_helper_user_helper_idTouserInput = {
    id?: number
    user_id?: number | null
    state?: string | null
  }

  export type helper_userCreateManyUser_helper_user_user_idTouserInput = {
    id?: number
    helper_id?: number | null
    state?: string | null
  }

  export type intervention_historyCreateManyUserInput = {
    id?: number
    device_id?: number | null
    scheduled_date: Date | string
    completion_date?: Date | string | null
    description?: string | null
    status?: string | null
    type?: $Enums.intervention_type | null
    title?: string | null
    location?: string | null
  }

  export type purchase_historyCreateManyUserInput = {
    id?: number
    date?: Date | string
    device_id?: number | null
    public?: boolean | null
  }

  export type deviceUpdateWithoutUserInput = {
    mac_address?: StringFieldUpdateOperationsInput | string
    software_version?: StringFieldUpdateOperationsInput | string
    date_of_service?: DateTimeFieldUpdateOperationsInput | Date | string
    comm_state?: BoolFieldUpdateOperationsInput | boolean
    connection_state?: NullableBoolFieldUpdateOperationsInput | boolean | null
    battery_capacity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    alert?: alertUpdateManyWithoutDeviceNestedInput
    state_type?: state_typeUpdateOneRequiredWithoutDeviceNestedInput
    device_type?: device_typeUpdateOneRequiredWithoutDeviceNestedInput
    purchase_history?: purchase_historyUpdateManyWithoutDeviceNestedInput
  }

  export type deviceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    state_type_id?: IntFieldUpdateOperationsInput | number
    mac_address?: StringFieldUpdateOperationsInput | string
    software_version?: StringFieldUpdateOperationsInput | string
    date_of_service?: DateTimeFieldUpdateOperationsInput | Date | string
    comm_state?: BoolFieldUpdateOperationsInput | boolean
    connection_state?: NullableBoolFieldUpdateOperationsInput | boolean | null
    battery_capacity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    alert?: alertUncheckedUpdateManyWithoutDeviceNestedInput
    purchase_history?: purchase_historyUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type deviceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    state_type_id?: IntFieldUpdateOperationsInput | number
    mac_address?: StringFieldUpdateOperationsInput | string
    software_version?: StringFieldUpdateOperationsInput | string
    date_of_service?: DateTimeFieldUpdateOperationsInput | Date | string
    comm_state?: BoolFieldUpdateOperationsInput | boolean
    connection_state?: NullableBoolFieldUpdateOperationsInput | boolean | null
    battery_capacity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type env_userUpdateWithoutUserInput = {
    environment?: environmentUpdateOneWithoutEnv_userNestedInput
  }

  export type env_userUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type env_userUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type helper_userUpdateWithoutUser_helper_user_helper_idTouserInput = {
    state?: NullableStringFieldUpdateOperationsInput | string | null
    user_helper_user_user_idTouser?: userUpdateOneWithoutHelper_user_helper_user_user_idTouserNestedInput
  }

  export type helper_userUncheckedUpdateWithoutUser_helper_user_helper_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type helper_userUncheckedUpdateManyWithoutUser_helper_user_helper_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type helper_userUpdateWithoutUser_helper_user_user_idTouserInput = {
    state?: NullableStringFieldUpdateOperationsInput | string | null
    user_helper_user_helper_idTouser?: userUpdateOneWithoutHelper_user_helper_user_helper_idTouserNestedInput
  }

  export type helper_userUncheckedUpdateWithoutUser_helper_user_user_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    helper_id?: NullableIntFieldUpdateOperationsInput | number | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type helper_userUncheckedUpdateManyWithoutUser_helper_user_user_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    helper_id?: NullableIntFieldUpdateOperationsInput | number | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type intervention_historyUpdateWithoutUserInput = {
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumintervention_typeFieldUpdateOperationsInput | $Enums.intervention_type | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type intervention_historyUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumintervention_typeFieldUpdateOperationsInput | $Enums.intervention_type | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type intervention_historyUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    scheduled_date?: DateTimeFieldUpdateOperationsInput | Date | string
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumintervention_typeFieldUpdateOperationsInput | $Enums.intervention_type | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type purchase_historyUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: deviceUpdateOneWithoutPurchase_historyNestedInput
  }

  export type purchase_historyUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type purchase_historyUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type userCreateManyUser_typeInput = {
    id?: number
    created_at?: Date | string
    family_name?: string | null
    first_name?: string | null
    phone_number?: string | null
    password?: string | null
    email?: string | null
    sex?: string | null
    street?: string | null
    city?: string | null
    birth_date?: Date | string | null
    Identifier?: string | null
  }

  export type userUpdateWithoutUser_typeInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    device?: deviceUpdateManyWithoutUserNestedInput
    env_user?: env_userUpdateManyWithoutUserNestedInput
    helper_user_helper_user_helper_idTouser?: helper_userUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput
    helper_user_helper_user_user_idTouser?: helper_userUpdateManyWithoutUser_helper_user_user_idTouserNestedInput
    intervention_history?: intervention_historyUpdateManyWithoutUserNestedInput
    localisation?: localisationUpdateOneWithoutUserNestedInput
    purchase_history?: purchase_historyUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUser_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
    device?: deviceUncheckedUpdateManyWithoutUserNestedInput
    env_user?: env_userUncheckedUpdateManyWithoutUserNestedInput
    helper_user_helper_user_helper_idTouser?: helper_userUncheckedUpdateManyWithoutUser_helper_user_helper_idTouserNestedInput
    helper_user_helper_user_user_idTouser?: helper_userUncheckedUpdateManyWithoutUser_helper_user_user_idTouserNestedInput
    intervention_history?: intervention_historyUncheckedUpdateManyWithoutUserNestedInput
    localisation?: localisationUncheckedUpdateOneWithoutUserNestedInput
    purchase_history?: purchase_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutUser_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    family_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Identifier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type poi_zoneCreateManyZoneInput = {
    id?: number
    created_at?: Date | string
    poi_id?: number | null
  }

  export type poi_zoneUpdateWithoutZoneInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    poi?: poiUpdateOneWithoutPoi_zoneNestedInput
  }

  export type poi_zoneUncheckedUpdateWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    poi_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type poi_zoneUncheckedUpdateManyWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    poi_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type zoneCreateManyZone_type_zone_type_idTozone_typeInput = {
    id?: number
    created_at?: Date | string
    env_id?: number | null
    name?: string | null
    description?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: Date | string | null
    map_id?: number | null
    zone_type?: number | null
  }

  export type zoneCreateManyZone_type_zone_zone_typeTozone_typeInput = {
    id?: number
    created_at?: Date | string
    env_id?: number | null
    name?: string | null
    description?: string | null
    type_id?: number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: Date | string | null
    map_id?: number | null
  }

  export type zoneUpdateWithoutZone_type_zone_type_idTozone_typeInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poi_zone?: poi_zoneUpdateManyWithoutZoneNestedInput
    environment?: environmentUpdateOneWithoutZoneNestedInput
    map?: mapUpdateOneWithoutZoneNestedInput
    zone_type_zone_zone_typeTozone_type?: zone_typeUpdateOneWithoutZone_zone_zone_typeTozone_typeNestedInput
  }

  export type zoneUncheckedUpdateWithoutZone_type_zone_type_idTozone_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_type?: NullableIntFieldUpdateOperationsInput | number | null
    poi_zone?: poi_zoneUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type zoneUncheckedUpdateManyWithoutZone_type_zone_type_idTozone_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
    zone_type?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type zoneUpdateWithoutZone_type_zone_zone_typeTozone_typeInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    poi_zone?: poi_zoneUpdateManyWithoutZoneNestedInput
    environment?: environmentUpdateOneWithoutZoneNestedInput
    map?: mapUpdateOneWithoutZoneNestedInput
    zone_type_zone_type_idTozone_type?: zone_typeUpdateOneWithoutZone_zone_type_idTozone_typeNestedInput
  }

  export type zoneUncheckedUpdateWithoutZone_type_zone_zone_typeTozone_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
    poi_zone?: poi_zoneUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type zoneUncheckedUpdateManyWithoutZone_type_zone_zone_typeTozone_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    env_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    map_id?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}